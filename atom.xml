<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[聂同学]]></title>
  <link href="http://nielinjie.github.io/atom.xml" rel="self"/>
  <link href="http://nielinjie.github.io/"/>
  <updated>2014-06-16T19:41:03+08:00</updated>
  <id>http://nielinjie.github.io/</id>
  <author>
    <name><![CDATA[nielinjie]]></name>
    <email><![CDATA[nielinjie@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[给老爷爷系统（八）：特征机制]]></title>
    <link href="http://nielinjie.github.io/blog/2014/06/16/feature/"/>
    <updated>2014-06-16T21:06:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/06/16/feature</id>
    <content type="html"><![CDATA[<blockquote><p>这是一个老爷爷系统。</p></blockquote>

<p>在《<a href="http://nielinjie.github.io/blog/2013/09/01/dsl1/">一场似非而是的DSL</a>》和《<a href="http://nielinjie.github.io/blog/2014/06/16/3d">三个划分维度</a>》中，
已经提到了“特征机制”。这里专门讲一下。</p>

<!-- more -->


<p>“特征机制”，是一种动态选择机制，用来协同“通用”和“专用”两个层次。
当通用逻辑运行到某个点，需要执行专用逻辑，我们首先需要找到正确地专用逻辑。</p>

<ul>
<li>我们把通用逻辑中需要运行专用机制，也就是可能发生扩展的点，称为“扩展点”。</li>
<li>不同的“差异来源”带来不同的“业务差异”，通过在扩展点上填入适当的“扩展”来实现差异化的专用逻辑。</li>
<li>所谓“特征”，就是一条知识，描述了当在何种“业务差异”的处理中，需要在哪些个扩展点填入哪些个“扩展”。</li>
<li>所谓“特征机制”，就是当系统运行到一个扩展点的时候，查找到正确的特征，填入正确的扩展并运行的机制。</li>
</ul>


<p>特征机制的实现在设计上有意识地做到“操作层”和“知识层”分离，以便二者能够分别进化，这点在《<a href="http://nielinjie.github.io/blog/2013/09/01/dsl1/">一场似非而是的DSL</a>》已经说明了。</p>

<p>下面的图体现了上面这些概念的静态关系。除了主干之外，枝节也说一下：</p>

<ul>
<li>“业务差异”需要一个载体，就是“特征拥有者”，比如“签报”、“用户”等领域对象都可以是特征拥有者，这些拥有者的属性导致了差异。</li>
<li>同一个拥有者的特征可能来源于不同的差异，其中有可能会相互影响甚至冲突，这时候需要一个裁决者，这就是“特征集”。</li>
<li>“特征要求”是拥有者的属性与特征之间的映射，体现为“业务属性”和“业务事件”。</li>
<li>特征由特征要求决定，可以在需要特征时刷新，也可以当“业务属性”改变或“业务事件”发生时刷新。</li>
</ul>


<p><img src="http://nielinjie.github.io/images/feature/feature2.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给老爷爷系统（六）：重构（二）]]></title>
    <link href="http://nielinjie.github.io/blog/2014/06/11/refactory2/"/>
    <updated>2014-06-11T20:06:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/06/11/refactory2</id>
    <content type="html"><![CDATA[<blockquote><p>这是一个老爷爷系统。</p></blockquote>

<p>还是一篇补记，主要讲讲为什么是重构而不是重写。</p>

<!-- more -->


<p>同事们喜欢重写系统，好多别的老爷爷老态龙钟之后都是被重写的。
我们选择重构不重写的原因主要有三点：</p>

<ul>
<li>代码具有高价值，是可用和满足需求的。重写就意味着要放弃这些价值。</li>
<li>没有现成的需求。由于开发年代久远，人员流动，而用户也非常分散，没有人能告诉我们需求。
唯一可能的就是通读代码，反推出需求。这样做，无疑是成本高，风险大。</li>
<li>能否解决代码系统腐化根源？这一点其实是我们考虑的重点。重写容易，
如何防止重写的系统再次变坏，却不是件简单的任务。
我们认为在重构代码的过程中，可以教育和锻炼团队，通过寻找让系统变好的方法，来掌握防止或缓解系统变坏的手段。
这样不仅让本系统的情况好转，也可以给其他正在或即将变坏的系统提供借鉴。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给老爷爷系统（五）：重构（一）]]></title>
    <link href="http://nielinjie.github.io/blog/2014/06/09/refactory/"/>
    <updated>2014-06-09T20:06:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/06/09/refactory</id>
    <content type="html"><![CDATA[<blockquote><p>这是一个老爷爷系统。</p></blockquote>

<p>这是一篇补记，说的是在刚刚接手老爷爷系统的时候。</p>

<!-- more -->


<p>系统老不是问题，老而失控才是问题。我们的老爷爷系统就遇到了老而失控的问题。</p>

<p>系统腐化、大泥球，讲的大概都是一个意思：需求不停、补丁重重、代码堆积、逻辑纠缠。
随便一个小改动，都如履薄冰，面对着巨大的复杂性。越来越复杂、越来越纠缠，
慢慢地（应该说是很快地 &ndash;_&ndash;!!）接近了凡人能处理的极限。</p>

<p>我们研究了代码的结构和历史，发现主要问题是按照“功能”来安置代码，逻辑都放在一个功能入口的纵切面上。
以我们这个系统的具体情况<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>来说，这个纵切面，就是一条线：Controller → Service → DAO。
所有的代码，都分布在这条线上。
整个类似于Transaction Script模式。Transaction Script本身难说有什么问题，问题是这个模式只能面对比较小规模的领域逻辑，
当领域逻辑复杂度增加的时候，Transaction Script模式就难堪重任了。问题体现出来主要在两个方面：</p>

<ul>
<li>补丁：当一个功能涉及到的领域逻辑越来越多时，功能的代码上就依附了各种各样的领域逻辑代码。比如审批一个单据，逐渐贴上了用户授权、时效检查等等代码，如果“审批”功能本身修改，就得面对成倍增加的复杂性。</li>
<li>碎片：同一类的领域逻辑，由于在各个功能都要使用，代码就被分散到了各个功能的代码里面。比如上面说的“用户授权”，在多个功能的代码里都有分布，一旦需要改动，得从各个功能中找出来一一修改，复杂性可想而知。</li>
</ul>


<p>应对的办法是什么呢？简单两个字——划分。</p>

<p>我们的划分标准选择的是领域相关程度。
关于“用户”的代码集中在一起，关于“时效”的代码也集中在一起。
甚至“功能”的主要代码，也按照领域相关程度来放入不同的区域，
比如“审批”、&#8221;退回&#8221;都是一种对单据的状态流转，它跟为单据设置“审批人”就不是同一类，不放在一起。
而功能入口的纵切面上，只有调用这些代码的代码。</p>

<p>需要说明一下的是我们这里说“划分”的标准是“领域”，这个跟“领域驱动设计（DDD）”并没有太大关系，
大家不要搞混了。
我们的目的只是“划分”。</p>

<p>（<a href="http://nielinjie.github.io/blog/2014/06/11/refactory2">下篇继续</a>）</p>

<p><img src="http://nielinjie.github.io/images/refactory/refactory.png"></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>系统采用类似SpringMVC的一个定制框架。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给老爷爷系统（四）：如何描述系统？（三）]]></title>
    <link href="http://nielinjie.github.io/blog/2014/06/07/view3/"/>
    <updated>2014-06-07T18:06:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/06/07/view3</id>
    <content type="html"><![CDATA[<blockquote><p>这是一个老爷爷系统。</p></blockquote>

<p>这一篇讲讲如何实现的问题。</p>

<!-- more -->


<p>实现方面主要考虑了两个要点：</p>

<ul>
<li>如何构建和维护：要快速地建立和编辑，能够加入版本管理，能够在各方面间共享。</li>
<li>如何展现：各方面要容易地挂载自己的关注点数据，同时跨角色观察的需求要求框架能同时挂载多方面的数据。</li>
</ul>


<p>我们为这两个要点选择了两种不同的形式。</p>

<p>一方面在构建和维护时，特征描述采用纯文本方式，可以说是一种简单地DSL。
DSL文件很方便人和机器阅读，同时放入SCM，实现版本管理和角色间共享。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>审批/逐个审批
</span><span class='line'>  -i 查看签报详细信息
</span><span class='line'>  -i 输入审批意见
</span><span class='line'>      -g 使用默认意见
</span><span class='line'>      -g 手工输入意见
</span><span class='line'>      -g 语音输入意见
</span><span class='line'>  -i 选择用户
</span><span class='line'>    签报
</span><span class='line'>    用户
</span><span class='line'>批量审批
</span><span class='line'>    -e 逐个审批
</span><span class='line'>    -i 查看待处理文件列表
</span><span class='line'>    -i 点击审批按钮
</span><span class='line'>……</span></code></pre></td></tr></table></div></figure>


<p>另一方面在展现时，我们解析DSL，图形化交互式（并且略显炫酷滴 :-D）地展示。
下面展示的是目前的状况。</p>

<ul>
<li>左边的图，是“系统特征”，由黄色椭圆形表示的领域过程、绿色圆形表示的领域实体，以及他们之间的连线构成。</li>
<li>右边的下拉菜单，是由各方面提供的关注点数据，可以按需要附加到“系统特征”上。比如这个截图上，
左边的图上面有个红色的大圆，就是将代码质量数据叠加上来。还有个深绿色的小点，是将代码结构的数据叠加上来。</li>
<li>除了可以以叠加的方式展示数据，还可以根据关注点数据对图进行过滤。</li>
</ul>


<p><img src="http://nielinjie.github.io/images/view/view3.png"></p>

<p>最后，代码在此：<a href="http://github.com/nielinjie/developTools">http://github.com/nielinjie/developTools</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[言论：结构的要素]]></title>
    <link href="http://nielinjie.github.io/blog/2014/06/07/structure/"/>
    <updated>2014-06-07T17:06:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/06/07/structure</id>
    <content type="html"><![CDATA[<p>结构的基本要素有：</p>

<ul>
<li>存在：一个元素是否存在。</li>
<li>边界：一个元素的定义和与其他元素的区别。</li>
<li>关系：一个元素与其他元素有没有联系。</li>
</ul>


<p>在基本之上，研究结构的另一些特征可能有帮助：</p>

<ul>
<li>聚合：元素与某些元素的关系不同于与其他元素。</li>
<li>层次：元素与另一些元素区别的意义取决于观察的角度。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给老爷爷系统（三）：如何描述系统？（二）]]></title>
    <link href="http://nielinjie.github.io/blog/2014/06/06/view2/"/>
    <updated>2014-06-06T18:06:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/06/06/view2</id>
    <content type="html"><![CDATA[<blockquote><p>这是一个老爷爷系统。</p></blockquote>

<p>上一篇谈到统一的系统特征描述的形式问题。觉得“功能”或者“领域模型”可能可以承担这个重任。</p>

<!-- more -->


<p>但功能和领域模型都不能直接使用：</p>

<ul>
<li>功能的问题是很难跟代码直接关联起来。</li>
<li>领域模型的问题是只有开发同学熟悉这个概念。SA、测试、开发经理等同学比较熟悉的是“功能”这个概念，
虽然他们对这个概念的定义不尽相同。</li>
</ul>


<p>我们希望我们的特征描述既可以将各方面关注点都联系起来，又可以让各方面都工作在自己熟悉的概念上。
于是我们尝试使用一种二者的混合体。</p>

<ul>
<li>从领域模型出发，以便我们能跟代码产生联系<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。代码非常重要，因为在运行时，代码决定的逻辑基本上是系统的一切。</li>
<li>弱化领域对象的定义，只描述它是否存在和与其他对象的关系<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。领域对象的定义显然是重要的，但我们现在要的是“框架”。</li>
<li>强调领域过程，弱化领域实体。实体常常被认为是分析的结果，看上去和“功能”没有关系，有些方面的同学不关注。</li>
<li>领域过程之间的关系划归为三种：Include、Extend、Generalization<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>。</li>
<li>领域过程与实体间，只有一种，引用关系。实体与实体间的关系，不再描述。</li>
</ul>


<p>总的来说，这是领域模型的一种裁剪，或者可能更准确地说法，是一种遮挡：暴露大家的共同关注点，隐藏其他。</p>

<p>（<a href="http://nielinjie.github.io/blog/2014/06/07/view3">再下篇继续</a>）</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>逻辑按领域结构划分，在这个系统没完全实现：<a href="http://nielinjie.github.io/blog/2014/06/09/refactory">重构</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>领域模型是一个领域对象的结构，<a href="http://nielinjie.github.io/blog/2014/06/07/structure">结构的要素</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>没错，跟UML use case图里面的三种关系相同。这并非偶然，我们认为所有的过程之间，都是这三种关系。<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给老爷爷系统（二）：如何描述系统？（一）]]></title>
    <link href="http://nielinjie.github.io/blog/2014/06/05/view/"/>
    <updated>2014-06-05T20:06:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/06/05/view</id>
    <content type="html"><![CDATA[<blockquote><p>这是一个老爷爷系统。</p></blockquote>

<p>对于老爷爷系统，我们发现特别难以回答一个问题：系统是什么样的？它正在如何发展？</p>

<!-- more -->


<p>团队中不同的角色都在尝试解决这个问题。
上次<a href="http://nielinjie.github.io/blog/2014/04/24/aa3/">有篇blog</a>提到:</p>

<blockquote><p>SA同学正在整理全局“功能地图”、测试同学整理“全量测试案例”</p></blockquote>

<p>而开发团队和架构师，则在整理“领域地图”。</p>

<p>这些不同的角色，对系统有各自不同的关注点。但他们的关注点都需要一个框架组织起来，
这个框架就是系统特征。
上面说的这些各种“整理”，其实都包含了对系统特征进行整理和重建，然后再把自己的关注点挂载上去。
只不过他们从各自的目的出发，从各自的角度下手。</p>

<p>团队意识到：这些各方面的关注者可能需要共用同一个系统特征描述。</p>

<ul>
<li>可以减少分别构建和维护框架带来的工作量。<br/>
如果说分别构建框架只是时间和工作量的问题的话，分别维护和保持同步进化，则是几乎不可能做到的。</li>
<li>可以有机地将各个角色的关注点联系起来，形成对系统全方位、跨角色的观察监控，例如——

<ul>
<li>通过观察代码历史和代码质量，可以帮助划定测试重点覆盖区域。</li>
<li>通过观察相关的代码结构，可以帮助发现功能间关系特别是潜在的相互影响。</li>
<li>通过观察用户使用量数据，可以帮助评估代码重构的风险。</li>
</ul>
</li>
</ul>


<p>“统一系统特征描述”看来很重要，我们需要找到一个形式，可以承担这样的重任。</p>

<p>我们整理了各方面的关注点，大致如下，觉得处于中间位置的“功能”或者“领域模型”可能可以承担这个重任。</p>

<p>（<a href="http://nielinjie.github.io/blog/2014/06/06/view2/">下篇继续</a>）</p>

<p><img src="http://nielinjie.github.io/images/view/view.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[企业中需要什么样的社交？]]></title>
    <link href="http://nielinjie.github.io/blog/2014/06/05/social/"/>
    <updated>2014-06-05T16:06:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/06/05/social</id>
    <content type="html"><![CDATA[<p>正在考虑这个问题。
目前想到几点：</p>

<!-- more -->


<ul>
<li><p>业务系统、办公系统和所有工作环境中随时可以发起社交活动。<br/>
企业中的社交以工作中的沟通和协作为主，工作事务中随时可以发起社交很重要。</p></li>
<li><p>社交中要可以方便地包含“业务上下文” 。
不论是即时通讯、协作、还是活动流、备忘录，需要能方便地插入“业务上下文”。
“业务上下文”是由业务系统定义，是对一个事务进行介入的入口，比如正在处理的订单，正在审批的文件等。<br/>
大概包括功能、用户、业务对象等重要要素。</p></li>
<li><p>社交中要容易为单个事务建立独立的“通道”。<br/>
工作中的社交跟生活中的社交不同，并不希望各种人和事交织在一起，
而是希望每件事务可以有个相对隔离的空间，在这个空间中不要被其他人和事干扰。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[言论：时间]]></title>
    <link href="http://nielinjie.github.io/blog/2014/06/04/time/"/>
    <updated>2014-06-04T16:06:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/06/04/time</id>
    <content type="html"><![CDATA[<p>分解问题的维度除了空间还有时间，可以逐一解决，还可以渐进解决。大家莫忘记了。:&ndash;)</p>

<p>架构师要善于将大规模问题分解为可控可解决的小问题，也要善于把大跨度问题分解为可迭代可验证可积累的小问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[简单的灰度发布方案]]></title>
    <link href="http://nielinjie.github.io/blog/2014/05/28/huidu/"/>
    <updated>2014-05-28T20:06:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/05/28/huidu</id>
    <content type="html"><![CDATA[<p>正在策划一个系统的灰度发布，目前有个简单的方案，（简图如最后所示）。</p>

<!-- more -->


<ol>
<li>同一系统发布为ab两个版本，同时在生产可用。</li>
<li>用户访问先通过一个分流规则，这个规则决定访问a版本还是b版本。</li>
<li>分流规则主要涉及到用户的特征，可能涉及到一些业务逻辑。</li>
<li>分流规则可以由运营方便地（如果可以，随时地）维护生效。</li>
</ol>


<p>我们的问题主要是：</p>

<p>分流这部分应该是一种常见的反向代理，不太熟悉这类组件。公司里用得比较多的时f5。
如果利用f5、nginx之类的做分流是否可以达成上面提到的第3、4点。</p>

<p>了解到f5的irule只能描述简单地规则，比如可以读取cookie，
目前的想法是由应用自己来写规则，通过cookie通知f5，irules里面只需要对cookie做简单判定。
需要调整分流规则的时候，运营（或者开发）只需要操作应用。
类似于这样：</p>

<p>f5 中</p>

<pre><code>if(cookie(‘abVersionFlag’)==a){
       redirectTo a
}else{
       redirectTo b
}
</code></pre>

<p>应用中（只在b版本中必要）：</p>

<pre><code>if(cookie(‘abVersionFlag’)==null){
       setCookie(‘abVersionFlag’, getABVserionByUserFromBusiness(user))
       sendRedirect(url)
}else{
       otherBusinessLogic……
}
</code></pre>

<p>简图：</p>

<p><img src="http://nielinjie.github.io/images/ab/ab.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给老爷爷系统（一）：代码质量守则和工具]]></title>
    <link href="http://nielinjie.github.io/blog/2014/05/26/quality/"/>
    <updated>2014-05-26T20:06:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/05/26/quality</id>
    <content type="html"><![CDATA[<blockquote><p>这是一个老爷爷系统。</p></blockquote>

<p>对于一个历史悠久的老爷爷系统，我们的程序员定下了下面的代码质量守则：</p>

<!-- more -->


<ul>
<li>新增方法复杂度不能大于5。</li>
<li>新增类之间不能出现包循环依赖，同层之间可稍微放宽（如Service之间互相调用）。</li>
<li>新增类和方法避免有重复代码，出现重复或者相似度较高的代码应提炼成函数。</li>
<li>过长的方法，新增方法不能过长，代码行数限定在30。</li>
<li>过大的类，新增类不能过大，尽量体现类的单一职责。</li>
<li>变量、方法和类的命名要体现业务含义，不能用如s=5、getString()等命名。</li>
<li>新增方法需编写自动化测试案例。</li>
</ul>


<p>守则里面有很多“新增”，新增类、新增方法。
因为对于老旧的代码，要求它们的质量不具有可操作性。
我们只能期望通过要求新增的代码符合要求，来改善至少是维持整个系统的代码质量。</p>

<p>如果团队比较有野心，可能想在“新增”里面包括“更新”，也就是所有“触碰过”的类和方法。</p>

<p>有了守则我们需要一个检查工具，让程序员可以快速地检查和自检。
但一般的代码扫描工具不能针对“新增、更新”进行扫描，我们需要自己的工具。
工具的要点在于如何找出所谓的“新增的类和方法”、“更新的类和方法”。</p>

<p>基本思路是：</p>

<ul>
<li>先找出版本之间的diff，新增的文件和修改过的文件。

<ul>
<li>比如svn，可以用svn的命令行客户端，也有一些java的api。比如svnKit。</li>
</ul>
</li>
<li>对于新增的文件：

<ul>
<li>parse这个文件，找到所有的类和方法，即可找到所有的“新增的方法和类”。</li>
<li>parse可以使用这个：<a href="https://code.google.com/p/javaparser/wiki/UsingThisParser">https://code.google.com/p/javaparser/wiki/UsingThisParser</a></li>
</ul>
</li>
<li>对于修改的文件：

<ul>
<li>parse新版本，找到所有类和方法的起止位置。</li>
<li>parse方法同上。</li>
<li>对比文件的diff结果（这个是按行号列出的更改），就可以发现新增的、更新过的类和方法。</li>
</ul>
</li>
<li>当新增、更新的类和方法得到以后，再综合代码扫描（扫描新版本）的结果报告。比如findbugs、jdepend……
即可得出新增、更新的类和方法的质量指标了。</li>
</ul>


<p>关键代码在这里：<br/>
<a href="https://gist.github.com/nielinjie/d8fa324ee0d1d149c5e2">https://gist.github.com/nielinjie/d8fa324ee0d1d149c5e2</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的简历（陆续完整中）]]></title>
    <link href="http://nielinjie.github.io/blog/2014/05/21/resume/"/>
    <updated>2014-05-21T20:06:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/05/21/resume</id>
    <content type="html"><![CDATA[<h3>目录</h3>

<ul>
<li><a href="http://nielinjie.github.io/blog/2014/05/21/resume/#1">自我评价</a></li>
<li><a href="http://nielinjie.github.io/blog/2014/05/21/resume/#2">工作经验</a></li>
<li><a href="http://nielinjie.github.io/blog/2014/05/21/resume/#3">项目经验</a></li>
<li><a href="http://nielinjie.github.io/blog/2014/05/21/resume/#4">教育经历</a></li>
<li><a href="http://nielinjie.github.io/blog/2014/05/21/resume/#5">培训经历</a></li>
<li><a href="http://nielinjie.github.io/blog/2014/05/21/resume/#6">FAQ</a></li>
</ul>


<!-- more -->


<hr />

<h3><a name="1"></a>自我评价</h3>

<p>熟悉企业信息系统架构及开发技术。
长期从事企业信息系统架构设计、架构执行、架构维护、设计和开发。
深入理解软件开发流程。
能够负责开发团队的构建和运行。
善于沟通合作，具备一定领导力和辅导培训能力。</p>

<h3><a name="2"></a>工作经验</h3>

<ul>
<li>2009 /6&mdash;至今：平安科技（深圳）有限公司

<ul>
<li>开发九部、集团开发部</li>
<li>应用架构师、应用架构专家</li>
<li>负责两个业务系列所属的项目和相关重要任务的架构设计和架构执行，日常应用架构管理维护。重点需求的解决方案设计，详细设计复审等工作。
同时参与部门范围改进开发过程；设计开发工具；提高开发效率；保障开发质量等工作。</li>
</ul>
</li>
</ul>


<hr />

<ul>
<li>2007 /11&mdash;2009 /6：平安科技（深圳）有限公司

<ul>
<li>开发九部</li>
<li>分组经理</li>
<li>组建和领导10-20人开发团队，统筹开发分工协调，进行相关决策。</li>
</ul>
</li>
</ul>


<hr />

<ul>
<li>2005 /12&mdash;2007 /11：上海花旗软件

<ul>
<li>PS部（专业服务部）</li>
<li>Solution Architect</li>
<li>j2ee软件系统架构、设计和开发。</li>
</ul>
</li>
</ul>


<hr />

<ul>
<li>2004 /6&mdash;2005 /11：上海花旗软件

<ul>
<li>PS部（专业服务部）</li>
<li>Senior Software Developer</li>
<li>j2ee软件设计和开发。</li>
</ul>
</li>
<li>……</li>
</ul>


<h3><a name="3"></a>项目经验</h3>

<ul>
<li>2014 /1&mdash;至今：平安企业门户信息聚合和企业社交

<ul>
<li>项目描述： 平安企业门户，关于信息聚合和企业社交。原型项目。</li>
<li>责任描述： 策划、原型设计和开发、技术选型。

<ul>
<li><a href="http://nielinjie.github.io/blog/2014/06/05/social/">企业中需要什么样的社交？</a></li>
</ul>
</li>
</ul>
</li>
</ul>


<hr />

<ul>
<li>2014 /1&mdash;至今：平安法律部诉讼管理系统

<ul>
<li>项目描述： 平安法律部诉讼管理系统。敏捷项目。</li>
<li>责任描述： 架构设计，架构执行。

<ul>
<li><a href="http://nielinjie.github.io/blog/filter/filter.html?filterName=series&amp;filterValue=%E6%95%8F%E6%8D%B7%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1&amp;filterDes=Series%3A%20%E6%95%8F%E6%8D%B7%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1">敏捷的架构设计（一 至 四）</a></li>
</ul>
</li>
</ul>
</li>
</ul>


<hr />

<ul>
<li>2014 /1&mdash;2014 /4：用户风险等级评级系统

<ul>
<li>项目描述： 平安内控关于用户风险等级的数据汇总和分析平台。</li>
<li>责任描述： 架构设计顾问。</li>
</ul>
</li>
</ul>


<hr />

<ul>
<li>2013 /1&mdash;2014 /1：行政系统移动化

<ul>
<li>项目描述： 平安行政系统移动适配项目。敏捷项目。</li>
<li>责任描述： 架构设计，架构执行。

<ul>
<li><a href="http://nielinjie.github.io/blog/2013/02/25/our-new-front-end/">我们的新前端</a></li>
<li><a href="http://nielinjie.github.io/blog/filter/filter.html?filterName=series&amp;filterValue=%E5%85%B3%E4%BA%8EREST%E9%A3%8E%E6%A0%BC%E7%9A%84%E8%AE%A8%E8%AE%BA&amp;filterDes=Series%3A%20%E5%85%B3%E4%BA%8EREST%E9%A3%8E%E6%A0%BC%E7%9A%84%E8%AE%A8%E8%AE%BA">关于REST风格的讨论（系列）</a></li>
</ul>
</li>
</ul>
</li>
</ul>


<hr />

<ul>
<li>2013 /1&mdash;至今：机构主页可定制化改造

<ul>
<li>项目描述： 平安机构主页可定制化改造项目，暨企业统一信息发布系统实验项目。</li>
<li>责任描述： 架构设计，技术选型，架构执行。</li>
</ul>
</li>
</ul>


<hr />

<ul>
<li>2012 /10&mdash;至今：企业全文检索服务

<ul>
<li>项目描述： 企业公用的全文检索服务。</li>
<li>责任描述： 架构设计、技术选型，架构执行。</li>
</ul>
</li>
</ul>


<hr />

<ul>
<li>2012 /6&mdash;2013 /4：内控信息收集管理系统

<ul>
<li>项目描述： 平安集团内控中心内控信息收集管理系统。运行于j2ee平台的bs架构企业管理系统，展示逻辑大量部署于浏览器端。</li>
<li>责任描述： 架构设计、技术选型、技术培训、架构执行。</li>
</ul>
</li>
</ul>


<hr />

<ul>
<li>2011 /10&mdash;至今：办公系统重构项目

<ul>
<li>项目描述： 平安集团行政中心办公系统的重构项目。对复杂系统进行有针对性的重构，延缓腐化、降低其维护成本和修改功能的成本。</li>
<li>责任描述： 策划并发起项目、制定原则和方案、分析和设计。

<ul>
<li><a href="http://nielinjie.github.io/blog/filter/filter.html?filterName=series&amp;filterValue=%E4%B8%80%E5%9C%BA%E4%BC%BC%E9%9D%9E%E8%80%8C%E6%98%AF%E7%9A%84DSL&amp;filterDes=Series%3A%20%E4%B8%80%E5%9C%BA%E4%BC%BC%E9%9D%9E%E8%80%8C%E6%98%AF%E7%9A%84DSL">一场似非而是的DSL（系列）</a></li>
<li><a href="http://nielinjie.github.io/blog/filter/filter.html?filterName=series&amp;filterValue=%E6%95%8F%E6%8D%B7%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1&amp;filterDes=Series%3A%20%E6%95%8F%E6%8D%B7%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1">敏捷的架构设计（五、六）：领域地图（一、二）</a></li>
<li><a href="http://nielinjie.github.io/blog/filter/filter.html?filterName=series&amp;filterValue=%E7%BB%99%E8%80%81%E7%88%B7%E7%88%B7%E7%B3%BB%E7%BB%9F&amp;filterDes=Series%3A%20%E7%BB%99%E8%80%81%E7%88%B7%E7%88%B7%E7%B3%BB%E7%BB%9F">给老爷爷系统（系列）</a></li>
</ul>
</li>
</ul>
</li>
</ul>


<hr />

<ul>
<li>2005 /11&mdash;2007 /11：投资银行销售客户管理系统

<ul>
<li>项目描述： j2ee 平台b/s结构的客户资源管理系统。</li>
<li>责任描述： 架构设计、详细设计、开发协调。</li>
</ul>
</li>
<li>……</li>
</ul>


<h3><a name="4"></a>教育经历</h3>

<ul>
<li>1997 /9&mdash;2001 /7  上海交通大学

<ul>
<li>自动化   本科</li>
</ul>
</li>
</ul>


<h3><a name="5"></a>培训经历</h3>

<ul>
<li>2013 /12&mdash;2013 /12：

<ul>
<li>中程在线： 架构设计实践</li>
</ul>
</li>
<li>2012 /3&mdash;2012 /3：

<ul>
<li>MPD软件工坊：  敏捷开发过程</li>
</ul>
</li>
<li>2011 /8&mdash;2011 /8：

<ul>
<li>中程在线： 大型架构案例分析训练营</li>
</ul>
</li>
<li>2011 /6&mdash;2011 /7：

<ul>
<li>卡洛奇资讯：  卡洛奇应用架构师培训</li>
</ul>
</li>
<li>2010 /7&mdash;2010 /8：

<ul>
<li>中程在线： 架构设计最佳实践与方法体系</li>
</ul>
</li>
<li>2009 /8&mdash;2009 /8：

<ul>
<li>Sun：  sun架构师标准课程培训SL425，获SL425结业证书</li>
</ul>
</li>
</ul>


<h3><a name="6"></a>FAQ</h3>

<p>Q:<br/>
架构工作中最重要的是什么？<br/>
A:<br/>
最重要的是做出折中，架构工作中遇到的问题往往不是非黑即白的，最后的答案是折中的结果。
不仅要敢于折中，还要善于折中。
不仅要关注折中这个结果，还必须持续关注和管理折中的条件、折中的范围、折中的程度、折中的影响。</p>

<p>Q:<br/>
架构工作中最难的是什么？<br/>
A:<br/>
个人感到比较难的有两点。<br/>
* 第一点是管理架构设计过程。
  很多时候架构设计过程过于依赖架构师个人的经验甚至直觉，过程本身难以控制，同时架构知识也很难积累和分享。<br/>
* 第二点是架构的执行。架构只有执行了才能产生作用。
  但架构执行的过程却往往缺少重视和指导，在长时间跨度、参与人员复杂、需求随时变化等等因素的影响下，架构执行走样的情况经常发生。
  如何避免架构执行走样，或者及时发现和纠正走样，是一个还没想透彻的问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[敏捷的架构设计（六）：领域地图（二）]]></title>
    <link href="http://nielinjie.github.io/blog/2014/04/24/aa4/"/>
    <updated>2014-04-24T17:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/04/24/aa4</id>
    <content type="html"><![CDATA[<blockquote><p>敏捷已死，而敏捷性长存。</p></blockquote>

<h3>如何建立领域地图</h3>

<!-- more -->


<p>以下直接转帖“领域地图”工作开始时的kickoff邮件，可以体现我们建立“领域地图”方法的基本思路。</p>

<hr />

<ol>
<li>“领域地图”编制和使用将是一个渐进的和团队参与的过程。地图将逐步进化和完善，于此同时可以使用。</li>
<li>“领域地图”的目的是将系统的领域知识（业务知识）进行整理，使其结构化，为相关工作提供指导。比如：架构设计、包划分……</li>
<li>“领域地图”中的知识来源于：

<ol>
<li>同学们和业务同事的记忆中或者从其他渠道整理的业务知识。</li>
<li>从代码中发掘来的业务知识。</li>
</ol>
</li>
<li>“领域地图”希望展现的是业务概念及其关系。是一个静态的领域模型视图。“功能地图”也是一个领域模型的一个视图，是动态视图。两者保持一致并相互支持和完善。</li>
<li>“领域地图”编制工作要点大致是：

<ol>
<li>工作在“领域地图白板”上进行，就是“英雄联盟白板”<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>的右侧白板。</li>
<li>图上的要素说明如下：

<ol>
<li>紫色矩形：来源于同学们的业务知识（3.a），目前主要来源于SA维护的“功能地图”。</li>
<li>绿色矩形：来源于代码的架构现状。既有可能是从代码发掘的正面的业务知识（3.b），也有可能是系统多年积累来负面现状。</li>
<li>橙色塔形：从i，ii两点综合而来的理想或者说是设计结论，是领域地图的结果。由架构师和开发同学们讨论确立。</li>
<li>紫色和绿色的post上的文字可以是一些词语，也可以是一些描述。橙色的post是结果，一般是一个词语，是英文的，便于指导后续架构和设计工作。</li>
<li>post之间的距离表示概念之间的关系。间隔较小进而重叠的，表示业务概念有较多重合和交互；间隔较远的，表示业务概念分隔明显。</li>
</ol>
</li>
</ol>
</li>
<li>对“领域地图”的使用目前主要体现在代码的结构改进，目标是按领域组织代码。

<ol>
<li>对照橙色塔形和绿色矩形，可以发现现状与理想间的差距，是我们的改进方向，用红色post表示。</li>
<li>从红色的post，产生可衡量可执行的改进任务，用紫色post表示，与“英雄联盟”白板上内部改造需求一致，便于移动到“英雄联盟”上跟进。（虽然与5.b.i中的颜色一样，但内容会很不一样，应该不会混淆。）</li>
<li>在“英雄联盟”白板上，有时会有橙色塔形标注“DM”（domain map）贴在任务卡片上，表示此项任务涉及到的领域知识（业务知识）必须在设计阶段在“领域地图”上体现。（和要求设计复审的符号相似，都是橙色塔形，不过那个上标注“D”）</li>
</ol>
</li>
</ol>


<p><img src="http://nielinjie.github.io/images/kanban/dm.jpg"></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>该系统敏捷开发过程的用户故事白板。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[敏捷的架构设计（五）：领域地图（一）]]></title>
    <link href="http://nielinjie.github.io/blog/2014/04/24/aa3/"/>
    <updated>2014-04-24T16:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/04/24/aa3</id>
    <content type="html"><![CDATA[<blockquote><p>敏捷已死，而敏捷性长存。</p></blockquote>

<h3>什么是“领域地图”？是“领域模型”么？</h3>

<!-- more -->


<p>基本上，就是的。</p>

<p>这是一个历史悠久的系统，历经多年的进化，长久以来团队不知道它的整体需求是怎样的，也缺少有条理的领域知识积累。风险逐渐积累。</p>

<p>现在到了系统整理领域知识，尝试建立领域模型的适当时机——</p>

<ul>
<li>事务脚本风格向领域划分风格的重构<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>已经在重点局部取得了阶段性进展，现在到了推广到全局的时间了。既然是“按领域划分”，我们自然需要一个领域模型作为划分原则。</li>
<li>SA同学正在整理全局“功能地图”、测试同学整理“全量测试案例”，这些东西希望能与代码发生联系，需要一个中枢。在上述的架构风格下，这个中枢只能是领域模型。
我们画了个图来分析领域模型的中枢地位。如后所示。</li>
</ul>


<p>虽然是一种模型，但叫“地图”不叫“模型”——</p>

<ul>
<li>尺度大，粒度大，只有宏观结构没有细节。是对领域的全局鸟瞰，感觉就像是面对地图。</li>
<li>强调它的最高指导意义，类比“军事地图”。感受下。:-D</li>
<li>SA同学的叫做功能“地图”，我们也叫“地图”。</li>
</ul>


<p><img src="http://nielinjie.github.io/images/kanban/gongneng.png"></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>关于重构有个系列的blog即将写，届时这里换成一个链接……<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[向Octopress贡献（二）：连载系列]]></title>
    <link href="http://nielinjie.github.io/blog/2014/04/20/series/"/>
    <updated>2014-04-20T23:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/04/20/series</id>
    <content type="html"><![CDATA[<p>我们常常会发表一些连载的系列文章。
这些文章时间上有时会相互隔开，这时候默认的导航链接就不太方便。
需要一个新的方式在同一系列的连载文章间跳转。</p>

<!-- more -->


<ul>
<li>延续上篇文章的思路，采用js来实现功能。</li>
<li>在每个post头部的yaml metadata中添加连载系列的相关数据，比如这篇文章添加：<code>series: ["向Octopress贡献 2"]</code>。</li>
<li>Jekyll会自动将所有的metadata都解析出来，这样全局的json文件中可以容易地包含相关数据。</li>
<li>在适当的地方嵌入相应地html文件，其中的js根据json产生相关的内容。</li>
<li>代码在这里：<a href="https://github.com/nielinjie/nielinjie.github.io/commit/4a599e5d1296b420dc13473c4e6bbaf4d55fc198">https://github.com/nielinjie/nielinjie.github.io/commit</a>。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[向Octopress贡献（一）：动态内容]]></title>
    <link href="http://nielinjie.github.io/blog/2014/04/20/xiaowanyier/"/>
    <updated>2014-04-20T23:06:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/04/20/xiaowanyier</id>
    <content type="html"><![CDATA[<p>同学们往右看：就是那个一坨一坨飘一飘的东西。8-D<br/>
每个圆表示一个category，它的大小表示该category名下文章的数量（相对的）；两个圆之间的连线表示两个category有联系，也就是说有文章同时属于这两个category。
两个圆距离越近，则category的关系越密切，同时属于这两个category的文章越多。<br/>
点击圆形，将来到一个显示该category下所有文章的页面。</p>

<!-- more -->


<p>这只是一个初步的demo，有兴趣的同学可以沿着这个思路创造更多有意思的动态内容。</p>

<ul>
<li>新建一个静态的文件，让Jekyll在generate的时候将整个site的数据写进去。这里我放在根目录，用的是json格式。</li>
<li>定制aside添加一个html文件，我这里是category.html。</li>
<li>category.html里面用js绘制需要的动态内容。引用上面的json文件，你可以利用所有数据为所欲为。</li>
<li>代码看这里：<a href="http://github.com/nielinjie/nielinjie.github.io/commit/3abeab7a7f6d5170be3ae1f7294314470063e88b">http://github.com/nielinjie/nielinjie.github.io/commit</a>。</li>
</ul>


<p>至于显示category文章的页面，比较简单。通过url上queryString传递相应参数即可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[言论：雪人（四）]]></title>
    <link href="http://nielinjie.github.io/blog/2014/04/12/said-xueren4/"/>
    <updated>2014-04-12T23:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/04/12/said-xueren4</id>
    <content type="html"><![CDATA[<p>你感到雪人项目进行得还算顺利，虽然样子有点奇怪。
直到有一天PO突然说道：“经过调研，现在的孩子喜欢的其实是蜘蛛侠不是蜘蛛。”
你于是尝试铲掉其中六条腿，雪人摇摇欲坠。 “架构太不敏捷了。”——PO大喊。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[敏捷的架构设计（四）：来提意见]]></title>
    <link href="http://nielinjie.github.io/blog/2014/04/07/aa25/"/>
    <updated>2014-04-07T16:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/04/07/aa25</id>
    <content type="html"><![CDATA[<blockquote><p>敏捷已死，而敏捷性长存。</p></blockquote>

<p>在第一块看板前，邀请一些资深同学就这块看板和它背后的“风险驱动的架构设计”方法进行了一些讨论。</p>

<!-- more -->


<p>同学们的意见主要集中在：</p>

<ul>
<li>如何确保没有遗漏的风险？</li>
<li>知识如何积累和传承？</li>
</ul>


<p>第一个问题。很难给出满意的答案。</p>

<p>目前来看，对风险的识别主要靠架构师和开发团队的经验。
如果架构师和团队经验不足，就会有风险遗漏，导致架构设计不能解决所有需要解决的问题，不能满足要求。<br/>
这个问题跟架构设计方法关系不大，不管采用何种架构设计方法，都需要首先发现待解决的问题，再去解决它。
发现问题的阶段，对架构师和团队的经验的依赖是很难避免的。
比如比较传统的三段式架构设计方法<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，是以需求驱动的架构设计方法，要求识别关键功能功能、质量场景等作为待解决的问题。
方法体系中虽然提供了一些工具和指导，但这些识别仍然依赖架构师的经验。</p>

<p>从另一方面讲，应该避免对风险“过度识别”。风险驱动的架构设计隐含了一个重要观点：不需要完备的架构设计。
不完备的架构设计要求掌握好一个度：识别与忽略的度。而“风险”，恰好是掌握这个度的工具。过度识别风险，把不是风险的识别为风险，等于是放弃了这个度的平衡，也就放弃了不完备的架构设计这一核心理念。</p>

<p>回到当前实践中，我们计划采取的措施是：制成一个风险检查清单，随时对照检查，看是或否遗漏，检查清单的来源包括但不限于：<br/>
1. 传统架构设计方法的一些现成知识，比如质量要求检查清单。<br/>
2. 企业中积累的知识，比如规章制度、相似项目的经验教训。</p>

<p>第二个问题。看似容易回答。</p>

<p>这里的“知识”主要指两方面的内容：架构设计的过程和架构设计的结果。
不管是哪个方面，其实并不是所有都需要积累和传承。</p>

<p>我表示计划这样来做：对于每一项风险，我们都执行了一系列的有针对性的架构任务（看板上体现为绿色的卡片），这些卡片的生命周期，其实就是对应的架构设计的过程，这些卡片的产出，其实就是对应的架构设计的结果。
当我们制定任务、绿色卡片生成的时候，我们多考虑一件事情，就是这个卡片的生命要不要记录下来，它的的产出物要不要记录下来。把考虑的结果标记在卡片上，任务完成，卡片存档的时候，我们按照这个标记制定相应地记录就可以了。</p>

<p>有同学对这个办法并不认可，认为知识积累和传承主要满足项目结束后的维护同事需要。从当前团队的角度来考虑某个知识是否需要记录，结果往往会遗漏。
我认为这个担忧有一定道理，但我理解“不完备架构设计”理论对这个问题的观点是：没人知道后来者真正需要什么文档，宁愿他们找不到文档，也不要走上全文档的老路。</p>

<p>实践中，我们会先按上述的计划做，观察一段时间再说。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>请见另一篇博客（搬家未完成……）<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[敏捷的架构设计（三）：第一块看板]]></title>
    <link href="http://nielinjie.github.io/blog/2014/04/03/aa2/"/>
    <updated>2014-04-03T23:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/04/03/aa2</id>
    <content type="html"><![CDATA[<blockquote><p>敏捷已死，而敏捷性长存。</p></blockquote>

<p>这是一个架构“普通”的项目。也是第一个系统实践“风险驱动架构设计”的项目。</p>

<!-- more -->


<p>下面介绍一下这个项目的“架构看板”——</p>

<ul>
<li>看板空间分为三列。

<ul>
<li>第一列，红色卡片，放置识别到的风险，包括风险的描述、评价手段、影响程度和优先级等。</li>
<li>第二列，蓝色卡片，放置对策，包括指导原则、注意事项、大致计划、研究的中间结果等。</li>
<li>第三列，绿色卡片，放置可以执行的任务。</li>
</ul>
</li>
<li>看板空间分为多行，每行对应一个风险。它们按处置的优先级排序。</li>
<li>风险会随时被识别出来，来源包括但不限于架构师、开发团队、PO、领导和其他干系人。</li>
<li>所有的风险都会上板，有些会被否决或定为“微不足道”、“容易解决”等，这些被移动到最下方。</li>
<li>任务根据对策制定，必须是可执行、可衡量的。这些任务体现为绿色卡片。</li>
<li>绿色任务卡片，会跟用户故事拆分来的任务卡片一起排优先级，并采用和这些卡片一致的跟进方法。</li>
<li>当绿色任务卡片的状态变化，团队审视红色和蓝色卡片是否需要变化，随着应对措施的进行，对风险认识可能会有改变，对其的对策也可能随之变化。</li>
<li>团队随时可以移动、增减看板上的卡片，只要跟其他人达成共识。</li>
</ul>


<p>看板并不会直接帮助团队发现风险、制定应对措施、完成相关任务。
但看板能够有效地协助团队管理整个架构过程。
是敏捷过程中执行风险驱动架构设计方法的有效手段。</p>

<p><img src="http://nielinjie.github.io/images/kanban/rd.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[敏捷的架构设计（二）：风险驱动]]></title>
    <link href="http://nielinjie.github.io/blog/2014/03/31/aa1/"/>
    <updated>2014-03-31T21:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/03/31/aa1</id>
    <content type="html"><![CDATA[<blockquote><p>敏捷已死，而敏捷性长存。</p></blockquote>

<p>何为风险驱动的架构设计？
该方法认为：</p>

<ul>
<li>架构设计的（唯一）目的是应对工程风险。</li>
<li>当且仅当有风险被识别的时候需要考虑是否进行相应的架构设计。</li>
<li>架构设计采用的技术和投入的资源要与对应风险种类和程度相适应。</li>
<li>风险本身或\和对风险的认识会发生改变，相应的架构设计活动也会改变，架构设计结果也会改变。</li>
<li>风险驱动架构设计方法适合敏捷开发过程。</li>
</ul>

]]></content>
  </entry>
  
</feed>
