<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[聂同学]]></title>
  <link href="http://nielinjie.github.io/atom.xml" rel="self"/>
  <link href="http://nielinjie.github.io/"/>
  <updated>2014-05-26T16:02:07+08:00</updated>
  <id>http://nielinjie.github.io/</id>
  <author>
    <name><![CDATA[nielinjie]]></name>
    <email><![CDATA[nielinjie@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[给老大爷系统：代码质量守则和工具]]></title>
    <link href="http://nielinjie.github.io/blog/2014/05/24/quality/"/>
    <updated>2014-05-24T20:06:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/05/24/quality</id>
    <content type="html"><![CDATA[<p>对于一个历史悠久的老大爷系统，我们的程序员定下了下面的代码质量守则：</p>

<!-- more -->


<ul>
<li>新增方法复杂度不能大于5。</li>
<li>新增类之间不能出现包循环依赖，同层之间可稍微放宽（如Service之间互相调用）。</li>
<li>新增类和方法避免有重复代码，出现重复或者相似度较高的代码应提炼成函数。</li>
<li>过长的方法，新增方法不能过长，代码行数限定在30。</li>
<li>过大的类，新增类不能过大，尽量体现类的单一职责。</li>
<li>变量、方法和类的命名要体现业务含义，不能用如s=5、getString()等命名。</li>
<li>新增方法需编写自动化测试案例。</li>
</ul>


<p>守则里面有很多“新增”，新增类、新增方法。
因为对于老旧的代码，要求它们的质量不具有可操作性。
我们只能期望通过要求新增的代码符合要求，来改善至少是维持整个系统的代码质量。</p>

<p>如果团队比较有野心，可能想在“新增”里面包括“更新”，也就是所有“触碰过”的类和方法。</p>

<p>有了守则我们需要一个检查工具，让程序员可以快速地检查和自检。
但一般的代码扫描工具不能针对“新增、更新”进行扫描，我们需要自己的工具。
工具的要点在于如何找出所谓的“新增的类和方法”、“更新的类和方法”。</p>

<p>基本思路是：</p>

<ul>
<li>先找出版本之间的diff，新增的文件和修改过的文件。

<ul>
<li>比如svn，可以用svn的命令行客户端，也有一些java的api。比如svnKit。</li>
</ul>
</li>
<li>对于新增的文件：

<ul>
<li>parse这个文件，找到所有的类和方法，即可找到所有的“新增的方法和类”。</li>
<li>parse可以使用这个：<a href="https://code.google.com/p/javaparser/wiki/UsingThisParser">https://code.google.com/p/javaparser/wiki/UsingThisParser</a></li>
</ul>
</li>
<li>对于修改的文件：

<ul>
<li>parse新版本，找到所有类和方法的起止位置。</li>
<li>parse方法同上。</li>
<li>对比文件的diff结果（这个是按行号列出的更改），就可以发现新增的、更新过的类和方法。</li>
</ul>
</li>
<li>当新增、更新的类和方法得到以后，再综合代码扫描（扫描新版本）的结果报告。比如findbugs、jdepend……
即可得出新增、更新的类和方法的质量指标了。</li>
</ul>


<p>关键代码在这里：<br/>
<a href="https://gist.github.com/nielinjie/d8fa324ee0d1d149c5e2">https://gist.github.com/nielinjie/d8fa324ee0d1d149c5e2</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的简历（陆续补充中）]]></title>
    <link href="http://nielinjie.github.io/blog/2014/05/21/resume/"/>
    <updated>2014-05-21T20:06:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/05/21/resume</id>
    <content type="html"><![CDATA[<h3>目录</h3>

<ul>
<li><a href="http://nielinjie.github.io/blog/2014/05/21/resume/#1">自我评价</a></li>
<li><a href="http://nielinjie.github.io/blog/2014/05/21/resume/#2">工作经验</a></li>
<li><a href="http://nielinjie.github.io/blog/2014/05/21/resume/#3">项目经验</a></li>
<li><a href="http://nielinjie.github.io/blog/2014/05/21/resume/#4">教育经历</a></li>
<li><a href="http://nielinjie.github.io/blog/2014/05/21/resume/#5">培训经历</a></li>
<li><a href="http://nielinjie.github.io/blog/2014/05/21/resume/#6">FAQ</a></li>
</ul>


<!-- more -->


<hr />

<h3><a name="1"></a>自我评价</h3>

<p>熟悉一般企业信息应用系统架构及开发技术。能够进行应用架构设计、技术决策、设计开发。
深入理解软件开发流程。能够进行相关领域的制度建立、责任分配、指标制定。
能够负责开发团队的构建和运行。
善于沟通合作，具备一定领导力和辅导培训能力。</p>

<h3><a name="2"></a>工作经验</h3>

<ul>
<li>2009 /6&mdash;至今：平安科技（深圳）有限公司

<ul>
<li>开发九部、集团开发部</li>
<li>应用架构师</li>
<li>负责两个业务系列所属的项目和相关重要任务的架构设计和架构执行，日常应用架构管理维护。重点需求的解决方案设计，详细设计复审等工作。
同时参与部门范围改进开发过程；设计开发工具；提高开发效率；保障开发质量等工作。</li>
</ul>
</li>
</ul>


<hr />

<ul>
<li>2007 /11&mdash;2009 /6：平安科技（深圳）有限公司

<ul>
<li>开发九部</li>
<li>分组经理</li>
<li>组建和领导10-20人开发团队，统筹开发分工协调，进行相关决策。</li>
</ul>
</li>
</ul>


<hr />

<ul>
<li>2005 /12&mdash;2007 /11：上海花旗软件

<ul>
<li>PS部（专业服务部）</li>
<li>Solution Architect</li>
<li>j2ee软件系统架构、设计和开发。</li>
</ul>
</li>
</ul>


<hr />

<ul>
<li>2004 /6&mdash;2005 /11：上海花旗软件

<ul>
<li>PS部（专业服务部）</li>
<li>Senior Software Developer</li>
<li>j2ee软件设计和开发。</li>
</ul>
</li>
<li>……</li>
</ul>


<h3><a name="3"></a>项目经验</h3>

<ul>
<li>2014 /1&mdash;至今：平安企业门户信息聚合和企业社交

<ul>
<li>项目描述： 平安企业门户，关于信息聚合和企业社交。原型项目。</li>
<li>责任描述： 策划、原型设计和开发、技术选型。</li>
</ul>
</li>
</ul>


<hr />

<ul>
<li>2014 /1&mdash;至今：平安法律部诉讼管理系统

<ul>
<li>项目描述： 平安法律部诉讼管理系统。敏捷项目。</li>
<li>责任描述： 架构设计，架构执行。

<ul>
<li><a href="http://nielinjie.github.io/blog/filter/filter.html?filterName=series&amp;filterValue=%E6%95%8F%E6%8D%B7%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1&amp;filterDes=Series%3A%20%E6%95%8F%E6%8D%B7%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1">敏捷的架构设计（一 至 四）</a></li>
</ul>
</li>
</ul>
</li>
</ul>


<hr />

<ul>
<li>2014 /1&mdash;2014 /4：用户风险等级评级系统

<ul>
<li>项目描述： 平安内控关于用户风险等级的数据汇总和分析平台。</li>
<li>责任描述： 架构设计顾问。</li>
</ul>
</li>
</ul>


<hr />

<ul>
<li>2013 /1&mdash;2014 /1：行政系统移动化

<ul>
<li>项目描述： 平安行政系统移动适配项目。敏捷项目。</li>
<li>责任描述： 架构设计，架构执行。

<ul>
<li><a href="http://nielinjie.github.io/blog/2013/02/25/our-new-front-end/">我们的新前端</a></li>
<li><a href="http://nielinjie.github.io/blog/filter/filter.html?filterName=series&amp;filterValue=%E5%85%B3%E4%BA%8EREST%E9%A3%8E%E6%A0%BC%E7%9A%84%E8%AE%A8%E8%AE%BA&amp;filterDes=Series%3A%20%E5%85%B3%E4%BA%8EREST%E9%A3%8E%E6%A0%BC%E7%9A%84%E8%AE%A8%E8%AE%BA">关于REST风格的讨论（系列）</a></li>
</ul>
</li>
</ul>
</li>
</ul>


<hr />

<ul>
<li>2013 /1&mdash;至今：机构主页可定制化改造

<ul>
<li>项目描述： 平安机构主页可定制化改造项目，暨企业统一信息发布系统实验项目。</li>
<li>责任描述： 架构设计，技术选型，架构执行。</li>
</ul>
</li>
</ul>


<hr />

<ul>
<li>2012 /10&mdash;至今：企业全文检索服务

<ul>
<li>项目描述： 企业公用的全文检索服务。</li>
<li>责任描述： 架构设计、技术选型，架构执行。</li>
</ul>
</li>
</ul>


<hr />

<ul>
<li>2012 /6&mdash;2013 /4：内控信息收集管理系统

<ul>
<li>项目描述： 平安集团内控中心内控信息收集管理系统。运行于j2ee平台的bs架构企业管理系统，展示逻辑大量部署于浏览器端。</li>
<li>责任描述： 架构设计、技术选型、技术培训、架构执行。</li>
</ul>
</li>
</ul>


<hr />

<ul>
<li>2011 /10&mdash;至今：办公系统重构项目

<ul>
<li>项目描述： 平安集团行政中心办公系统的重构项目。对复杂系统进行有针对性的重构，延缓腐化、降低其维护成本和修改功能的成本。</li>
<li>责任描述： 策划并发起项目、制定原则和方案、分析和设计。

<ul>
<li><a href="http://nielinjie.github.io/blog/filter/filter.html?filterName=series&amp;filterValue=%E4%B8%80%E5%9C%BA%E4%BC%BC%E9%9D%9E%E8%80%8C%E6%98%AF%E7%9A%84DSL&amp;filterDes=Series%3A%20%E4%B8%80%E5%9C%BA%E4%BC%BC%E9%9D%9E%E8%80%8C%E6%98%AF%E7%9A%84DSL">一场似非而是的DSL（系列）</a></li>
<li><a href="http://nielinjie.github.io/blog/filter/filter.html?filterName=series&amp;filterValue=%E6%95%8F%E6%8D%B7%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1&amp;filterDes=Series%3A%20%E6%95%8F%E6%8D%B7%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1">敏捷的架构设计（五、六）：领域地图（一、二）</a></li>
</ul>
</li>
</ul>
</li>
</ul>


<hr />

<ul>
<li>2005 /11&mdash;2007 /11：投资银行销售客户管理系统

<ul>
<li>项目描述： j2ee 平台b/s结构的客户资源管理系统。</li>
<li>责任描述： 架构设计、详细设计、开发协调。</li>
</ul>
</li>
<li>……</li>
</ul>


<h3><a name="4"></a>教育经历</h3>

<ul>
<li>1997 /9&mdash;2001 /7  上海交通大学

<ul>
<li>自动化   本科</li>
</ul>
</li>
</ul>


<h3><a name="5"></a>培训经历</h3>

<ul>
<li>2013 /12&mdash;2013 /12：

<ul>
<li>中程在线： 架构设计实践</li>
</ul>
</li>
<li>2012 /3&mdash;2012 /3：

<ul>
<li>MPD软件工坊：  敏捷开发过程</li>
</ul>
</li>
<li>2011 /8&mdash;2011 /8：

<ul>
<li>中程在线： 大型架构案例分析训练营</li>
</ul>
</li>
<li>2011 /6&mdash;2011 /7：

<ul>
<li>卡洛奇资讯：  卡洛奇应用架构师培训</li>
</ul>
</li>
<li>2010 /7&mdash;2010 /8：

<ul>
<li>中程在线： 架构设计最佳实践与方法体系</li>
</ul>
</li>
<li>2009 /8&mdash;2009 /8：

<ul>
<li>Sun：  sun架构师标准课程培训SL425，获SL425结业证书</li>
</ul>
</li>
</ul>


<h3><a name="6"></a>FAQ</h3>

<p>Q:<br/>
架构工作中最重要的是什么？<br/>
A:<br/>
最重要的是做出折中，架构工作中遇到的问题往往不是非黑即白的，最后的答案是折中的结果。
不仅要敢于折中，还要善于折中。
不仅要关注折中这个结果，还必须持续关注和管理折中的条件、折中的范围、折中的程度、折中的影响。</p>

<p>Q:<br/>
架构工作中最难的是什么？<br/>
A:<br/>
个人感到比较难的有两点。<br/>
* 第一点是管理架构设计过程。
  很多时候架构设计过程过于依赖架构师个人的经验甚至直觉，过程本身难以控制，同时架构知识也很难积累和分享。<br/>
* 第二点是架构的执行。架构只有执行了才能产生作用。
  但架构执行的过程却往往缺少重视和指导，在长时间跨度、参与人员复杂、需求随时变化等等因素的影响下，架构执行走样的情况经常发生。
  如何避免架构执行走样，或者及时发现和纠正走样，是一个还没想透彻的问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[敏捷的架构设计（六）：领域地图（二）]]></title>
    <link href="http://nielinjie.github.io/blog/2014/04/24/aa4/"/>
    <updated>2014-04-24T17:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/04/24/aa4</id>
    <content type="html"><![CDATA[<blockquote><p>敏捷已死，而敏捷性长存。</p></blockquote>

<h3>如何建立领域地图</h3>

<!-- more -->


<p>以下直接转帖“领域地图”工作开始时的kickoff邮件，可以体现我们建立“领域地图”方法的基本思路。</p>

<hr />

<ol>
<li>“领域地图”编制和使用将是一个渐进的和团队参与的过程。地图将逐步进化和完善，于此同时可以使用。</li>
<li>“领域地图”的目的是将系统的领域知识（业务知识）进行整理，使其结构化，为相关工作提供指导。比如：架构设计、包划分……</li>
<li>“领域地图”中的知识来源于：

<ol>
<li>同学们和业务同事的记忆中或者从其他渠道整理的业务知识。</li>
<li>从代码中发掘来的业务知识。</li>
</ol>
</li>
<li>“领域地图”希望展现的是业务概念及其关系。是一个静态的领域模型视图。“功能地图”也是一个领域模型的一个视图，是动态视图。两者保持一致并相互支持和完善。</li>
<li>“领域地图”编制工作要点大致是：

<ol>
<li>工作在“领域地图白板”上进行，就是“英雄联盟白板”<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>的右侧白板。</li>
<li>图上的要素说明如下：

<ol>
<li>紫色矩形：来源于同学们的业务知识（3.a），目前主要来源于SA维护的“功能地图”。</li>
<li>绿色矩形：来源于代码的架构现状。既有可能是从代码发掘的正面的业务知识（3.b），也有可能是系统多年积累来负面现状。</li>
<li>橙色塔形：从i，ii两点综合而来的理想或者说是设计结论，是领域地图的结果。由架构师和开发同学们讨论确立。</li>
<li>紫色和绿色的post上的文字可以是一些词语，也可以是一些描述。橙色的post是结果，一般是一个词语，是英文的，便于指导后续架构和设计工作。</li>
<li>post之间的距离表示概念之间的关系。间隔较小进而重叠的，表示业务概念有较多重合和交互；间隔较远的，表示业务概念分隔明显。</li>
</ol>
</li>
</ol>
</li>
<li>对“领域地图”的使用目前主要体现在代码的结构改进，目标是按领域组织代码。

<ol>
<li>对照橙色塔形和绿色矩形，可以发现现状与理想间的差距，是我们的改进方向，用红色post表示。</li>
<li>从红色的post，产生可衡量可执行的改进任务，用紫色post表示，与“英雄联盟”白板上内部改造需求一致，便于移动到“英雄联盟”上跟进。（虽然与5.b.i中的颜色一样，但内容会很不一样，应该不会混淆。）</li>
<li>在“英雄联盟”白板上，有时会有橙色塔形标注“DM”（domain map）贴在任务卡片上，表示此项任务涉及到的领域知识（业务知识）必须在设计阶段在“领域地图”上体现。（和要求设计复审的符号相似，都是橙色塔形，不过那个上标注“D”）</li>
</ol>
</li>
</ol>


<p><img src="http://nielinjie.github.io/images/kanban/dm.jpg"></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>该系统敏捷开发过程的用户故事白板。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[敏捷的架构设计（五）：领域地图（一）]]></title>
    <link href="http://nielinjie.github.io/blog/2014/04/24/aa3/"/>
    <updated>2014-04-24T16:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/04/24/aa3</id>
    <content type="html"><![CDATA[<blockquote><p>敏捷已死，而敏捷性长存。</p></blockquote>

<h3>什么是“领域地图”？是“领域模型”么？</h3>

<!-- more -->


<p>基本上，就是的。</p>

<p>这是一个历史悠久的系统，历经多年的进化，长久以来团队不知道它的整体需求是怎样的，也缺少有条理的领域知识积累。风险逐渐积累。</p>

<p>现在到了系统整理领域知识，尝试建立领域模型的适当时机——</p>

<ul>
<li>事务脚本风格向领域划分风格的重构<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>已经在重点局部取得了阶段性进展，现在到了推广到全局的时间了。既然是“按领域划分”，我们自然需要一个领域模型作为划分原则。</li>
<li>SA同学正在整理全局“功能地图”、测试同学整理“全量测试案例”，这些东西希望能与代码发生联系，需要一个中枢。在上述的架构风格下，这个中枢只能是领域模型。
我们画了个图来分析领域模型的中枢地位。如后所示。</li>
</ul>


<p>虽然是一种模型，但叫“地图”不叫“模型”——</p>

<ul>
<li>尺度大，粒度大，只有宏观结构没有细节。是对领域的全局鸟瞰，感觉就像是面对地图。</li>
<li>强调它的最高指导意义，类比“军事地图”。感受下。:-D</li>
<li>SA同学的叫做功能“地图”，我们也叫“地图”。</li>
</ul>


<p><img src="http://nielinjie.github.io/images/kanban/gongneng.png"></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>关于重构有个系列的blog即将写，届时这里换成一个链接……<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[向Octopress贡献（二）：连载系列]]></title>
    <link href="http://nielinjie.github.io/blog/2014/04/20/series/"/>
    <updated>2014-04-20T23:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/04/20/series</id>
    <content type="html"><![CDATA[<p>我们常常会发表一些连载的系列文章。
这些文章时间上有时会相互隔开，这时候默认的导航链接就不太方便。
需要一个新的方式在同一系列的连载文章间跳转。</p>

<!-- more -->


<ul>
<li>延续上篇文章的思路，采用js来实现功能。</li>
<li>在每个post头部的yaml metadata中添加连载系列的相关数据，比如这篇文章添加：<code>series: ["向Octopress贡献 2"]</code>。</li>
<li>Jekyll会自动将所有的metadata都解析出来，这样全局的json文件中可以容易地包含相关数据。</li>
<li>在适当的地方嵌入相应地html文件，其中的js根据json产生相关的内容。</li>
<li>代码在这里：<a href="https://github.com/nielinjie/nielinjie.github.io/commit/4a599e5d1296b420dc13473c4e6bbaf4d55fc198">https://github.com/nielinjie/nielinjie.github.io/commit</a>。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[向Octopress贡献（一）：动态内容]]></title>
    <link href="http://nielinjie.github.io/blog/2014/04/20/xiaowanyier/"/>
    <updated>2014-04-20T23:06:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/04/20/xiaowanyier</id>
    <content type="html"><![CDATA[<p>同学们往右看：就是那个一坨一坨飘一飘的东西。8-D<br/>
每个圆表示一个category，它的大小表示该category名下文章的数量（相对的）；两个圆之间的连线表示两个category有联系，也就是说有文章同时属于这两个category。
两个圆距离越近，则category的关系越密切，同时属于这两个category的文章越多。<br/>
点击圆形，将来到一个显示该category下所有文章的页面。</p>

<!-- more -->


<p>这只是一个初步的demo，有兴趣的同学可以沿着这个思路创造更多有意思的动态内容。</p>

<ul>
<li>新建一个静态的文件，让Jekyll在generate的时候将整个site的数据写进去。这里我放在根目录，用的是json格式。</li>
<li>定制aside添加一个html文件，我这里是category.html。</li>
<li>category.html里面用js绘制需要的动态内容。引用上面的json文件，你可以利用所有数据为所欲为。</li>
<li>代码看这里：<a href="http://github.com/nielinjie/nielinjie.github.io/commit/3abeab7a7f6d5170be3ae1f7294314470063e88b">http://github.com/nielinjie/nielinjie.github.io/commit</a>。</li>
</ul>


<p>至于显示category文章的页面，比较简单。通过url上queryString传递相应参数即可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[语录：雪人（四）]]></title>
    <link href="http://nielinjie.github.io/blog/2014/04/12/said-xueren4/"/>
    <updated>2014-04-12T23:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/04/12/said-xueren4</id>
    <content type="html"><![CDATA[<p>你感到雪人项目进行得还算顺利，虽然样子有点奇怪。
直到有一天PO突然说道：“经过调研，现在的孩子喜欢的其实是蜘蛛侠不是蜘蛛。”
你于是尝试铲掉其中六条腿，雪人摇摇欲坠。 “架构太不敏捷了。”——PO大喊。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[敏捷的架构设计（四）：来提意见]]></title>
    <link href="http://nielinjie.github.io/blog/2014/04/07/aa25/"/>
    <updated>2014-04-07T16:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/04/07/aa25</id>
    <content type="html"><![CDATA[<blockquote><p>敏捷已死，而敏捷性长存。</p></blockquote>

<p>在第一块看板前，邀请一些资深同学就这块看板和它背后的“风险驱动的架构设计”方法进行了一些讨论。</p>

<!-- more -->


<p>同学们的意见主要集中在：</p>

<ul>
<li>如何确保没有遗漏的风险？</li>
<li>知识如何积累和传承？</li>
</ul>


<p>第一个问题。很难给出满意的答案。</p>

<p>目前来看，对风险的识别主要靠架构师和开发团队的经验。
如果架构师和团队经验不足，就会有风险遗漏，导致架构设计不能解决所有需要解决的问题，不能满足要求。<br/>
这个问题跟架构设计方法关系不大，不管采用何种架构设计方法，都需要首先发现待解决的问题，再去解决它。
发现问题的阶段，对架构师和团队的经验的依赖是很难避免的。
比如比较传统的三段式架构设计方法<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，是以需求驱动的架构设计方法，要求识别关键功能功能、质量场景等作为待解决的问题。
方法体系中虽然提供了一些工具和指导，但这些识别仍然依赖架构师的经验。</p>

<p>从另一方面讲，应该避免对风险“过度识别”。风险驱动的架构设计隐含了一个重要观点：不需要完备的架构设计。
不完备的架构设计要求掌握好一个度：识别与忽略的度。而“风险”，恰好是掌握这个度的工具。过度识别风险，把不是风险的识别为风险，等于是放弃了这个度的平衡，也就放弃了不完备的架构设计这一核心理念。</p>

<p>回到当前实践中，我们计划采取的措施是：制成一个风险检查清单，随时对照检查，看是或否遗漏，检查清单的来源包括但不限于：<br/>
1. 传统架构设计方法的一些现成知识，比如质量要求检查清单。<br/>
2. 企业中积累的知识，比如规章制度、相似项目的经验教训。</p>

<p>第二个问题。看似容易回答。</p>

<p>这里的“知识”主要指两方面的内容：架构设计的过程和架构设计的结果。
不管是哪个方面，其实并不是所有都需要积累和传承。</p>

<p>我表示计划这样来做：对于每一项风险，我们都执行了一系列的有针对性的架构任务（看板上体现为绿色的卡片），这些卡片的生命周期，其实就是对应的架构设计的过程，这些卡片的产出，其实就是对应的架构设计的结果。
当我们制定任务、绿色卡片生成的时候，我们多考虑一件事情，就是这个卡片的生命要不要记录下来，它的的产出物要不要记录下来。把考虑的结果标记在卡片上，任务完成，卡片存档的时候，我们按照这个标记制定相应地记录就可以了。</p>

<p>有同学对这个办法并不认可，认为知识积累和传承主要满足项目结束后的维护同事需要。从当前团队的角度来考虑某个知识是否需要记录，结果往往会遗漏。
我认为这个担忧有一定道理，但我理解“不完备架构设计”理论对这个问题的观点是：没人知道后来者真正需要什么文档，宁愿他们找不到文档，也不要走上全文档的老路。</p>

<p>实践中，我们会先按上述的计划做，观察一段时间再说。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>请见另一篇博客（搬家未完成……）<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[敏捷的架构设计（三）：第一块看板]]></title>
    <link href="http://nielinjie.github.io/blog/2014/04/03/aa2/"/>
    <updated>2014-04-03T23:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/04/03/aa2</id>
    <content type="html"><![CDATA[<blockquote><p>敏捷已死，而敏捷性长存。</p></blockquote>

<p>这是一个架构“普通”的项目。也是第一个系统实践“风险驱动架构设计”的项目。</p>

<!-- more -->


<p>下面介绍一下这个项目的“架构看板”——</p>

<ul>
<li>看板空间分为三列。

<ul>
<li>第一列，红色卡片，放置识别到的风险，包括风险的描述、评价手段、影响程度和优先级等。</li>
<li>第二列，蓝色卡片，放置对策，包括指导原则、注意事项、大致计划、研究的中间结果等。</li>
<li>第三列，绿色卡片，放置可以执行的任务。</li>
</ul>
</li>
<li>看板空间分为多行，每行对应一个风险。它们按处置的优先级排序。</li>
<li>风险会随时被识别出来，来源包括但不限于架构师、开发团队、PO、领导和其他干系人。</li>
<li>所有的风险都会上板，有些会被否决或定为“微不足道”、“容易解决”等，这些被移动到最下方。</li>
<li>任务根据对策制定，必须是可执行、可衡量的。这些任务体现为绿色卡片。</li>
<li>绿色任务卡片，会跟用户故事拆分来的任务卡片一起排优先级，并采用和这些卡片一致的跟进方法。</li>
<li>当绿色任务卡片的状态变化，团队审视红色和蓝色卡片是否需要变化，随着应对措施的进行，对风险认识可能会有改变，对其的对策也可能随之变化。</li>
<li>团队随时可以移动、增减看板上的卡片，只要跟其他人达成共识。</li>
</ul>


<p>看板并不会直接帮助团队发现风险、制定应对措施、完成相关任务。
但看板能够有效地协助团队管理整个架构过程。
是敏捷过程中执行风险驱动架构设计方法的有效手段。</p>

<p><img src="http://nielinjie.github.io/images/kanban/rd.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[敏捷的架构设计（二）：风险驱动]]></title>
    <link href="http://nielinjie.github.io/blog/2014/03/31/aa1/"/>
    <updated>2014-03-31T21:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/03/31/aa1</id>
    <content type="html"><![CDATA[<blockquote><p>敏捷已死，而敏捷性长存。</p></blockquote>

<p>何为风险驱动的架构设计？
该方法认为：</p>

<ul>
<li>架构设计的（唯一）目的是应对工程风险。</li>
<li>当且仅当有风险被识别的时候需要考虑是否进行相应的架构设计。</li>
<li>架构设计采用的技术和投入的资源要与对应风险种类和程度相适应。</li>
<li>风险本身或\和对风险的认识会发生改变，相应的架构设计活动也会改变，架构设计结果也会改变。</li>
<li>风险驱动架构设计方法适合敏捷开发过程。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[敏捷的架构设计（一）：自问自答]]></title>
    <link href="http://nielinjie.github.io/blog/2014/03/31/aa/"/>
    <updated>2014-03-31T21:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/03/31/aa</id>
    <content type="html"><![CDATA[<blockquote><p>敏捷已死，而敏捷性长存。</p></blockquote>

<p>Q：敏捷开发过程貌似不需要架构设计，不需要架构师角色？<br/>
A：任何开发过程是否需要架构设计，不是由采用什么过程决定的，而是由需要完成的开发任务决定的。
如果开发的系统/软件有架构问题需要解决，不论采用何种开发过程、是否采用敏捷过程，都需要架构设计。
如果需要架构设计，而开发团队不确定有能力进行架构设计，那么团队就需要架构师介入/加入。</p>

<!-- more -->


<p>Q：敏捷过程对架构设计有没有什么特殊要求？<br/>
A：是否需要架构设计并不是由是否敏捷过程决定。但敏捷过程的特点，对架构设计活动有一些要求。<br/>
传统开发过程中，架构设计一般采用“集中式”架构设计方法，即在开发过程的某个阶段，集中完成所有的架构设计。<br/>
这种安排有一个先决条件，就是需求也必须集中完成。架构设计的依据是需求，如果需求不能在架构设计活动之前完成，架构设计就没有依据。
然而敏捷过程没有集中完毕的需求，只有“演进式”需求，需求是逐渐挖掘和显现的。这时的架构设计只能放弃“集中式”，同样也采用“演进式”。</p>

<p>Q：如何处理架构“演进”带来的“额外”成本和风险？<br/>
A：必须就事论事，没有统一答案。有些架构决策，可以尽量前置；有些架构决策，只能随需求逐渐明朗；有些架构决策，需要随时回顾改进。
架构设计不再是一个阶段性、集中处置的大任务，而需要划分成多个任务，按不同情况分别管理跟进。</p>

<p>Q：如何判断何时开始、何时完成、何种程度、哪一部分的架构设计？<br/>
A：“风险驱动架构设计”方法……</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[语录：雪人（三）]]></title>
    <link href="http://nielinjie.github.io/blog/2014/03/30/said-xueren3/"/>
    <updated>2014-03-30T15:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/03/30/said-xueren3</id>
    <content type="html"><![CDATA[<p>雪人项目进行得还算顺利。然而你发现兄弟们有些异样，他们常常盯着雪人的肚皮部位自说自话，这两天甚至开始聚在一起窃窃私语。
这些人都是多啦A梦设计风格的铁根粉丝啊，你能感受到设计一个口袋对他们来说是非常巨大的诱惑。
你曾经反复解释口袋有多危险，明令禁止任何设计口袋的企图。然而你知道这些根本无法打消你的担忧：架构走形的风险正如影随形。</p>

<p>这时候你忽然灵光一现，你埋头迅速制造了一个口袋，不是华丽的、未知的、危险的口袋，而是一个简单、简陋、安全、甚至没完全完成的口袋。“啪”，你把口袋拍在雪人肚子上。
你感到世界清净下来。你傻笑，认为自己理解了一个高大上的词语，叫做：“提升至架构的设计”。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[博客搬家了]]></title>
    <link href="http://nielinjie.github.io/blog/2014/03/22/new-blog-site/"/>
    <updated>2014-03-22T20:15:27+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/03/22/new-blog-site</id>
    <content type="html"><![CDATA[<p>看到了芝明同学的博客以及引擎octopress, 感觉漂亮又方便，于是把博客搬家了。</p>

<!-- more -->


<p>感谢octopress, 感谢芝明同学（<a href="http://zhaozhiming.github.io">http://zhaozhiming.github.io</a> ），感谢github。听说github正在遭受ddos攻击，祝好运。</p>

<p>期间只遇到一个编码问题，如下。感谢这位同学的博客，问题很快解决了。
<a href="http://fedcuit.github.io/blog/2012/08/02/config-octopress-on-mac/">http://fedcuit.github.io/blog/2012/08/02/config-octopress-on-mac/</a>
 见文章中的最后一个问题：YAML Exception</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>➜  octopress git:(source) ✗ rake generate
</span><span class='line'>## Generating Site with Jekyll
</span><span class='line'>identical source/stylesheets/screen.css
</span><span class='line'>Configuration from /Users/nielinjie/Projects/octopress/_config.yml
</span><span class='line'>Building site: source -&gt; public
</span><span class='line'>YAML Exception reading 2014-03-22-new-blog-site.markdown: invalid byte sequence in US-ASCII
</span><span class='line'>/Users/nielinjie/Projects/octopress/plugins/backtick_code_block.rb:13:in `gsub': invalid byte sequence in US-ASCII (ArgumentError)
</span><span class='line'>  from /Users/nielinjie/Projects/octopress/plugins/backtick_code_block.rb:13:in `render_code_block'
</span><span class='line'>  from /Users/nielinjie/Projects/octopress/plugins/octopress_filters.rb:12:in `pre_filter'
</span><span class='line'>  from /Users/nielinjie/Projects/octopress/plugins/octopress_filters.rb:28:in `pre_render'
</span><span class='line'>  from /Users/nielinjie/Projects/octopress/plugins/post_filters.rb:112:in `block in pre_render'
</span><span class='line'>  from /Users/nielinjie/Projects/octopress/plugins/post_filters.rb:111:in `each'
</span><span class='line'>  from /Users/nielinjie/Projects/octopress/plugins/post_filters.rb:111:in `pre_render'
</span><span class='line'>  from /Users/nielinjie/Projects/octopress/plugins/post_filters.rb:166:in `do_layout'
</span><span class='line'>  from /Users/nielinjie/.rbenv/versions/1.9.3-p0/lib/ruby/gems/1.9.1/gems/jekyll-0.12.0/lib/jekyll/post.rb:195:in `render'
</span><span class='line'>  from /Users/nielinjie/.rbenv/versions/1.9.3-p0/lib/ruby/gems/1.9.1/gems/jekyll-0.12.0/lib/jekyll/site.rb:200:in `block in render'
</span><span class='line'>  from /Users/nielinjie/.rbenv/versions/1.9.3-p0/lib/ruby/gems/1.9.1/gems/jekyll-0.12.0/lib/jekyll/site.rb:199:in `each'
</span><span class='line'>  from /Users/nielinjie/.rbenv/versions/1.9.3-p0/lib/ruby/gems/1.9.1/gems/jekyll-0.12.0/lib/jekyll/site.rb:199:in `render'
</span><span class='line'>  from /Users/nielinjie/.rbenv/versions/1.9.3-p0/lib/ruby/gems/1.9.1/gems/jekyll-0.12.0/lib/jekyll/site.rb:41:in `process'
</span><span class='line'>  from /Users/nielinjie/.rbenv/versions/1.9.3-p0/lib/ruby/gems/1.9.1/gems/jekyll-0.12.0/bin/jekyll:264:in `&lt;top (required)&gt;'
</span><span class='line'>  from /Users/nielinjie/.rbenv/versions/1.9.3-p0/bin/jekyll:23:in `load'
</span><span class='line'>  from /Users/nielinjie/.rbenv/versions/1.9.3-p0/bin/jekyll:23:in `&lt;main&gt;'</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[语录：好的架构师]]></title>
    <link href="http://nielinjie.github.io/blog/2014/03/09/said-jiagoushi/"/>
    <updated>2014-03-09T21:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/03/09/said-jiagoushi</id>
    <content type="html"><![CDATA[<p>好的架构师说：好吧，重做是架构进化的一种形式，我们下一个架构将解决这些问题；脾气好的架构师说：好吧，你是老板，你说重做我们就重做；2b架构师说：重做？mb你是老板你了不起么？老子的架构不够nb么？老子的xxx风格yyy模式你sb懂得起么？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[语录：乌鸦]]></title>
    <link href="http://nielinjie.github.io/blog/2014/03/03/said-yuya/"/>
    <updated>2014-03-03T21:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/03/03/said-yuya</id>
    <content type="html"><![CDATA[<p>一只乌鸦口渴了……，可是他早上买的酸奶没拿吸管，他的勺子比瓶子口大……，这时候一只老乌鸦走过来，分享了他处理类似问题的经验，并声称已经已经被广为使用和验证。
乌鸦感到庆幸，立即找来了很多石子儿……，直到他认识到他要对付的是酸奶，而不是清水。</p>

<p>乌鸦看着表面上堆着石子儿的酸奶，自我感觉对“模式”的认识深了些。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[语录：手段和目的]]></title>
    <link href="http://nielinjie.github.io/blog/2014/02/15/said-shouduan/"/>
    <updated>2014-02-15T21:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/02/15/said-shouduan</id>
    <content type="html"><![CDATA[<p>“通用”是手段而不是目的，“简单”也一样，甚而“结构”也一样。感受下呢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[语录：雪人（二）]]></title>
    <link href="http://nielinjie.github.io/blog/2014/02/15/said-xueren2/"/>
    <updated>2014-02-15T15:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/02/15/said-xueren2</id>
    <content type="html"><![CDATA[<p>这时候走来一个大叔，他对多啦A梦风格的了解人所共知。他警告说多啦A梦的口袋充满了未知，非常危险。于是你谨慎地决定：多啦A梦风格的设计必须局限在雪人的手部。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[语录：雪人（一）]]></title>
    <link href="http://nielinjie.github.io/blog/2014/02/15/said-xueren1/"/>
    <updated>2014-02-15T15:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/02/15/said-xueren1</id>
    <content type="html"><![CDATA[<p>你正在堆一个雪人，突然觉得万一它活过来了，跑来掐你脖子可怎么办？于是你把雪人的手改成了多啦A梦风格。恭喜你，你掌握了风险驱动的架构设计方法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一场似非而是的DSL（后传）]]></title>
    <link href="http://nielinjie.github.io/blog/2013/09/02/dsl-post/"/>
    <updated>2013-09-02T21:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2013/09/02/dsl-post</id>
    <content type="html"><![CDATA[<p>这是后传，不是正传，主要写设计结果和实现的一些细节，不喜请无视。</p>

<!-- more -->


<p>DSL的一个片段如最后的代码所示，基本上满足了我们的要求——</p>

<ul>
<li>片段完整地描述了一个特征，包括扩展点、扩展等等各方面的信息。实例中，<code>dynamicProperty</code>、<code>show</code>、<code>mail</code>是三个不同的扩展点，大括号里面的内容是当某个业务差异时填入扩展点的具体扩展逻辑。而这个业务差异，由<code>condition</code>描述。</li>
<li>不存在片段中和片段间来回引用穿梭等影响阅读完整性的问题。</li>
<li>不同方面的内容描述形式一致。比如动态属性dynamicProperty和邮件策略mail是不同的特征，背后的业务知识是很不同的，但这里体现为统一的描述形式。</li>
<li>聚焦于业务概念，噪音很少。这个片段看上去，除了表示范围的大小括号外，基本上全部是业务概念。</li>
</ul>


<p>讲一些实现细节——</p>

<ul>
<li>DSL的实现基于Groovy的<code>ObjectGraphBuilder</code>。</li>
<li>示例代码中的<code>dsl</code>就是<code>ObjectGraphBuilder</code>的一个实例，<code>requirement</code>构建顶层的bean。</li>
<li>类似于<code>requirement{}</code>以及内嵌的<code>dynamicProperty{…}</code>都是一些普通的groovy方法调用，通过groovy的动态调用机制赋予这次调用一些逻辑，以<code>dynamictProperty</code>为例：

<ul>
<li>实例化一个类，根据方法名计算这个类的类名。这个例子里就是类<code>DynamicProperty</code>。</li>
<li>将这个实例set到上级bean的适当属性上，这个属性也是根据方法的名字计算得到的。这个例子就是属性<code>dynamicProperty</code>。</li>
</ul>
</li>
<li>上述的根据方法名计算类名和属性的办法是<code>ObjectGraphBuilder</code>原生的，比较简陋，需要做一些定制，<code>ObjectGraphBuilder</code>提供了定制的接口，分别是<code>ClassNameResolver</code>和<code>RelationNameResolver</code>。我们对简单的计算办法做了补充：

<ul>
<li>类名搜寻策略，原生的计算只有硬匹配，就是只能设置一个包名，每个方法名直接加在包名后面就得出类名。这个策略在我们这里完全行不通，因为我们这里的很多类，不是固定在某个已知的包里面的，比如扩展和扩展点，这些类是具体的，类名来自于具体逻辑所在的包，散布在整个系统。对此我们引入了类名搜索机制，在整个系统的包空间搜索需要的类。另外一方面，我们借助reflection，从上层bean的属性类型，得到需要的类。</li>
<li>属性搜寻策略，在原生的名字匹配的基础上，我们结合类型匹配，也就是根据类名对应策略得到的类名反过来匹配上层bean的属性类型，找到这个属性。比如<code>dynamicProperty</code>这个方法，上层的bean是没有一个叫“dynamicProperty”的属性的，但有个<code>Feature</code>类型的属性。<code>dynamicProperty</code>方法实例化<code>DynamicProperty</code>类，它是<code>Feature</code>的子类，可以匹配。</li>
<li>上述两个搜索策略都考虑了集合属性的情况，名字经过简单地单复数转化，读取类型时通过泛型的集合的参数类型读取。</li>
<li>有一种特殊情况，搜寻类名和搜寻属性的策略会相互影响，我们希望有一种特殊的策略能把两个搜索过程独立开。我们约定一种特殊的方法名字形式：<code>propertya$classb</code>，这样我们根据<code>propertya</code>计算属性，<code>classb</code>计算类名。更特殊的情况比如代码中的<code>$selectorRenderer</code>，只计算类名不计算属性，表示这里只实例化bean，不做上层bean的属性设置。这中特殊策略为DSL的编写带来了方便，但其实不是一种业务策略，在DSL的角度看来其实是一种噪音，我们尽量避免使用。</li>
</ul>
</li>
<li>相关的代码不多，已经放到github，供参考。<a href="https://github.com/nielinjie/dslOGB">https://github.com/nielinjie/dslOGB</a>。其中用于扫描classpath的依赖包<code>com.google.classpath</code>来自于介里：<a href="https://code.google.com/p/classpath-explorer/">https://code.google.com/p/classpath-explorer/</a>。</li>
</ul>


<p>代码：</p>

<pre><code>dsl.requirement{
    name('isStock')
    description('是否关联交易')
    condition(exp:'(owner.sortId==1 || owner.sortId==11 ) &amp;&amp; owner.taskComp.contains("PA002")')
    dynamicProperty{
        name('isStockTrade')
        cName('关联交易')
        type(java.lang.String.class)
        stringValidator()
        stringEditor()
        maxLength(10)
        minLength(1)
        isRequired(true)
        defaultValue(true)
        renderMap(key:'writable',value:$selectorRenderer())
        renderMap(key:'readOnly')
        activeEvent{
            change('var ....')
        }
    }

    show{
        flag(function:'submitTask',flag:'writable')
        flag(function:'approval',flag:'readOnly')
    }

    mail{
        handleMap(key:'New_Submit',value:'mailHandle')
        handleMap(key:'Edit_Submit',value:'mailHandle')
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一场似非而是的DSL（三）]]></title>
    <link href="http://nielinjie.github.io/blog/2013/09/01/dsl3/"/>
    <updated>2013-09-01T21:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2013/09/01/dsl3</id>
    <content type="html"><![CDATA[<p>上回说到，可读和全局，是我们的DSL形式要解决的主要问题。</p>

<!-- more -->


<ul>
<li>全局，要求DSL结构要精练，同时最好是层级结构，避免指针引用。</li>
<li>可读，要求DSL能以一种形式表达各个不同的业务方面，所以这个形式必须相当通用。</li>
</ul>


<p>此时那个最纠结的问题出现了：“相当通用”的DSL是不是D <strong><em>S</em></strong> L？毕竟，“通用”在一端，S在另一端。</p>

<p>幸运的是：我们决定先找到这个DSL再讨论它是不是真正的DSL。</p>

<p>既然需要相当通用，我们决定从通用的配置形式出发，我们的办法是——</p>

<ol>
<li>清理要描述的对象，明确其结构和关系，形成确定的业务模型。在这里就是“特征机制“涉及到的知识层的各个概念，比如特征、扩展点、扩展等。这个工作其实在“特征机制”设计期就已经完成了。</li>
<li>保证知识层业务模型的可读性，在我们Java系统中，就表现为相关的类（特征、扩展点、扩展等，包括抽象的类和具体的类），它们的类名和属性名、关系名都准确精练、可读。</li>
<li><p>然后我们使用一种通用的配置形式将这些类实例化（一些javabean），并关联在一起。这时候发现，我们的DSL，基本上等同于描述Bean图的DSL。</p>

<p> 这种配置方式是很常见的，有很多实现方法：</p>

<ul>
<li>Spring Bean XML：这个形式简单直白，通用性非常强，但过于冗长了些，很难满足全局性要求。噪音很多，很难说可读。</li>
<li>定制namespace的Spring Bean XML和其他简单的XML：粗略一看是个好主意，比上面的办法在体积和噪音两个方面都改善挺多。但仔细看看不对，要保证通用性，这种方法只能退化为前一种。</li>
<li>Json：形式上比较简洁，噪音比较少，基本已经满足要求。只是需要在配置中补充一些类型信息，而且处理这些信息需要自己实现，比较繁琐。</li>
<li>YAML：跟Json相似，类型信息方面实现上简洁些。</li>
<li>Groovy ObjectGraphBuilder：当我们已经开始深入研究YAML的实现细节的时候，回忆到世界上还有这个，各方面都符合要求。</li>
</ul>
</li>
</ol>


<p>至此，我们基本上找到了符合要求的DSL形式，期间也花了很多时间来思考那个纠结的问题：“相当通用”的DSL是不是DSL？现在，我们的回答是：这个DSL就是我们想要的DSL。我们认为——</p>

<ul>
<li>作为一门语言，其通用或者专用，主要是从使用者的视角来衡量，而不是从设计者、实现者的视角。虽然我们用通用的形式设计、用通用的方法实现这个dsl，但使用者撰写、维护时能接触到的，都是专有业务领域的概念，很少有领域之外的噪音。</li>
<li>任何定义，都是为作用服务的。我们选择DSL，是由于它的作用，而不是它的定义。如果一个东西被用作DSL，则它就是DSL。</li>
</ul>


<p>一场似非而是的DSL的故事就是这样，如果有同学对我们这个DSL具体是怎样的有兴趣，可以要求我写故事后传……</p>
]]></content>
  </entry>
  
</feed>
