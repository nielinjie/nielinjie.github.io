<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[聂同学]]></title>
  <link href="http://www.nietongxue.xyz/atom.xml" rel="self"/>
  <link href="http://www.nietongxue.xyz/"/>
  <updated>2015-12-24T14:18:53+08:00</updated>
  <id>http://www.nietongxue.xyz/</id>
  <author>
    <name><![CDATA[nielinjie]]></name>
    <email><![CDATA[nielinjie@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[“Reactive宣言里为什么有个消息驱动？”]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/12/23/md/"/>
    <updated>2015-12-23T16:31:35+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/12/23/md</id>
    <content type="html"><![CDATA[<p>宣言的其他方面描述的都是系统的外部特征：快速响应、容错、压力下的弹性。为什么单单加入“消息驱动”这个实现策略呢？</p>

<!--more-->


<p>外部特征被纳入一个“宣言”容易理解，是作为一种承诺和目标。实现策略为何要被纳入一个宣言？毕竟，如果我的系统能实现被期待的外部特征，谁在乎是什么东西驱动的呢？消息驱动？神经驱动？意念驱动？随便啊。</p>

<p>表面看来确实如此。</p>

<p>答案在于，消息驱动在这里并不仅是一个实现策略。宣言中提到的“系统”是多层的，包括大大小小各层级的系统，其中大系统往往由小系统组成。当诸多小系统组成大系统的时候，大系统的实现策略就成了对小系统的外部特征要求。小系统之间的交互，要遵循的就是消息驱动这个一致约定，这对与小系统来说是外部特征，而不是实现策略。</p>

<p>所以消息驱动这个要点，在Reactive的系统生态中，是相互间既能松散自治又能协同合作的重要保证。虽然对系统的最终用户可能没有重要意义，但却是开发者之间的重要承诺和共同目标。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Orchestration 和 Choreography]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/11/29/oc/"/>
    <updated>2015-11-29T15:01:02+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/11/29/oc</id>
    <content type="html"><![CDATA[<p>Orchestration 和 Choreography，这个两个词在跟“服务”有关的架构讨论中常有出现。比如微服务和SOA。</p>

<!--more-->


<p>如果直译的话，这两个词一个是“编曲”，一个“编舞”。</p>

<p>编曲和编舞都是编。编就是安排、设计。不论是微服务的服务还是SOA的服务，要想沟通协同，合力完成业务请求，都是需要安排设计的。</p>

<p>但二者编排的对象不同，一个是曲一个是舞。特别是，按照词的本意，这里的“曲”指的是“管弦乐曲”，是相对复杂宏大的演奏。</p>

<p>曲和舞有什么区别呢？</p>

<ol>
<li>曲需要指挥，舞不需要。乐者在演奏时，需要指挥随时指挥协调。而舞者则不需要，按照事前安排做好自己就行。需要跟其他舞者合作时，也由自己直接沟通完成。</li>
<li>曲分工复杂，舞比较简单。管弦乐曲演奏需要多种不同乐器多种不同乐者，要求彼此配合得当，才能演出成功。而舞蹈没那么多分工，即使是大型舞蹈，台上人多，但角色也就数种而已。</li>
<li>曲比较严肃，舞比较宽松。乐者的演奏和配合一丝不苟，少有随性。舞者则有较多的个人发挥空间。</li>
</ol>


<p>SOA的理念是自上而下，比较多的依赖于集中安排，运行时也需要明确的中间件进行中央控制协调。边界内有多种类型的服务，相互之间严密配合。SOA的风格类似于编曲。</p>

<p>跟SOA相比，微服务风格更类似于编舞。边界内的服务遵循简单的约定，负责一个特定的领域。他们的地位相似，实现方式和沟通方式由自己选择。</p>

<p>编曲和编舞是一种形象的比喻，并不会完全精确。架构师编排服务的时候不要照抄。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[系统要像什么？]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/11/20/system-like/"/>
    <updated>2015-11-20T10:39:55+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/11/20/system-like</id>
    <content type="html"><![CDATA[<p>系统不要像一座建筑或一台机器。</p>

<!--more-->


<p>要想办法让系统像一个生物，如能更进一步，要像一个社会。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读TOGAF（二）：ADM初瞥]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/11/17/togaf-adm/"/>
    <updated>2015-11-17T00:05:18+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/11/17/togaf-adm</id>
    <content type="html"><![CDATA[<!--more-->


<ul>
<li>ADM建议一系列的阶段和步骤。但不建议范围<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。</li>
<li>ADM是渐进迭代的。每次迭代有自己的范围，渐进产出。</li>
<li>ADM是可以调整包括裁剪的。但调整必须管理并维持。</li>
<li>ADM通过架构仓库参与到企业火锅<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。</li>
</ul>

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>架构范围包括：宽度、深度、时间范围、架构领域。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p><a href="http://www.nietongxue.xyz/blog/2015/11/07/togaf/">企业火锅</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读TOGAF（一）：企业大火锅]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/11/07/togaf/"/>
    <updated>2015-11-07T00:05:18+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/11/07/togaf</id>
    <content type="html"><![CDATA[<p>Enterprise Continuum， 我称作企业大火锅。</p>

<!--more-->


<p>热气腾腾地沸着。各种物料在里面翻滚，碰撞，成熟，积累。</p>

<p>食客不用看见那么多，眼中只有这一刻的这一坨，先捞去也……</p>

<p><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<p><img src="http://www.nietongxue.xyz/images/togaf/hot.jpg" width="500"></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>比喻有风险。如有跑偏，概不负责。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[架构设计过程的驱动技术（二）]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/10/28/driving2/"/>
    <updated>2015-10-28T09:06:49+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/10/28/driving2</id>
    <content type="html"><![CDATA[<p>模式驱动不是一种顶层的驱动技术。因为架构模式本身，严格来讲并不是对目标系统本身的分解（而特征和风险则是）。<!--more-->如果说得完整一点，应该是：“为了实现xx特征（或者控制xx风险），我们应用xx模式。”。所以模式驱动其实是在特征驱动或风险驱动之后接着应用的驱动技术。但实际很多情况下，团队只要稍微知道要设计的系统的类型，脑中已经冒出了许多模式，后续也是依据这些模式的应用来跟进，可以说淡化了原有的顶层驱动技术。</p>

<p>由于不是顶层驱动技术，模式驱动很难验证最终解决了问题，比如不能说：“由于我们使用了xx、yy、zz模式，所以我们能完成XX系统。”反过来，对于顶层的驱动技术，就可以说：“由于我们实现了所有典型的特征，所以我们能实现XX系统”，或者，“由于我们遏制了所有（发现了的）风险，所有我们能完成XX系统”。所以如果使用模式驱动，应该要回过头来，借助顶层驱动技术来验证问题的解决。从这个意义上来讲，可以说模式驱动是被顶层驱动嵌套使用的。</p>

<p>特征驱动和风险驱动分解问题时，也会频繁使用模式思维，但这不是模式驱动。比如说特征驱动，整理系统的质量需求的时候，我们常常使用一个“质量需求检查表”。其中列举了特定类型系统常见的质量需求。我们对此一一检视，判别目标系统是否有此需求。这是典型的模式思维。但这里的模式不是架构设计模式，这里也不是将目标系统分解为模式进行跟进。所以不是模式驱动的架构设计。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[方法论]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/10/26/method/"/>
    <updated>2015-10-26T21:24:20+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/10/26/method</id>
    <content type="html"><![CDATA[<p>方法论是路线图，不是轨道。</p>

<!--more-->


<p>想要像火车司机那样一趟又一趟，恐怕不能如愿。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[“架构是进化来的，不是设计来的。”]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/10/24/evolve/"/>
    <updated>2015-10-24T17:21:53+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/10/24/evolve</id>
    <content type="html"><![CDATA[<p>当然。</p>

<!--more-->


<p>但是，每一步的进化都是设计来的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[架构设计过程的驱动技术（一）]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/10/09/driving/"/>
    <updated>2015-10-09T21:31:05+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/10/09/driving</id>
    <content type="html"><![CDATA[<p>驱动技术是方法论的第一步，是对目标问题进行分割，并分别进行管理跟进的技术。</p>

<p>我们常说“这个问题从何处着手呢？”——驱动技术要做的就是：找到从何着手，跟进着手过程，评估着手效果，归纳着手结论。</p>

<!--more-->


<p>具体到架构设计方法论，驱动技术要解决的就是：</p>

<ol>
<li>如何将目标系统<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>分解为可以应对的问题。</li>
<li>如何跟进应对这些问题的过程。</li>
<li>如何评价问题被应对的程度。</li>
<li>如何归纳所有应对结果并形成架构设计。</li>
</ol>


<p>其中第一条，是区别各驱动技术的要点。也是理解和选择各驱动技术的要点。分解依据不同，跟进、评价、归纳等机制也相应不同。</p>

<p>从这个角度看，架构设计中常见的驱动技术有：</p>

<ol>
<li><p>特征驱动，或者叫需求驱动。分解依据是目标系统的特征。特征驱动是收集筛选系统的特征，并跟进特征的实现措施的驱动技术。经典的架构设计方法论多采用这种驱动技术。</p></li>
<li><p>风险驱动。分解依据是目标系统生命周期中蕴藏的风险。风险驱动是发现生命周期中的风险，并跟进风险的控制措施的驱动技术。风险驱动是“不完备架构设计方法”的主要驱动技术。作为本人团队最常用的驱动技术，前期博客已经做了阐述<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。</p></li>
<li><p>模式驱动。分解依据是团队积累的架构模式（也包括反模式）。模式驱动是筛选适用的模式，并跟进模式的应用措施的驱动技术。</p></li>
<li><p>直觉驱动。或者说不使用任何驱动技术。当团队处于非常熟悉的领域、平台、技术栈的时候，直觉驱动确实存在。这种情况下架构设计基本已不需要“过程”来管控。不需要过程管控的架构设计是否合理，团队中意见并不一致，个人认为要慎重<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>。</p></li>
</ol>


<p>（<a href="http://www.nietongxue.xyz/blog/2015/10/28/driving2/">后一篇</a>）</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>本篇中以新系统架构设计为例，但所谈适合其他架构设计，比如架构重整改进、仅设计一个模块等。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p><a href="http://www.nietongxue.xyz/blog/filter/filter.html?filterName=series&amp;filterValue=%E6%95%8F%E6%8D%B7%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1&amp;filterDes=Series%3A%20%E6%95%8F%E6%8D%B7%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1">系列：敏捷的架构设计</a><br/><a href="http://www.nietongxue.xyz/blog/2015/08/13/scenario/">以场景思维辅助风险驱动架构设计</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p><a href="http://www.nietongxue.xyz/blog/2015/10/04/process/">架构设计不能忽视过程产出</a><a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[架构设计不能忽视过程产出]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/10/04/process/"/>
    <updated>2015-10-04T10:25:03+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/10/04/process</id>
    <content type="html"><![CDATA[<p>跟开发过程中其他环节相比，架构设计往往更加依赖于架构师个人的经验和决定。
有些架构师和团队对架构设计过程比较随意。
我们常看到的介绍架构设计的文章，也多侧重于介绍设计结论。这些都似乎使得架构设计倾向强调最终结论，不太重视中间过程和过程产出。</p>

<p>最终结论固然是重要的，但过程产出也有重要意义。从几个方面来看：</p>

<!--more-->


<ol>
<li>架构设计需要迭代和回朔。在架构设计和执行的整个过程中，往往需要反复迭代，逐次逼近理想结论。期间有很多的回溯反复过程。如果没有必要的过程产出，很难有效地进行这种迭代。</li>
<li>架构设计需要沟通和协作。架构设计作为开发工作的一个环节，与其他环节有许多沟通协作。特别是，实现环节将直接使用架构设计结论。这些沟通协作要求交付物<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 有说服力，合作团队希望接受包括来龙去脉和前因后果的设计产出，而不仅仅是一个最终结论。过程产出能支持设计结论，提供说服力。</li>
<li>架构设计需要积累和分享讨论。架构设计结论作为组织内的高价值知识，需要有效地积累和分享讨论。这同样要求设计结论有系统性、有说服力，需要有过程产出。</li>
</ol>

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>交付物，不一定是书面交付物。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[技术栈是架构设计的目的么？]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/10/02/techstack/"/>
    <updated>2015-10-02T22:46:38+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/10/02/techstack</id>
    <content type="html"><![CDATA[<p>不是。</p>

<p>相比于架构设计的目的，技术栈更像是架构执行的手段。</p>

<p>“为了实现那样的架构设计，我们将使用这些的技术。……”</p>

<!--more-->


<p>既然架构设计和执行是连贯不分的一个整体，那么区分前者的输出和后置的输入有什么意义呢？我认为是有意义的。这是孰本孰末，孰因孰果的问题。试想这样的情况：架构执行过程中，如果发现栈中某技术不适用，是否可以更改？如果是执行的手段，我们可以便宜更改，只要不偏离设计结论；如果是设计的目的，我们不能随意更改，因为要改结论需要从论点、论据、论证一一检视更改。</p>

<p> <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>另一个角度说来，技术栈也确实常作为架构设计的重要产出物，体现着设计结论的一些方面。所以类似“XX技术在XX公司的应用”这样的句型，作为架构分享文章的标题经常出现。读到这样的文章，希望同学们以正确的姿势打开，从技术栈的展示中，窥见架构设计的来龙去脉。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[“别让牛人写代码。”]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/09/27/nocoolcode/"/>
    <updated>2015-09-27T16:51:48+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/09/27/nocoolcode</id>
    <content type="html"><![CDATA[<p>同意。</p>

<!--more-->


<p>牛人写的代码固然威力无穷，奈何太贵。不仅现在贵，将来更贵。</p>

<p>一般人看不懂，改不动，又不敢丢。活活贵死整个团队。</p>

<p>如果有别的办法，不要依赖于牛人写代码。</p>

<p><img src="http://www.nietongxue.xyz/images/nocoolcode/nocoolcode.jpg" width="350"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[“伪代码是好代码。”]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/09/25/fakecode/"/>
    <updated>2015-09-25T20:51:27+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/09/25/fakecode</id>
    <content type="html"><![CDATA[<p>可以这么说。</p>

<!-- more -->


<p>通常伪代码都直接描述了某个层面的业务逻辑，是比较典型的领域特定语言（DSL）。同时，也往往符合DDD中对统一语言的期望。</p>

<p>在系统中，如果有一个层次的代码可以集中精力于表达业务逻辑，而不用操心各种质量约束，无疑是理想的。</p>

<p>伪代码确实是好代码，如果它能如愿运行的话。</p>

<p><img src="http://www.nietongxue.xyz/images/fakecode/fakecode.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[以场景思维辅助风险驱动架构设计]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/08/13/scenario/"/>
    <updated>2015-08-13T15:15:34+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/08/13/scenario</id>
    <content type="html"><![CDATA[<p>“风险驱动架构设计”<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>需要架构师和团队及时发现风险。这一点是依赖团队经验的。这样的依赖常常引发人们的焦虑：是否所有的风险都被及时发现进而处理了？</p>

<p>不用说缺乏相关经验的团队，即使是经验丰富的团队，随着进入陌生的业务领域或技术环境，也不能避免再次陷入到这样的焦虑之中。</p>

<!-- more -->


<p>如何缓解焦虑，建立大家的信心呢？我们做了一些尝试——</p>

<p>每当我们害怕遗漏的时候，我们有个朴素的方法：列出所有可能，一一检视，从中挑出那些需要处理的。</p>

<p>怎么才能列出“所有”可能的工程风险呢？我们尝试的是场景思维：我们以软件工程中常见的场景为线索——</p>

<ul>
<li>系统处理典型需求的场景</li>
<li>发布新功能的场景</li>
<li>业务量发生显著变化的场景</li>
<li>常见故障和应对的场景</li>
</ul>


<p>根据业务领域、技术环境以及团队结构等因素的不同，这些场景中会发生不同的事件。通过虚拟这些场景和其中的事件，一一检视这些事件中可能蕴含的风险，就可以使我们发现风险的工作系统化。</p>

<p>有同学问到：去寻求一个“完整的”风险列表，不是跟“恰如其分的、不完备的”原则矛盾了么？并不是这样的。我们说的要恰如其分和不完备，指的是架构活动不追求全面，而不是说考虑范围不考虑全面。通过场景思维剪除掉不必要应对的风险，以后的架构活动仍然是恰如其分的。</p>

<p>我们可以从另一个角度来概述这件事情——</p>

<p>“不能发现所有风险”这个风险，是我们可能需要应对的第一个风险。如果需要应对，那我们的措施就是“场景思维法”。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p><a href="http://www.nietongxue.xyz/blog/2014/03/31/aa1/">“风险驱动架构设计”</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[雪人（五）]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/08/04/said-xueren4/"/>
    <updated>2015-08-04T21:10:16+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/08/04/said-xueren4</id>
    <content type="html"><![CDATA[<p>“最近好多展览，这些雪人真是太漂亮了！”<br/>
“是的。可惜不能看到建造和维护这些雪人的展览。”</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[架构工作中的三个关键词]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/07/29/3words/"/>
    <updated>2015-07-29T10:21:30+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/07/29/3words</id>
    <content type="html"><![CDATA[<p>这里是我在架构工作中强调的三个关键词。是我工作桌面上保留时间最长的一个Post，也许会一直保留下去吧。</p>

<!-- more -->


<h4>Structure</h4>

<p>结构。在有些观点中，结构就是架构的定义，比如：“架构就是系统中的元素以及它们之间的关系”。<br/>
架构的结果最终被体现为系统中的结构，架构的价值，也是通过系统中的结构体现。</p>

<h4>Risk</h4>

<p>风险。解决风险是架构的目的。所有的架构活动，都是为了消除或者减轻工程风险。<br/>
把风险作为架构过程的驱动力，是进行“恰如其分”的架构过程的有效选项。</p>

<h4>View</h4>

<p>视野。架构师需要随时与开发团队共享视野。<br/>
一方面保证开发团队对架构的认识和认同，另一方面保证架构师对需求的了解。</p>

<h4>最后</h4>

<p>来个靓照。是的，它有些沧桑了。:-D</p>

<p><img src="http://www.nietongxue.xyz/images/3words/post.jpg" width="300"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[中文字体]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/07/28/typo/"/>
    <updated>2015-07-28T16:41:56+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/07/28/typo</id>
    <content type="html"><![CDATA[<p><a href="http://typo.sofi.sh">typo.css</a> 提供的中文字体不错——</p>

<p><code>
PingFang SC, Lantinghei SC, Microsoft Yahei, Hiragino Sans GB, Microsoft Sans Serif, WenQuanYi Micro Hei, sans;
</code></p>

<!--more-->


<p> <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>2015年9月30日升级OSX到EI Capitan后，PingFang SC变难看了，改为了PingFang SC Light。话说只有我一个人觉得PingFang SC不好看么？只有Light和Thin勉强能看。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[问架构师候选人什么问题？]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/07/25/questions/"/>
    <updated>2015-07-25T09:57:11+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/07/25/questions</id>
    <content type="html"><![CDATA[<p>面试时交流时间有限，应该问你的架构师候选人什么问题？</p>

<!--more-->


<h4>Q1：架构工作有些什么步骤？架构工作与其它开发工作的关系如何？……</h4>

<p>有些架构师认为此类问题比较重要。只有弄清楚了这些问题，才能算是掌握了架构方法论，能够保证可控可重复地进行架构设计。而另一些架构师则认为，只要能产出切实可用的系统，架构设计是什么，它如何达成的都不重要。</p>

<p>个人认为方法论是重要的。你团队中的架构过程和成果需要积累和传承，适当的方法论可以在架构师（包括开发团队）之间统一讨论语言和产出物，利于积累和传承。</p>

<p>特别是，如果你认为你的架构师应该负责建立或提高架构和开发的团队和流程，你需要问此类问题。</p>

<h4>Q2：假设现在需要搭建XX类型的系统，你如何思考？</h4>

<p>这类问题是开放式的主观题。涵盖范围很广，可以全面地考察架构师的思维方式、方法论、知识、经验，所以被广泛使用。这类问题很好用，但需要注意。它常常引来候选人的长篇大论，从方法到模式，从前台到后台，从需求到设计，…… 所以交流过程中需要控制和引导，避免被淹没在回答当中，当候选人提到了想要重点考察的领域，需要有针对性地进行专门的提问和讨论。</p>

<h4>Q3：假设现在遇到X问题，解决方案是什么？</h4>

<p>这类问题考察的是架构师的经验。如果他<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>遇到和解决过同类问题，并且记住了解决方案，他就能回答，如果没有，就不能回答。因为没有人能够在四目相对的几秒十几秒时间里解决一个陌生的架构问题。要知道架构决策和设计不是一个靠急智能够胜任的工作。</p>

<p>所以如果你需要架构师招聘进来以后能够立即解决一个问题——也就是你提问中的那个问题，你需要问这类问题。个人认为这种情况要尽量避免，因为这样就放弃了对其它方面素质的考量和选择。</p>

<h4>Q4：AA设计模式中……、BB数据库中……、CC算法中……、DD类里面……</h4>

<p>这类是涉及到某些领域的细节问题，如果你需要架构师兼任此领域的技术专家（这种情况常见），那你需要问这类问题。</p>

<p>有些架构师可能对某些领域的细节问题解决能力不足，但他隔离和描述问题的能力很强，进而可以很快从外部找到并应用现成的解决方案。这样的架构师虽然称不上技术专家，但一定程度上其实可以解决大量的具体问题。</p>

<p>依据你面对的问题、团队规模及可以负担的成本，你需要判断是否需要真正的技术专家。</p>

<h4>Q5：在你做过的YY事情中，是如何考虑ZZ问题的？</h4>

<p>这类问题跟Q2问题功能相似。同时它可以避免Q2问题的一个弱点：万一候选人没有XX类型系统的工作经验，考察就没办法进行下去。除非：你的职位必需这类系统的知识和经验。这种情况常见，比如招聘互联网产品的架构师往往认为必需“大并发系统”的知识和经验。</p>

<h4>Q6：最近在干什么？学什么？比较关注什么？</h4>

<p>个人比较喜欢此类问题。但这类问题完全没有参考答案，需要提问人注意从回答中挖掘想要的信息。比如候选人对职业生涯的规划、对技术走势的判断等等。否则问答完了之后，对候选人是否适合职位的判断帮助不大。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>文中所有的“他”，均不特指男性。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[单体优先还是微服务？]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/06/28/monolithf/"/>
    <updated>2015-06-28T16:58:26+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/06/28/monolithf</id>
    <content type="html"><![CDATA[<p>单体优先还是直接采用微服务？这个问题随着马丁大叔的文章Monolith First<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>发布，显得再次热闹起来。</p>

<p>在我看来，从三个方面尝试分析这个问题。</p>

<ol>
<li>微服务架构和单体架构区别是什么？</li>
<li>系统建立之初这些区别意味着什么？</li>
<li>如果系统建立之初使用单体架构，后续过渡到微服务架构代价如何？</li>
</ol>


<!-- more -->


<h3>微服务架构和单体架构区别是什么？</h3>

<p>微服务架构与单体架构的区别，本质是系统各部件间分隔的强度大小。</p>

<p>从下面几个方面看一看：</p>

<table>
<thead>
<tr>
<th><i></i> </th>
<th>微服务 </th>
<th> 单体</th>
</tr>
</thead>
<tbody>
<tr>
<td>领域分隔 </td>
<td> 领域被分隔为微服务。分隔力度大，相互间的影响较小。微服务可以各自拥有不同的进化节奏，不同领域的创新可以分别实施、快速落地。 <br/> 领域间的调用相对困难，需要一些基础服务帮助，比如服务注册和寻址等。 </td>
<td> 领域的分隔表现为模块的分隔，其间的联系简单直接。</td>
</tr>
<tr>
<td>团队分隔    </td>
<td> 团队按微服务配置。成员专注于小的领域和代码集。沟通成本低。容易学习。<br/> 需要部件之间紧密协作时相对困难，比如当代码需要在部件之间移动。  </td>
<td> 整个系统一个团队。如果系统变得庞大，成员就需要学习大量的代码和领域知识，团队内的沟通和协作也变得低效。不得不分割团队时容易按职责分割，形成竖井团队<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。</td>
</tr>
<tr>
<td>技术分隔    </td>
<td> 在不同的微服务中，可以根据不同的业务特性分别选择适当的技术。包括可以分别选择适当的存储策略。    </td>
<td> 整个系统（甚至整个企业）统一的技术栈，管理起来看似简单。但有时候统一的标准并不适合所有的实际情况。</td>
</tr>
<tr>
<td>运行时分隔 </td>
<td> 各部件通常运行于不同的进程。容易进行错误隔离。可以分别伸缩。<br/> 运行时需要管理的单位较多，相对困难，需要一些专门的运营工具。</td>
<td> 通常运行于同一个进程。部件间协作的额外开销很小。</td>
</tr>
</tbody>
</table>


<h3>系统建立之初这些区别意味着什么？</h3>

<p>通过上面的罗列比较我们可以看到：对于复杂系统，微服务架构可以有效地分隔复杂度。
但微服务架构有风险：首先需要前期就对领域有良好的认识以便分割。其次需要一定的基础服务和工具。如果团队并不熟悉这种相对较新的架构，学习和适应的成本还是比较高的。
如果我们的系统在建立之初比较简单，在各个方面基本上并不需要高强度的分隔，单体架构往往就能够满足要求。</p>

<p>我们看看什么情况下可能有可能直接从微服务架构开始：</p>

<ul>
<li>我们的系统所面对的领域规模很大，需要进行分割；同时，我们很清楚如何分隔。（……，好吧，这种情况基本没有，囧）</li>
<li>我们的团队规模太小，从一开始就无法单独承担系统的规模。</li>
<li>我的企业默认架构就是微服务，很多系统已经实践过了。</li>
<li>我的老板认为微服务很酷，必须上。</li>
<li>……</li>
</ul>


<p>这些情况下，如果各方充分认识到微服务的代价并作出应对预案，是可以直接应用微服务架构的。</p>

<p>在所有的代价中，有一种最重要，值得再说一遍：领域划分不清晰的情况下请务必慎重，在微服务间移动领域逻辑是非常昂贵的。</p>

<h3>已有单体架构系统过渡到微服务架构代价如何？</h3>

<p>马丁大叔提出的“扼死大法”<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>是一种自然有效的过渡方式。但跟其他所有的方式一样。
这个办法的难度和相关代价还是取决于单体本身的结构特点。
如果单体自身拥有良好的结构，容易从中剥离出相对独立的领域逻辑。那我们可以有条不紊逐步剥离：</p>

<ol>
<li>为新特性创建微服务，单体保持不变。</li>
<li>在单体中识别内聚的子领域，对应地各自剥离为微服务。</li>
<li>按照业务价值和变化频度安排优先级。</li>
<li>并不追求完全消灭单体。</li>
</ol>


<p>另一种情况，单体本身是一个大泥球。那就没有那么幸运了，我们必须先整理单体本身。</p>

<h3>结论</h3>

<ul>
<li><p>单体优先，同时请做好准备，你可能很快需要过渡到微服务。所以做一个“微服务友好”的单体，并适时开始基础服务和团队技能的准备。</p></li>
<li><p>读到这里仍然觉得自己应该立即微服务的同学：请不犹豫地微服务吧。</p></li>
</ul>

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p><a href="http://martinfowler.com/bliki/MonolithFirst.html">Monolith First</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>“竖井团队”被认为在大部分情况下是反模式。参见<a href="http://www.thoughtworks.com/radar/techniques/inverse-conway-maneuver">“反Conway策略”</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p><a href="http://www.martinfowler.com/bliki/StranglerApplication.html">StranglerApplication</a><a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[译：迁移至云架构（六）]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/06/07/cloud6/"/>
    <updated>2015-06-07T11:15:31+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/06/07/cloud6</id>
    <content type="html"><![CDATA[<p>（<a href="http://www.nietongxue.xyz/blog/2015/06/07/cloud5/">接前文</a>）</p>

<h2>分布式系统指南</h2>

<p>当我们开始构建由微服务组成的分布式系统，我们需要应对单体架构系统一般不会需要的非功能需求。有时候需要跟物理定律周旋，比如一致性、延迟、网络分割等。然而另一些问题比如脆弱和可管理性就可以用相对通用的模式来解决。下面我们将介绍这方面的一些实践。</p>

<!--more-->


<p>这些实践来自于<a href="http://projects.spring.io/spring-cloud/">Spring Cloud</a> 和<a href="http://netflix.github.io">Netflix OSS</a> 系列项目的组合使用。</p>

<h3>有版本的分布式配置</h3>

<p>我们已经讨论了<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>适当的配置管理机制的重要性，提到过配置通过操作系统级别的环境变量注入。这种方式非常适合简单系统。但当系统复杂性增加，我们可能需要更多的配置功能，比如：</p>

<ul>
<li>为正在运行的应用改变日志级别，以便诊断生产问题。</li>
<li>改变接收消息的线程数。</li>
<li>报告所有的配置更改，支持生产系统的监管审计。</li>
<li>为正在运行的应用开关某个功能。</li>
<li>支持配置中的保密内容，比如密码。</li>
</ul>


<p>为了支持这些能力，我们的配置机制需要有如下的特性：</p>

<ul>
<li>有版本</li>
<li>可以审计</li>
<li>加密</li>
<li>刷新不需重启</li>
</ul>


<p>Spring Cloud项目中有个<a href="http://cloud.spring.io/spring-cloud-config/">配置服务器</a>支持这些特性。这个配置服务器保存了应用的配置文件，后台是一个git仓库，提供一套REST API（图3-1）。</p>

<p><img src="http://www.nietongxue.xyz/images/cloud/springConfig.png" title="[图3-1. The Spring Cloud Config Server]" ></p>

<p>图3-1. The Spring Cloud Config Server</p>

<p>剩下的问题是如何可以不重启应用客户端修改配置。这个能力由Spring Cloud的另一个模块——<a href="http://cloud.spring.io/spring-cloud-bus/">总线</a>提供。这个模块用一个轻量级的消息中间件连接分布式系统中的各节点。它可以用来广播状态变化，比如我们的配置更改（图3-2）。
只要简单地向连入总线的任何应用的<code>/bus/refresh</code>地址发送一个HTTP POST，我们就可以提示所有连入的应用更新他们的配置值，通常更新到配置服务器上的最新值。</p>

<p><img src="http://www.nietongxue.xyz/images/cloud/springBus.png" title="[图3-2. The Spring Cloud Bus]" ></p>

<p>图3-2. The Spring Cloud Bus</p>

<h3>服务注册和发现</h3>

<p>当我们建立分布式系统，我们的代码和它的依赖之间就必须通过网络沟通。我们如何有效地将我们的微服务联系起来呢？</p>

<p>云中的一种常见的架构模式（图3-3）是建立前端（应用）服务和后端（业务）服务，后端服务通常不会被直接访问，而是通过前端服务间接访问。服务注册表存放了所有服务的信息，前端服务中有一个客户端库<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>可以到这些信息，从而可以处理路由和负载均衡事务。</p>

<p><img src="http://www.nietongxue.xyz/images/cloud/serviceRegistration.png" title="[图3-3. Service registration and discovery]" ></p>

<p>图3-3. Service registration and discovery</p>

<p>我们使用各种<a href="https://en.wikipedia.org/wiki/Service_locator_pattern">Service Locator</a>和<a href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency Injection</a>解决这个问题，面向服务架构长期使用各种服务注册机制。这里我们使用一个类似的方案：<a href="https://github.com/Netflix/eureka">Eureka</a>——来自于Netflix OSS项目，可以在服务定位的同时处理中间层服务的负载均衡、failover机制。<a href="http://cloud.spring.io/spring-cloud-netflix/">Spring Cloud Netflix</a>项目进一步简化了对Eureka的使用，它提供了一个基于Annotation的配置模型。</p>

<p>所有使用<a href="http://projects.spring.io/spring-boot/">Spring Boot</a>的应用都可以通过简单添加<code>@EnableDiscoveryClient</code>来获得服务注册和发现功能。</p>

<h3><a name="rlb"></a>路由和负载均衡</h3>

<p>简单的循环负载均衡在很多场景下是很有效的。但在云环境下的分布式系统需要进一步的路由与负载均衡行为。以前这通常由外部的集中的负载均衡服务提供。然而这种服务往往没有足够的信息和上下文，它们也没办法为应用提供最佳选择。同时，集中的解决方案存在单点失效的问题，当他们出问题了整个架构都要受到影响。</p>

<p>云架构把路由和负载均衡的职责转移到客户端。这种方案的一个例子是来自Netflix OSS项目的<a href="https://github.com/Netflix/ribbon">Ribbon</a>（图3-4）。</p>

<p><img src="http://www.nietongxue.xyz/images/cloud/clientLoadBalancer.png" title="[图3-4. Ribbon client-side load balancer]" ></p>

<p>图3-4. Ribbon client-side load balancer</p>

<p>Ribbon提供了丰富的功能：</p>

<ul>
<li>内建多种负载均衡规则

<ul>
<li>循环</li>
<li>平均响应时间加权的循环</li>
<li>随机</li>
<li>可用性过滤（避免tripped circuits和大并发连接数）</li>
</ul>
</li>
<li>定制均衡规则插件</li>
<li>与服务发现方案（包括Eureka）的可拔插集成</li>
<li>Cloud-native intelligence such as zone affinity and unhealthy zone avoidance</li>
<li>内建错误容忍</li>
</ul>


<p>就跟Eureka类似，Spring Cloud Netflix 项目进一步简化了对Ribbon的使用，将注入<code>DiscoveryClient</code>变为注入<code>LoadBalancerClient</code>，就可以从直接使用Eureka切换为使用Ribbon</p>

<h3><a name="ft"></a>错误容忍</h3>

<p>分布式系统潜在的错误比单体系统要多。现在每一个请求都需要使用数十个甚至上百个不同的微服务，其中的一个或多个出问题几乎是肯定的。</p>

<blockquote><p>如果不采取必要地错误容忍措施，30个依赖服务的系统每个月将有两个小时多的宕机时间，即使每个服务可用性都是99.99%。（99.99%^30 = 99.7% uptime = 2+ hours in a month）—<em>Ben Christensen, Netflix Engineer</em></p></blockquote>

<p>我们如何防止类似的错误堆积呢？</p>

<p>Mike Nygard论述<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>了几种有用的模式：</p>

<ul>
<li><a name="bc"></a>断流器<br/>
断流器会隔离一个服务，如果发现它的依赖服务状态不佳的话。断流器通常被实现为一个状态机（图3-5）。当它处于闭合状态，调用就简单地被传递到依赖。如果调用失败了，断流器开始对失败计数，当在特定时间内失败次数达到了特定值，断流器就切换到断开状态。当断流器处于断开状态，任何调用都会立即返回，根本不会真正尝试调用依赖。再过了一个特地时间过后，断流器切换到半开状态。在半开状态，调用会被传递到依赖，如果成功，断流器切换到闭合状态，否则切到断开状态。</li>
</ul>


<p><img src="http://www.nietongxue.xyz/images/cloud/stateMachine.png" title="[图3-5. A circuit breaker state machine]" ></p>

<p>图3-5. A circuit breaker state machine</p>

<ul>
<li>隔板<br/>
隔板分割服务，防止整个服务因为局部错误而整体失效。软件系统可以从多个层面应用隔板。简单地分割为微服务就是第一种应用。将应用进程分割为Linux容器<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>，使得单个进程不会影响整个机器，也是一种应用。还有个例子是将并行运算分散到多个线程池中。</li>
</ul>


<p>Netflix在库<a href="https://github.com/Netflix/Hystrix">Hystrix</a>中加入了很强大错误容忍功能。Hystrix通过<code>HystrixCommand</code>来将代码包装在断流器中。</p>

<p>Spring Cloud Netflix项目通过<code>@EnableCircuitBreaker</code>注解，在Spring Boot应用中加入Hystrix部件。并且借助一系列<a href="https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica">捐献的注解</a>使得编程更加的简单。</p>

<p>Hystrix不同于其他的断流器，它还应用隔板模式，将各个断流器封装在各自的线程池中。它还收集一些有用的数据：</p>

<ul>
<li>流量</li>
<li>请求速率</li>
<li>错误占比</li>
<li>Hosts reporting</li>
<li>延迟分布</li>
<li>请求结果：成功、失败、拒绝</li>
</ul>


<p>这些数据作为事件流散发，可以用另一个Netflix OSS工具—— <a href="https://github.com/Netflix/Turbine">Turbine</a>进行综合。单独的综合的数据都可以通过一个Hystrix面板展示出来（图3-6），面板对分布式系统的健康状况提供了很好地可视化。</p>

<p><img src="http://www.nietongxue.xyz/images/cloud/dashboard.png" title="[图3-6. Hystrix Dashboard showing three sets of circuit breaker metrics]" ></p>

<p>图3-6. Hystrix Dashboard showing three sets of circuit breaker metrics</p>

<h3><a name="api"></a>API网关和边缘服务</h3>

<p>我们已经提到了<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>微服务中服务方的服务整合，我们来具体看看它的必要性：</p>

<ul>
<li>延迟<br/>
移动端通常使用比较慢速的网络，如果应用需要依次跟几十几百个服务通信，那延迟是很难接受的。容易理解并行发起请求是很有必要的。相比于在各个不同的移动端平台上实现并行模式，在服务端实现会比较便宜也不容易出错。</li>
<li>续航<br/>
就算网络速度不是问题，客户端跟大量微服务打交道还是会有问题。使用网络对于移动端来说是很消耗电池电量的。移动开发者通常都希望减少与服务端的通信来增强用户体验。</li>
<li>设备多样性<br/>
移动端的设备多样性非常明显。比如厂商、尺寸、操作系统、编程语言等等都有很多不同。</li>
</ul>


<p><a href="http://microservices.io/patterns/apigateway.html">API网关</a>模式就是将移动端开发的负担转移到服务端。API网关就是一个普通的微服务，只不过它是与单个移动应用对应的，为它提供单一的后台入口。它每个请求都会跟几十几百个服务并行通信，将所有返回结果综合起来再返回到移动端。如果有必要，它也处理协议翻译的工作，比如HTTP翻译为AMQP。</p>

<p><img src="http://www.nietongxue.xyz/images/cloud/apiGateway.png" title="[Figure 3-7. The API Gateway pattern]" ></p>

<p>Figure 3-7. The API Gateway pattern</p>

<p>API网关可以用任何语言、运行时或者框架实现，只要它能支持web编程、并发以及跟后台服务通信的协议。流行的选择包括Nodejs（有reactive编程模型）和Go（有简单的并发模型）。</p>

<p>如果使用Java，可以考虑<a href="https://github.com/ReactiveX/RxJava">RxJava</a>， <a href="http://reactivex.io">Reactive Extensions</a> 的Java实现。毕竟如果只使用Java提供的原生特性，合并并行处理的结果这一点很难做好。</p>

<h2>总结</h2>

<p>以下又是译者自己总结的 :-)</p>

<ul>
<li>分解： 新特性作为微服务、防腐层、扼杀单体</li>
<li>分布式系统： 配置服务和管理总线、动态服务发现、去中心化的负载均衡、断流器和隔板、API网关</li>
</ul>

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p><a href="http://www.nietongxue.xyz/blog/2015/05/23/cloud2/#12f">十二因子应用</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p><a href="#rlb">路由和负载均衡</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>书：<em>Release It!</em><a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p><a href="http://www.nietongxue.xyz/blog/2015/06/02/cloud4/#c">容器化</a><a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
<li id="fn:5">
<p><a href="http://www.nietongxue.xyz/blog/2015/05/23/cloud/#mc">移动应用和客户端多样性</a><a href="#fnref:5" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
