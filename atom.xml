<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[聂同学]]></title>
  <link href="http://www.nietongxue.xyz/atom.xml" rel="self"/>
  <link href="http://www.nietongxue.xyz/"/>
  <updated>2016-04-02T15:21:31+08:00</updated>
  <id>http://www.nietongxue.xyz/</id>
  <author>
    <name><![CDATA[nielinjie]]></name>
    <email><![CDATA[nielinjie@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[架构是一种管理手段]]></title>
    <link href="http://www.nietongxue.xyz/blog/2016/03/19/am/"/>
    <updated>2016-03-19T09:59:18+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2016/03/19/am</id>
    
    <category term="/架构"/>
    
    <content type="html"><![CDATA[<p>是的。如果不是最重要的那一种的话。</p>

<!--more-->


<p>架构同时也是管理的目的。既是目的又是手段。有点像是修金字塔，基础部分的修建既是目的又是手段。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[“程序员需要工程思维”]]></title>
    <link href="http://www.nietongxue.xyz/blog/2016/03/13/quality2/"/>
    <updated>2016-03-13T19:46:06+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2016/03/13/quality2</id>
    
    <category term="/质量"/>
    
    <category term="/过程"/>
    
    <content type="html"><![CDATA[<p>有同学提到工程思维，认为借助传统的建筑、机械工程的思考方式，有助于控制软件工程质量<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。这当然是有益的。</p>

<!--more-->


<p>但我们需要注意，软件系统与传统建筑、机械系统有非常重要的不同。直接借鉴传统的建筑、机械工程思维，很多时候是不足以解决问题的。</p>

<p>最大的不同在于：软件系统不仅是运行着的，而且是演进着的<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。而且这个演进是必需的、积极的、有巨大价值的。这是软件质量控制的独特和真正困难之处。</p>

<p>传统工程一旦产出，产品本身就保持稳定。所以传统质量的定义是描述产出物的特征，符合这个特征的就是好质量，否则就是坏质量。对于特定的产品，质量的定义保持不变。质量控制的方法也以质量定义不变作为前提。</p>

<p>这个办法在软件这里不好用。因为产出物的特征不断变化，质量的定义必须不断变化。所以质量控制方法必须多增加一个维度，即质量定义本身的变化。有了这个维度，问题完全不一样了。</p>

<p>所以，从质量控制这个角度来说，将软件系统比作建筑、机械系统，软件工程比作建筑、机械工程是不理想的。不如把软件系统比作社会系统，把软件工程比作社会的发展演进。软件质量控制，更多的从社会科学领域借鉴方法。比如为了控制社会的有效运行，人类发明了立法、司法、执法等成体系的有效手段，我们可以借鉴，“反脆弱”<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>是个不错的尝试。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI0NjA1NTg0MA==&amp;mid=402605263&amp;idx=1&amp;sn=0490d0de815bef7ac9c61f8c47e0254e&amp;scene=2&amp;srcid=03136ItfAMvAXMJLxllTDEsp&amp;from=timeline&amp;isappinstalled=0#wechat_redirect">为了产品，程序猿请随时加满工程属性</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>“卖出不管”的传统软件这里不讨论。主要讲互联网系统比如SAAS。<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p><a href="http://www.nietongxue.xyz/blog/2015/05/23/cloud2/#an">“反脆弱”</a><a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重构，从知识结构开始（一）]]></title>
    <link href="http://www.nietongxue.xyz/blog/2016/02/20/dev-dc/"/>
    <updated>2016-02-20T14:17:28+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2016/02/20/dev-dc</id>
    
    <category term="/架构"/>
    
    <category term="/领域"/>
    
    <content type="html"><![CDATA[<p>在知识结构层面，我们认识到有两个问题：</p>

<!--more-->


<ol>
<li>没有意识到知识需要拆分。</li>
<li>知识的结构来自于“产品线”。</li>
</ol>


<h3>一、没有意识到知识需要拆分</h3>

<p>大家有个印象，认为对业务知识掌握越全面越好。没有意识到这里面其实有个陷阱。业务知识越全面越好，其实指的是“了解”得越全面越好，而不是“掌握”得越全面越好。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<p>所以大家没有想到需要对知识进行有意识地拆分。也就是说没有想到：</p>

<p><strong>知识需要结构。而且这个结构需要设计。</strong></p>

<p>我们来看看我们需要什么样的知识结构。</p>

<p>首先，我们的知识结构要能降低负担，使人集中精力。每个人掌握的知识刚好可以完成手边的工作。而不需要掌握所有的知识，就像造车轮胎的工程师不需要关心车身油漆的工艺，更不需要关心油漆工业发展趋势。</p>

<p>其次，我们的知识结构要能制造适当的隔离。这样我们能解开知识间的耦合，有助于解决知识在全局的概念不一致，也有助于协调知识演进的步调。</p>

<p>第三，我们的知识结构要能减少关联风险。知识不可能不与其他知识关联，那么我们希望关联越明确越稳定越好。如果关联不停产生不停终结不停变化，那么谁也没办法保证每次都能正确完整地识别。</p>

<h3>二、知识的结构来自于“产品线”</h3>

<p>虽然大家并没有意识到需要关注知识结构。但知识结构其实已经自然存在了。我们团队的结构和需求驱动的研发过程决定了我们的知识结构直接来自于我们的“产品线”结构。<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p>

<p>以“产品线”分布的知识有显著的特点：</p>

<ul>
<li>“补丁”： 补丁指的是一个产品线涉及到的业务知识方面很多，而且在无法控制地不断堆积。只要功能集发生变化，更多业务知识就要堆积上来。</li>
<li>“碎片”： 碎片是指一个方面的业务知识分散在不同的产品线上，这些业务知识的一致性很难保证。要想维护一套完整的业务规则，往往需要在各个产品线穿梭，不时进行跨产品线归纳。</li>
</ul>


<p>以上面我们谈到的好的知识结构的要求来看。来自于“产品线”的知识结构，一个要求都不能满足。</p>

<p>（待续，下一篇讲讲我们的解决思路）</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>所谓“掌握”，指的是可以直接指导研发，并使其产生业务价值的程度。而“了解”，指的是明了其大致原理的程度。举个时髦的例子，你能明白《时间简史》，大概可以算是了解相对论。但你能设计探测引力波的方案，才能算掌握相对论。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>我们这里的“产品线”可能跟很多团队的“产品线”概念不一样。我们的产品线大部分其实是同一套业务的不同功能集。比如有面向不同用户角色的不同功能集，体现在不同客户端的不同功能集等等。<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在发展中团队：开发质量问题]]></title>
    <link href="http://www.nietongxue.xyz/blog/2016/01/24/develop-quality/"/>
    <updated>2016-01-24T11:44:37+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2016/01/24/develop-quality</id>
    
    <category term="/开发"/>
    
    <category term="/过程"/>
    
    <category term="/质量"/>
    
    <content type="html"><![CDATA[<p>随着系统和团队规模逐渐成长，开发质量问题<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>一般有增多趋势。</p>

<!--more-->


<p>错误（包括低级错误）是不能完全避免的。开发人员如何减少错误呢？</p>

<p>有两个方面的事情可以做：</p>

<p>一是依靠团队和合理的过程，相互检查排错。比如结对编程、codereview、代码静态扫描、各种评审会议等等，都是属于这类。</p>

<p>另一个方面，是构建并依靠合理的系统结构。合理的系统结构一来可以分割复杂度，使开发人员面临相对简单的工作，减小错误发生的概率；二来即使错误发生，可以将错误的影响面限制在组件内部，减小全局影响。</p>

<p>可以说前一方面偏于对症治疗，而第二方面偏于对因治疗。对因治疗当然更利于根本性地杜绝错误，但很多时候对症治疗更加直接有效，同时为对因治疗赢得时间和资源。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>这里说的“开发质量问题”，指的是由于局部错误造成的系统问题。特别是那些由开发人员个人错误造成的问题。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[领域对象的没落？]]></title>
    <link href="http://www.nietongxue.xyz/blog/2016/01/19/do-die/"/>
    <updated>2016-01-19T09:21:19+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2016/01/19/do-die</id>
    
    <category term="/架构"/>
    
    <content type="html"><![CDATA[<p>最近，网红架构师学镛老师提出了观点，说用对象模型来体现领域已不太适用于现代系统环境，比如分布式和高并发。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<!--more-->


<p>我是同意这个观点的。</p>

<p>我认为究其原因，主要是因为目前的服务<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>提供方式。不是以对象为单位包装为服务。由于性能、容错、可伸缩、可扩展等质量要求，人们常使用分布式和松耦合的接口，比如REST风格的HTTP接口、Reactive风格的消息接口。而曾经流行的对象风格的接口，比如EJB，由于不适应这些现代质量要求，已经逐渐淡出了视线。</p>

<p>如果服务不以对象的方式提供，则领域对象无法直接映射为服务。那么领域对象的意义就局限到服务内部。而在更重要的、有全局意义的服务设计和跨服务过程设计中，就不再有使用领域对象的理由。</p>

<p>体现在实践中，领域过程仍然是最重要的知识，只是现在更多的领域过程被分解为子过程的调用和信息的流动，而不是对象和对象间的协作。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>原话在<a href="http://weibo.com/rebol">这里</a>。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>这里通篇使用的是“服务”这个词语，但指的是广义的可重用组件。<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在发展中团队：微服务？]]></title>
    <link href="http://www.nietongxue.xyz/blog/2016/01/05/dev-micro/"/>
    <updated>2016-01-05T10:08:59+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2016/01/05/dev-micro</id>
    
    <category term="/架构"/>
    
    <category term="/微服务"/>
    
    <content type="html"><![CDATA[<p>当系统成长的时候，大家都想到“微服务”。</p>

<!--more-->


<p>微服务太火，好像成了理所当然。但应该考虑微服务是否适于这个团队。</p>

<p>对于微服务本身，正反两方驱动力讲得比较多了<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。</p>

<p>而微服务落实到团队，需要考虑更多：文化需要推广？团队需要重组？技能需要学习？过程可能调整？平台需要验证？……</p>

<p>对照团队现状和发展步调，我们必须知道能得到什么，又需要付出什么。</p>

<p>想要提高可用性？可能只需要多份部署。</p>

<p>想要改善逻辑结构？可能只需要开发时模块化。</p>

<p>想要错误隔离？可能只需要分布式。</p>

<p>想要解耦和可重用化？可能只需要服务化。</p>

<p>……</p>

<p>微服务是一套工具，而不是一件。团队可以做出裁剪，也可以做出渐进策略。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p><a href="http://www.nietongxue.xyz/blog/2015/12/01/micro/">微服务的“微”</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在发展中团队：领域管理]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/12/31/developing-domain/"/>
    <updated>2015-12-31T09:54:24+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/12/31/developing-domain</id>
    
    <category term="/架构"/>
    
    <category term="/过程"/>
    
    <content type="html"><![CDATA[<p>度过初创期，业务复杂性明显发展，系统结构和质量越来越受到重视。</p>

<p>需要考虑如何管理领域<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。</p>

<!--more-->


<h3>什么是领域？</h3>

<p>领域是业务概念和他们之间的关系与协作。系统的目的就是实现这些概念和协作。</p>

<h3>领域有什么用？</h3>

<ol>
<li>领域决定系统的业务特征。领域的现状就是系统的业务现状，领域的历史就是系统的业务历史。或者说，领域体现了业务与系统特征间的因果关系。</li>
<li>领域是通用语言。在产品团队与开发团队间，各产品线之间，各开发团队之间或者开发团队内部。领域是沟通的语言，也是发布和积累的语言，是协作的首要工具。</li>
<li>领域是系统结构的依据。以领域驱动设计<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>是应对系统复杂性的常见手段。领域的结构深刻影响系统结构。</li>
</ol>


<p>这些用途决定了对领域管理的要求，比如：容易阅读，容易查找，容易控制，容易共享，容易跟踪变化。</p>

<h3>如何管理领域？</h3>

<ol>
<li>从静态、动态两个角度描述领域。静态体现领域实体和他们的关系，动态体现领域实体的行为和协作。可以借用UML类图和序列图的形式<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>，也可以使用伪代码。</li>
<li>形式化、结构化的描述体系。形式化的语言去除二义性，知识在各团队各角色之间不会产生歧义。结构化的语言体现层次，不同角色可以关注不同层面。 这一点上，UML相关约定完全够用。如果结合文件系统的树形结构，可以实现足够丰富的层次。</li>
<li>使用git或其他SVC。便于共享和跟踪变化。这要求使用尽量简单的描述语言。在这里，一般的UML图不太理想，人类无法阅读UML图的diff。同样的，各种其他图、doc文档之类也不理想。可以借用马丁大叔UmlAsSketch<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>的想法，使用纯文本形式的UML。</li>
<li>使用中文。英文翻译是引入歧义的重要途径，在尽量少的地方使用英文，而不是相反。</li>
<li>与开发共享周期。领域变化的步调一般与系统的设计开发一致，可以借用设计开发的版本和迭代周期。</li>
</ol>


<p>另外，一些可能的问题——</p>

<p>Q：领域是需求么？<br/>
A：对于开发团队来说，可以说领域来源于需求。区别是：</p>

<ol>
<li>需求从产品和用户的角度，以交互驱动；领域从设计和开发的角度，以结构和逻辑驱动。</li>
<li>需求是增量，领域是全量。需求描述的是每次改动，一般以版本、迭代作为组织单位。如果想从需求知道系统体现业务现状，就必须将历史中所有相关需求找出来进行归纳，这无疑非常困难。而领域持续维护，随时体现当前现状。</li>
<li>需求关心局部，领域关心全局。需求强调体验，往往专注于局部，以一个场景一次交互为单位进行描述。而领域强调整体，需要负责跨产品线跨系统保持一致性。</li>
<li>需求包括功能、质量、约束，领域只涉及到功能。</li>
</ol>


<p>Q：领域是设计（类图、ER图……）么？<br/>
A：领域是设计的依据（之一）。设计的目的是实现领域，但设计需要同时考虑其他架构策略，比如由质量要求引发的技术方案。如图：</p>

<p><img src="http://www.nietongxue.xyz/images/dev/domain.png" width="550"></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>本文中的“领域”都是指“领域模型”或者其他形式的领域知识，而不是领域本身。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>此处的“以领域驱动设计”不完全等于DDD。<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>是不是任何事物都可以从静态和动态两角度描述，进而都使用类图和序列图？<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p><a href="http://martinfowler.com/bliki/UmlAsSketch.html">UmlAsSketch</a><a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实现质量要求的三个考虑方向]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/12/24/3direct/"/>
    <updated>2015-12-24T13:25:20+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/12/24/3direct</id>
    
    <category term="/架构"/>
    
    <category term="/质量"/>
    
    <content type="html"><![CDATA[<p>性能、可用性、可伸缩、可扩展……如何达成这些质量要求，是随时要考虑的问题。
有没有什么“普遍的”考虑方法呢？</p>

<!--more-->


<p>对各个质量要求，具体的考虑方法是各不相同的，但总结起来思考方向一般有几个：<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>.</p>

<h3>正向</h3>

<p>顺着问题发生的因果方向考虑。</p>

<p>列出可能导致问题发生的因素，建立问题场景的模型，研究因素与结果的关系，按优先级评估和排除这些因素。比如对于性能质量风险：对典型请求建模，列出处理请求的步骤，考察它们可能对总体性能的影响，排除可能的瓶颈。</p>

<h3>反向</h3>

<p>将因果关系反过来。</p>

<p>我们从结果出发，基于问题已经发生。考虑如何才能回溯问题的原因并排除。还以性能为例。如果发现系统响应缓慢，我们可以有些什么手段找到缓慢环节，证实它是缓慢的根源？从这个方向考虑，通常会发现要求系统中有足够多的诊断支持，比如日志、现场收集保护、快照分析等等。</p>

<p>值得提醒的是，问题发生有至少两个场景，都是可以利用的：</p>

<ol>
<li>测试，制造问题的发生。</li>
<li>生产中发现已发生的问题。<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></li>
</ol>


<h3>横向</h3>

<p>或者说无向。指的是不按因果方向考虑。比如使用“模式”——根据系统特点，列出可能提高性能的模式，看看成本，能用上的都用上吧。这种方法也确实有用。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>本文以性能为例，但方法可以推广到其他质量要求。好吧，貌似也可以推广到其他任何事。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>当然先要救命和减少问题影响。但不属于本文的范围。<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[“Reactive宣言里为什么有个消息驱动？”]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/12/23/md/"/>
    <updated>2015-12-23T16:31:35+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/12/23/md</id>
    
    <category term="/架构"/>
    
    <content type="html"><![CDATA[<p>宣言的其他方面描述的都是系统的外部特征：快速响应、容错、压力下的弹性。为什么单单加入“消息驱动”这个实现策略呢？</p>

<!--more-->


<p>外部特征被纳入一个“宣言”容易理解，是作为一种承诺和目标。实现策略为何要被纳入一个宣言？毕竟，如果我的系统能实现被期待的外部特征，谁在乎是什么东西驱动的呢？消息驱动？神经驱动？意念驱动？随便啊。</p>

<p>表面看来确实如此。</p>

<p>答案在于，消息驱动在这里并不仅是一个实现策略。宣言中提到的“系统”是多层的，包括大大小小各层级的系统，其中大系统往往由小系统组成。当诸多小系统组成大系统的时候，大系统的实现策略就成了对小系统的外部特征要求。小系统之间的交互，要遵循的就是消息驱动这个一致约定，这对与小系统来说是外部特征，而不是实现策略。</p>

<p>所以消息驱动这个要点，在Reactive的系统生态中，是相互间既能松散自治又能协同合作的重要保证。虽然对系统的最终用户可能没有重要意义，但却是开发者之间的重要承诺和共同目标。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微服务的微]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/12/01/micro/"/>
    <updated>2015-12-01T15:16:01+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/12/01/micro</id>
    
    <category term="/架构"/>
    
    <category term="/微服务"/>
    
    <content type="html"><![CDATA[<p>微服务的微，是指服务粒度的微么？</p>

<!--more-->


<p>微服务可能是由此得名的。但在微服务架构思想中，服务粒度的微，不应该放在首要强调的位置。</p>

<p>微服务架构的思想中，服务的粒度是能找到明确依据的。它由正反两个方向的力相互平衡决定。</p>

<p>驱动服务分割变小的正向力是解耦带来的收益。这个可以从几个方面考察——业务、团队、技术栈、运行时。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<p>反向力是服务分割变小后带来的问题，目前看来最难解决的是性能和数据一致性。服务的粒度越小，需要协作的服务数量越多，性能和一致性方面的影响就越大。</p>

<p>对于这两个力的平衡，不同的业务，不同的团队，不同的进化方向等等，多种因素决定了结果并不相同。正向力大一些，服务的粒度就小一些，服务就微一些，否则，服务就没那么微。</p>

<p>这样一来，服务是不是微、有多微，并不由微服务架构思想本身决定。甚至一种可能的合理结果是：运用微服务的思想分析之后，却发现使用单体架构更为合理。</p>

<p>所以，微服务的微，并不强调服务粒度的微。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>前面有详细讨论，参见<a href="http://www.nietongxue.xyz/blog/2015/06/28/monolithf/">《单体优先还是微服务？》</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Orchestration 和 Choreography]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/11/29/oc/"/>
    <updated>2015-11-29T15:01:02+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/11/29/oc</id>
    
    <category term="/架构"/>
    
    <category term="/微服务"/>
    
    <content type="html"><![CDATA[<p>Orchestration 和 Choreography，这个两个词在跟“服务”有关的架构讨论中常有出现。比如微服务和SOA。</p>

<!--more-->


<p>如果直译的话，这两个词一个是“编曲”，一个“编舞”。</p>

<p>编曲和编舞都是编。编就是安排、设计。不论是微服务的服务还是SOA的服务，要想沟通协同，合力完成业务请求，都是需要安排设计的。</p>

<p>但二者编排的对象不同，一个是曲一个是舞。特别是，按照词的本意，这里的“曲”指的是“管弦乐曲”，是相对复杂宏大的演奏。</p>

<p>曲和舞有什么区别呢？</p>

<ol>
<li>曲需要指挥，舞不需要。乐者在演奏时，需要指挥随时指挥协调。而舞者则不需要，按照事前安排做好自己就行。需要跟其他舞者合作时，也由自己直接沟通完成。</li>
<li>曲分工复杂，舞比较简单。管弦乐曲演奏需要多种不同乐器多种不同乐者，要求彼此配合得当，才能演出成功。而舞蹈没那么多分工，即使是大型舞蹈，台上人多，但角色也就数种而已。</li>
<li>曲比较严肃，舞比较宽松。乐者的演奏和配合一丝不苟，少有随性。舞者则有较多的个人发挥空间。</li>
</ol>


<p>SOA的理念是自上而下，比较多的依赖于集中安排，运行时也需要明确的中间件进行中央控制协调。边界内有多种类型的服务，相互之间严密配合。SOA的风格类似于编曲。</p>

<p>跟SOA相比，微服务风格更类似于编舞。边界内的服务遵循简单的约定，负责一个特定的领域。他们的地位相似，实现方式和沟通方式由自己选择。</p>

<p>编曲和编舞是一种形象的比喻，并不会完全精确。架构师编排服务的时候不要照抄。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[系统要像什么？]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/11/20/system-like/"/>
    <updated>2015-11-20T10:39:55+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/11/20/system-like</id>
    
    <category term="/架构"/>
    
    <content type="html"><![CDATA[<p>系统不要像一座建筑或一台机器。</p>

<!--more-->


<p>要想办法让系统像一个生物，如能更进一步，要像一个社会。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读TOGAF（二）：ADM初瞥]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/11/17/togaf-adm/"/>
    <updated>2015-11-17T00:05:18+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/11/17/togaf-adm</id>
    
    <category term="/架构"/>
    
    <category term="/togaf"/>
    
    <content type="html"><![CDATA[<!--more-->


<ul>
<li>ADM建议一系列的阶段和步骤。但不建议范围<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。</li>
<li>ADM是渐进迭代的。每次迭代有自己的范围，渐进产出。</li>
<li>ADM是可以调整包括裁剪的。但调整必须管理并维持。</li>
<li>ADM通过架构仓库参与到企业火锅<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。</li>
</ul>

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>架构范围包括：宽度、深度、时间范围、架构领域。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p><a href="http://www.nietongxue.xyz/blog/2015/11/07/togaf/">企业火锅</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读TOGAF（一）：企业大火锅]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/11/07/togaf/"/>
    <updated>2015-11-07T00:05:18+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/11/07/togaf</id>
    
    <category term="/架构"/>
    
    <category term="/togaf"/>
    
    <content type="html"><![CDATA[<p>Enterprise Continuum， 我称作企业大火锅。</p>

<!--more-->


<p>热气腾腾地沸着。各种物料在里面翻滚，碰撞，成熟，积累。</p>

<p>食客不用看见那么多，眼中只有这一刻的这一坨，先捞去也……</p>

<p><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<p><img src="http://www.nietongxue.xyz/images/togaf/hot.jpg" width="500"></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>比喻有风险。如有跑偏，概不负责。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[架构设计过程的驱动技术（二）]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/10/28/driving2/"/>
    <updated>2015-10-28T09:06:49+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/10/28/driving2</id>
    
    <category term="/架构"/>
    
    <category term="/过程"/>
    
    <content type="html"><![CDATA[<p>模式驱动不是一种顶层的驱动技术。因为架构模式本身，严格来讲并不是对目标系统本身的分解（而特征和风险则是）。<!--more-->如果说得完整一点，应该是：“为了实现xx特征（或者控制xx风险），我们应用xx模式。”。所以模式驱动其实是在特征驱动或风险驱动之后接着应用的驱动技术。但实际很多情况下，团队只要稍微知道要设计的系统的类型，脑中已经冒出了许多模式，后续也是依据这些模式的应用来跟进，可以说淡化了原有的顶层驱动技术。</p>

<p>由于不是顶层驱动技术，模式驱动很难验证最终解决了问题，比如不能说：“由于我们使用了xx、yy、zz模式，所以我们能完成XX系统。”反过来，对于顶层的驱动技术，就可以说：“由于我们实现了所有典型的特征，所以我们能实现XX系统”，或者，“由于我们遏制了所有（发现了的）风险，所有我们能完成XX系统”。所以如果使用模式驱动，应该要回过头来，借助顶层驱动技术来验证问题的解决。从这个意义上来讲，可以说模式驱动是被顶层驱动嵌套使用的。</p>

<p>特征驱动和风险驱动分解问题时，也会频繁使用模式思维，但这不是模式驱动。比如说特征驱动，整理系统的质量需求的时候，我们常常使用一个“质量需求检查表”。其中列举了特定类型系统常见的质量需求。我们对此一一检视，判别目标系统是否有此需求。这是典型的模式思维。但这里的模式不是架构设计模式，这里也不是将目标系统分解为模式进行跟进。所以不是模式驱动的架构设计。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[方法论]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/10/26/method/"/>
    <updated>2015-10-26T21:24:20+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/10/26/method</id>
    
    <category term="/架构"/>
    
    <category term="/过程"/>
    
    <content type="html"><![CDATA[<p>方法论是路线图，不是轨道。</p>

<!--more-->


<p>想要像火车司机那样一趟又一趟，恐怕不能如愿。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[“架构是进化来的，不是设计来的。”]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/10/24/evolve/"/>
    <updated>2015-10-24T17:21:53+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/10/24/evolve</id>
    
    <category term="/架构"/>
    
    <content type="html"><![CDATA[<p>当然。</p>

<!--more-->


<p>但是，每一步的进化都是设计来的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[架构设计过程的驱动技术（一）]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/10/09/driving/"/>
    <updated>2015-10-09T21:31:05+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/10/09/driving</id>
    
    <category term="/架构"/>
    
    <category term="/过程"/>
    
    <content type="html"><![CDATA[<p>驱动技术是方法论的第一步，是对目标问题进行分割，并分别进行管理跟进的技术。</p>

<p>我们常说“这个问题从何处着手呢？”——驱动技术要做的就是：找到从何着手，跟进着手过程，评估着手效果，归纳着手结论。</p>

<!--more-->


<p>具体到架构设计方法论，驱动技术要解决的就是：</p>

<ol>
<li>如何将目标系统<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>分解为可以应对的问题。</li>
<li>如何跟进应对这些问题的过程。</li>
<li>如何评价问题被应对的程度。</li>
<li>如何归纳所有应对结果并形成架构设计。</li>
</ol>


<p>其中第一条，是区别各驱动技术的要点。也是理解和选择各驱动技术的要点。分解依据不同，跟进、评价、归纳等机制也相应不同。</p>

<p>从这个角度看，架构设计中常见的驱动技术有：</p>

<ol>
<li><p>特征驱动，或者叫需求驱动。分解依据是目标系统的特征。特征驱动是收集筛选系统的特征，并跟进特征的实现措施的驱动技术。经典的架构设计方法论多采用这种驱动技术。</p></li>
<li><p>风险驱动。分解依据是目标系统生命周期中蕴藏的风险。风险驱动是发现生命周期中的风险，并跟进风险的控制措施的驱动技术。风险驱动是“不完备架构设计方法”的主要驱动技术。作为本人团队最常用的驱动技术，前期博客已经做了阐述<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。</p></li>
<li><p>模式驱动。分解依据是团队积累的架构模式（也包括反模式）。模式驱动是筛选适用的模式，并跟进模式的应用措施的驱动技术。</p></li>
<li><p>直觉驱动。或者说不使用任何驱动技术。当团队处于非常熟悉的领域、平台、技术栈的时候，直觉驱动确实存在。这种情况下架构设计基本已不需要“过程”来管控。不需要过程管控的架构设计是否合理，团队中意见并不一致，个人认为要慎重<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>。</p></li>
</ol>


<p>（<a href="http://www.nietongxue.xyz/blog/2015/10/28/driving2/">后一篇</a>）</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>本篇中以新系统架构设计为例，但所谈适合其他架构设计，比如架构重整改进、仅设计一个模块等。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p><a href="http://www.nietongxue.xyz/blog/filter/filter.html?filterName=series&amp;filterValue=%E6%95%8F%E6%8D%B7%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1&amp;filterDes=Series%3A%20%E6%95%8F%E6%8D%B7%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1">系列：敏捷的架构设计</a><br/><a href="http://www.nietongxue.xyz/blog/2015/08/13/scenario/">以场景思维辅助风险驱动架构设计</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p><a href="http://www.nietongxue.xyz/blog/2015/10/04/process/">架构设计不能忽视过程产出</a><a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[架构设计不能忽视过程产出]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/10/04/process/"/>
    <updated>2015-10-04T10:25:03+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/10/04/process</id>
    
    <category term="/架构"/>
    
    <category term="/过程"/>
    
    <content type="html"><![CDATA[<p>跟开发过程中其他环节相比，架构设计往往更加依赖于架构师个人的经验和决定。
有些架构师和团队对架构设计过程比较随意。
我们常看到的介绍架构设计的文章，也多侧重于介绍设计结论。这些都似乎使得架构设计倾向强调最终结论，不太重视中间过程和过程产出。</p>

<p>最终结论固然是重要的，但过程产出也有重要意义。从几个方面来看：</p>

<!--more-->


<ol>
<li>架构设计需要迭代和回朔。在架构设计和执行的整个过程中，往往需要反复迭代，逐次逼近理想结论。期间有很多的回溯反复过程。如果没有必要的过程产出，很难有效地进行这种迭代。</li>
<li>架构设计需要沟通和协作。架构设计作为开发工作的一个环节，与其他环节有许多沟通协作。特别是，实现环节将直接使用架构设计结论。这些沟通协作要求交付物<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 有说服力，合作团队希望接受包括来龙去脉和前因后果的设计产出，而不仅仅是一个最终结论。过程产出能支持设计结论，提供说服力。</li>
<li>架构设计需要积累和分享讨论。架构设计结论作为组织内的高价值知识，需要有效地积累和分享讨论。这同样要求设计结论有系统性、有说服力，需要有过程产出。</li>
</ol>

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>交付物，不一定是书面交付物。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[技术栈是架构设计的目的么？]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/10/02/techstack/"/>
    <updated>2015-10-02T22:46:38+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/10/02/techstack</id>
    
    <category term="/架构"/>
    
    <content type="html"><![CDATA[<p>不是。</p>

<p>相比于架构设计的目的，技术栈更像是架构执行的手段。</p>

<p>“为了实现那样的架构设计，我们将使用这些的技术。……”</p>

<!--more-->


<p>既然架构设计和执行是连贯不分的一个整体，那么区分前者的输出和后置的输入有什么意义呢？我认为是有意义的。这是孰本孰末，孰因孰果的问题。试想这样的情况：架构执行过程中，如果发现栈中某技术不适用，是否可以更改？如果是执行的手段，我们可以便宜更改，只要不偏离设计结论；如果是设计的目的，我们不能随意更改，因为要改结论需要从论点、论据、论证一一检视更改。</p>

<p> <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>另一个角度说来，技术栈也确实常作为架构设计的重要产出物，体现着设计结论的一些方面。所以类似“XX技术在XX公司的应用”这样的句型，作为架构分享文章的标题经常出现。读到这样的文章，希望同学们以正确的姿势打开，从技术栈的展示中，窥见架构设计的来龙去脉。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
