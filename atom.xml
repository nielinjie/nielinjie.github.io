<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[聂同学]]></title>
  <link href="http://nielinjie.github.io/atom.xml" rel="self"/>
  <link href="http://nielinjie.github.io/"/>
  <updated>2014-03-31T23:09:45+08:00</updated>
  <id>http://nielinjie.github.io/</id>
  <author>
    <name><![CDATA[nielinjie]]></name>
    <email><![CDATA[nielinjie@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[敏捷的架构设计（二）：风险驱动]]></title>
    <link href="http://nielinjie.github.io/blog/2014/03/31/aa1/"/>
    <updated>2014-03-31T21:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/03/31/aa1</id>
    <content type="html"><![CDATA[<blockquote><p>敏捷已死，而敏捷性长存。</p></blockquote>

<p>何为风险驱动的架构设计？
该方法认为：</p>

<ul>
<li>架构设计的（唯一）目的是应对工程风险。</li>
<li>当且仅当有风险被识别的时候需要考虑是否进行相应的架构设计。</li>
<li>架构设计采用的技术和投入的资源要与对应风险种类和程度相适应。</li>
<li>风险本身或\和对风险的认识会发生改变，相应的架构设计活动也会改变，架构设计结果也会改变。</li>
<li>风险驱动架构设计方法适合敏捷开发过程。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[敏捷的架构设计（一）：自问自答]]></title>
    <link href="http://nielinjie.github.io/blog/2014/03/31/aa/"/>
    <updated>2014-03-31T21:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/03/31/aa</id>
    <content type="html"><![CDATA[<blockquote><p>敏捷已死，而敏捷性长存。</p></blockquote>

<p>Q：敏捷开发过程貌似不需要架构设计，不需要架构师角色？<br/>
A：任何开发过程是否需要架构设计，不是由采用什么过程决定的，而是由需要完成的开发任务决定的。
如果开发的系统/软件有架构问题需要解决，不论采用何种开发过程、是否采用敏捷过程，都需要架构设计。
如果需要架构设计，而开发团队不确定有能力进行架构设计，那么团队就需要架构师介入/加入。</p>

<!-- more -->


<p>Q：敏捷过程对架构设计有没有什么特殊要求？<br/>
A：是否需要架构设计并不是由是否敏捷过程决定。但敏捷过程的特点，对架构设计活动有一些要求。<br/>
传统开发过程中，架构设计一般采用“集中式”架构设计方法，即在开发过程的某个阶段，集中完成所有的架构设计。<br/>
这种安排有一个先决条件，就是需求也必须集中完成。架构设计的依据是需求，如果需求不能在架构设计活动之前完成，架构设计就没有依据。
然而敏捷过程没有集中完毕的需求，只有“演进式”需求，需求是逐渐挖掘和显现的。这时的架构设计只能放弃“集中式”，同样也采用“演进式”。</p>

<p>Q：如何处理架构“演进”带来的“额外”成本和风险？<br/>
A：必须就事论事，没有统一答案。有些架构决策，可以尽量前置；有些架构决策，只能随需求逐渐明朗；有些架构决策，需要随时回顾改进。
架构设计不再是一个阶段性大任务，而需要划分成多个任务，按不同情况分别管理跟进。</p>

<p>Q：如何判断何时开始、何时完成、何种程度、哪一部分的架构设计？<br/>
A：“风险驱动架构设计”方法……</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[语录：雪人（三）]]></title>
    <link href="http://nielinjie.github.io/blog/2014/03/30/said-xueren3/"/>
    <updated>2014-03-30T15:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/03/30/said-xueren3</id>
    <content type="html"><![CDATA[<p>雪人项目进行得还算顺利。然而你发现兄弟们有些异样，他们常常盯着雪人的肚皮部位自说自话，这两天甚至开始聚在一起窃窃私语。
这些人都是多啦A梦设计风格的铁根粉丝啊，你能感受到设计一个口袋对他们来说是非常巨大的诱惑。
你曾经反复解释口袋有多危险，明令禁止任何设计口袋的企图。然而你知道这些根本无法打消你的担忧：架构走形的风险正如影随形。</p>

<p>这时候你忽然灵光一现，你埋头迅速制造了一个口袋，不是华丽的、未知的、危险的口袋，而是一个简单、简陋、安全、甚至没完全完成的口袋。“啪”，你把口袋拍在雪人肚子上。
你感到世界清净下来。你安心地微笑，脑中浮现一个模糊的词语，叫做：“提升架构的设计”。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[博客搬家了]]></title>
    <link href="http://nielinjie.github.io/blog/2014/03/22/new-blog-site/"/>
    <updated>2014-03-22T20:15:27+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/03/22/new-blog-site</id>
    <content type="html"><![CDATA[<p>看到了芝明同学的博客以及引擎octopress, 感觉漂亮又方便，于是把博客搬家了。</p>

<!-- more -->


<p>感谢octopress, 感谢芝明同学（<a href="http://zhaozhiming.github.io">http://zhaozhiming.github.io</a> ），感谢github。听说github正在遭受ddos攻击，祝好运。</p>

<p>期间只遇到一个编码问题，如下。感谢这位同学的博客，问题很快解决了。
<a href="http://fedcuit.github.io/blog/2012/08/02/config-octopress-on-mac/">http://fedcuit.github.io/blog/2012/08/02/config-octopress-on-mac/</a>
 见文章中的最后一个问题：YAML Exception</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>➜  octopress git:(source) ✗ rake generate
</span><span class='line'>## Generating Site with Jekyll
</span><span class='line'>identical source/stylesheets/screen.css
</span><span class='line'>Configuration from /Users/nielinjie/Projects/octopress/_config.yml
</span><span class='line'>Building site: source -&gt; public
</span><span class='line'>YAML Exception reading 2014-03-22-new-blog-site.markdown: invalid byte sequence in US-ASCII
</span><span class='line'>/Users/nielinjie/Projects/octopress/plugins/backtick_code_block.rb:13:in `gsub': invalid byte sequence in US-ASCII (ArgumentError)
</span><span class='line'>  from /Users/nielinjie/Projects/octopress/plugins/backtick_code_block.rb:13:in `render_code_block'
</span><span class='line'>  from /Users/nielinjie/Projects/octopress/plugins/octopress_filters.rb:12:in `pre_filter'
</span><span class='line'>  from /Users/nielinjie/Projects/octopress/plugins/octopress_filters.rb:28:in `pre_render'
</span><span class='line'>  from /Users/nielinjie/Projects/octopress/plugins/post_filters.rb:112:in `block in pre_render'
</span><span class='line'>  from /Users/nielinjie/Projects/octopress/plugins/post_filters.rb:111:in `each'
</span><span class='line'>  from /Users/nielinjie/Projects/octopress/plugins/post_filters.rb:111:in `pre_render'
</span><span class='line'>  from /Users/nielinjie/Projects/octopress/plugins/post_filters.rb:166:in `do_layout'
</span><span class='line'>  from /Users/nielinjie/.rbenv/versions/1.9.3-p0/lib/ruby/gems/1.9.1/gems/jekyll-0.12.0/lib/jekyll/post.rb:195:in `render'
</span><span class='line'>  from /Users/nielinjie/.rbenv/versions/1.9.3-p0/lib/ruby/gems/1.9.1/gems/jekyll-0.12.0/lib/jekyll/site.rb:200:in `block in render'
</span><span class='line'>  from /Users/nielinjie/.rbenv/versions/1.9.3-p0/lib/ruby/gems/1.9.1/gems/jekyll-0.12.0/lib/jekyll/site.rb:199:in `each'
</span><span class='line'>  from /Users/nielinjie/.rbenv/versions/1.9.3-p0/lib/ruby/gems/1.9.1/gems/jekyll-0.12.0/lib/jekyll/site.rb:199:in `render'
</span><span class='line'>  from /Users/nielinjie/.rbenv/versions/1.9.3-p0/lib/ruby/gems/1.9.1/gems/jekyll-0.12.0/lib/jekyll/site.rb:41:in `process'
</span><span class='line'>  from /Users/nielinjie/.rbenv/versions/1.9.3-p0/lib/ruby/gems/1.9.1/gems/jekyll-0.12.0/bin/jekyll:264:in `&lt;top (required)&gt;'
</span><span class='line'>  from /Users/nielinjie/.rbenv/versions/1.9.3-p0/bin/jekyll:23:in `load'
</span><span class='line'>  from /Users/nielinjie/.rbenv/versions/1.9.3-p0/bin/jekyll:23:in `&lt;main&gt;'</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[语录：好的架构师]]></title>
    <link href="http://nielinjie.github.io/blog/2014/03/09/said-jiagoushi/"/>
    <updated>2014-03-09T21:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/03/09/said-jiagoushi</id>
    <content type="html"><![CDATA[<p>好的架构师说：好吧，重做是架构进化的一种形式，我们下一个架构将解决这些问题；脾气好的架构师说：好吧，你是老板，你说重做我们就重做；2b架构师说：重做？mb你是老板你了不起么？老子的架构不够nb么？老子的xxx风格yyy模式你sb懂得起么？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[语录：乌鸦]]></title>
    <link href="http://nielinjie.github.io/blog/2014/03/03/said-yuya/"/>
    <updated>2014-03-03T21:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/03/03/said-yuya</id>
    <content type="html"><![CDATA[<p>一只乌鸦口渴了……，可是他早上买的酸奶没拿吸管，他的勺子比瓶子口大……，这时候一只老乌鸦走过来，分享了他处理类似问题的经验，并声称已经已经被广为使用和验证。
乌鸦感到庆幸，立即找来了很多石子儿……，直到他认识到他要对付的是酸奶，而不是清水。</p>

<p>乌鸦看着表面上堆着石子儿的酸奶，反思并明白了：模式的应用条件，是模式的重要一部分。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[语录：手段和目的]]></title>
    <link href="http://nielinjie.github.io/blog/2014/02/15/said-shouduan/"/>
    <updated>2014-02-15T21:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/02/15/said-shouduan</id>
    <content type="html"><![CDATA[<p>“通用”是手段而不是目的，“简单”也一样，甚而“结构”也一样。感受下呢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[语录：雪人（二）]]></title>
    <link href="http://nielinjie.github.io/blog/2014/02/15/said-xueren2/"/>
    <updated>2014-02-15T15:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/02/15/said-xueren2</id>
    <content type="html"><![CDATA[<p>这时候走来一个大叔，他对多啦A梦风格的了解人所共知。他警告说多啦A梦的口袋充满了未知，非常危险。于是你谨慎地决定：多啦A梦风格的设计必须局限在雪人的手部。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[语录：雪人（一）]]></title>
    <link href="http://nielinjie.github.io/blog/2014/02/15/said-xueren1/"/>
    <updated>2014-02-15T15:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/02/15/said-xueren1</id>
    <content type="html"><![CDATA[<p>你正在堆一个雪人，突然觉得万一它活过来了，跑来掐你脖子可怎么办？于是你把雪人的手改成了多啦A梦风格。恭喜你，你掌握了风险驱动的架构设计方法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一场似非而是的DSL（后传）]]></title>
    <link href="http://nielinjie.github.io/blog/2013/09/02/dsl-post/"/>
    <updated>2013-09-02T21:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2013/09/02/dsl-post</id>
    <content type="html"><![CDATA[<p>这是后传，不是正传，主要写设计结果和实现的一些细节，不喜请无视。</p>

<!-- more -->


<p>DSL的一个片段如最后的代码所示，基本上满足了我们的要求——</p>

<ul>
<li>片段完整地描述了一个特征，包括扩展点、扩展等等各方面的信息。实例中，<code>dynamicProperty</code>、<code>show</code>、<code>mail</code>是三个不同的扩展点，大括号里面的内容是当某个业务差异时填入扩展点的具体扩展逻辑。而这个业务差异，由<code>condition</code>描述。</li>
<li>不存在片段中和片段间来回引用穿梭等影响阅读完整性的问题。</li>
<li>不同方面的内容描述形式一致。比如动态属性dynamicProperty和邮件策略mail是不同的特征，背后的业务知识是很不同的，但这里体现为统一的描述形式。</li>
<li>聚焦于业务概念，噪音很少。这个片段看上去，除了表示范围的大小括号外，基本上全部是业务概念。</li>
</ul>


<p>讲一些实现细节——</p>

<ul>
<li>DSL的实现基于Groovy的<code>ObjectGraphBuilder</code>。</li>
<li>示例代码中的<code>dsl</code>就是<code>ObjectGraphBuilder</code>的一个实例，<code>requirement</code>构建顶层的bean。</li>
<li>类似于<code>requirement{}</code>以及内嵌的<code>dynamicProperty{…}</code>都是一些普通的groovy方法调用，通过groovy的动态调用机制赋予这次调用一些逻辑，以<code>dynamictProperty</code>为例：

<ul>
<li>实例化一个类，根据方法名计算这个类的类名。这个例子里就是类<code>DynamicProperty</code>。</li>
<li>将这个实例set到上级bean的适当属性上，这个属性也是根据方法的名字计算得到的。这个例子就是属性<code>dynamicProperty</code>。</li>
</ul>
</li>
<li>上述的根据方法名计算类名和属性的办法是<code>ObjectGraphBuilder</code>原生的，比较简陋，需要做一些定制，<code>ObjectGraphBuilder</code>提供了定制的接口，分别是<code>ClassNameResolver</code>和<code>RelationNameResolver</code>。我们对简单的计算办法做了补充：

<ul>
<li>类名搜寻策略，原生的计算只有硬匹配，就是只能设置一个包名，每个方法名直接加在包名后面就得出类名。这个策略在我们这里完全行不通，因为我们这里的很多类，不是固定在某个已知的包里面的，比如扩展和扩展点，这些类是具体的，类名来自于具体逻辑所在的包，散布在整个系统。对此我们引入了类名搜索机制，在整个系统的包空间搜索需要的类。另外一方面，我们借助reflection，从上层bean的属性类型，得到需要的类。</li>
<li>属性搜寻策略，在原生的名字匹配的基础上，我们结合类型匹配，也就是根据类名对应策略得到的类名反过来匹配上层bean的属性类型，找到这个属性。比如<code>dynamicProperty</code>这个方法，上层的bean是没有一个叫“dynamicProperty”的属性的，但有个<code>Feature</code>类型的属性。<code>dynamicProperty</code>方法实例化<code>DynamicProperty</code>类，它是<code>Feature</code>的子类，可以匹配。</li>
<li>上述两个搜索策略都考虑了集合属性的情况，名字经过简单地单复数转化，读取类型时通过泛型的集合的参数类型读取。</li>
<li>有一种特殊情况，搜寻类名和搜寻属性的策略会相互影响，我们希望有一种特殊的策略能把两个搜索过程独立开。我们约定一种特殊的方法名字形式：<code>propertya$classb</code>，这样我们根据<code>propertya</code>计算属性，<code>classb</code>计算类名。更特殊的情况比如代码中的<code>$selectorRenderer</code>，只计算类名不计算属性，表示这里只实例化bean，不做上层bean的属性设置。这中特殊策略为DSL的编写带来了方便，但其实不是一种业务策略，在DSL的角度看来其实是一种噪音，我们尽量避免使用。</li>
</ul>
</li>
<li>相关的代码不多，已经放到github，供参考。<a href="https://github.com/nielinjie/dslOGB">https://github.com/nielinjie/dslOGB</a>。其中用于扫描classpath的依赖包<code>com.google.classpath</code>来自于介里：<a href="https://code.google.com/p/classpath-explorer/">https://code.google.com/p/classpath-explorer/</a>。</li>
</ul>


<p>代码：</p>

<pre><code>dsl.requirement{
    name('isStock')
    description('是否关联交易')
    condition(exp:'(owner.sortId==1 || owner.sortId==11 ) &amp;&amp; owner.taskComp.contains("PA002")')
    dynamicProperty{
        name('isStockTrade')
        cName('关联交易')
        type(java.lang.String.class)
        stringValidator()
        stringEditor()
        maxLength(10)
        minLength(1)
        isRequired(true)
        defaultValue(true)
        renderMap(key:'writable',value:$selectorRenderer())
        renderMap(key:'readOnly')
        activeEvent{
            change('var ....')
        }
    }

    show{
        flag(function:'submitTask',flag:'writable')
        flag(function:'approval',flag:'readOnly')
    }

    mail{
        handleMap(key:'New_Submit',value:'mailHandle')
        handleMap(key:'Edit_Submit',value:'mailHandle')
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一场似非而是的DSL（三）]]></title>
    <link href="http://nielinjie.github.io/blog/2013/09/01/dsl3/"/>
    <updated>2013-09-01T21:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2013/09/01/dsl3</id>
    <content type="html"><![CDATA[<p>上回说到，可读和全局，是我们的DSL形式要解决的主要问题。</p>

<!-- more -->


<ul>
<li>全局，要求DSL结构要精练，同时最好是层级结构，避免指针引用。</li>
<li>可读，要求DSL能以一种形式表达各个不同的业务方面，所以这个形式必须相当通用。</li>
</ul>


<p>此时那个最纠结的问题出现了：“相当通用”的DSL是不是D <strong><em>S</em></strong> L？毕竟，“通用”在一端，S在另一端。</p>

<p>幸运的是：我们决定先找到这个DSL再讨论它是不是真正的DSL。</p>

<p>既然需要相当通用，我们决定从通用的配置形式出发，我们的办法是——</p>

<ol>
<li>清理要描述的对象，明确其结构和关系，形成确定的业务模型。在这里就是“特征机制“涉及到的知识层的各个概念，比如特征、扩展点、扩展等。这个工作其实在“特征机制”设计期就已经完成了。</li>
<li>保证知识层业务模型的可读性，在我们Java系统中，就表现为相关的类（特征、扩展点、扩展等，包括抽象的类和具体的类），它们的类名和属性名、关系名都准确精练、可读。</li>
<li><p>然后我们使用一种通用的配置形式将这些类实例化（一些javabean），并关联在一起。这时候发现，我们的DSL，基本上等同于描述Bean图的DSL。</p>

<p> 这种配置方式是很常见的，有很多实现方法：</p>

<ul>
<li>Spring Bean XML：这个形式简单直白，通用性非常强，但过于冗长了些，很难满足全局性要求。噪音很多，很难说可读。</li>
<li>定制namespace的Spring Bean XML和其他简单的XML：粗略一看是个好主意，比上面的办法在体积和噪音两个方面都改善挺多。但仔细看看不对，要保证通用性，这种方法只能退化为前一种。</li>
<li>Json：形式上比较简洁，噪音比较少，基本已经满足要求。只是需要在配置中补充一些类型信息，而且处理这些信息需要自己实现，比较繁琐。</li>
<li>YAML：跟Json相似，类型信息方面实现上简洁些。</li>
<li>Groovy ObjectGraphBuilder：当我们已经开始深入研究YAML的实现细节的时候，回忆到世界上还有这个，各方面都符合要求。</li>
</ul>
</li>
</ol>


<p>至此，我们基本上找到了符合要求的DSL形式，期间也花了很多时间来思考那个纠结的问题：“相当通用”的DSL是不是DSL？现在，我们的回答是：这个DSL就是我们想要的DSL。我们认为——</p>

<ul>
<li>作为一门语言，其通用或者专用，主要是从使用者的视角来衡量，而不是从设计者、实现者的视角。虽然我们用通用的形式设计、用通用的方法实现这个dsl，但使用者撰写、维护时能接触到的，都是专有业务领域的概念，很少有领域之外的噪音。</li>
<li>任何定义，都是为作用服务的。我们选择DSL，是由于它的作用，而不是它的定义。如果一个东西被用作DSL，则它就是DSL。</li>
</ul>


<p>一场似非而是的DSL的故事就是这样，如果有同学对我们这个DSL具体是怎样的有兴趣，可以要求我写故事后传……</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一场似非而是的DSL（二）]]></title>
    <link href="http://nielinjie.github.io/blog/2013/09/01/dsl2/"/>
    <updated>2013-09-01T21:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2013/09/01/dsl2</id>
    <content type="html"><![CDATA[<p>接演前文，我们这个任务是找到描述“特征”这个业务的语言——就是DSL，其实也就是找个合适的形式来写配置。不错，让我们看看如何找这个合适的形式。</p>

<!-- more -->


<p>前文已经说过，对这个DSL的形式，我们有几个要求：</p>

<ul>
<li>全局的：我们希望一个特征的所有内容，能够一次看到。</li>
<li>动态的：可以在系统运行中加入、删除或者修改一个特征。</li>
<li>可读的：我们希望运营人员甚至业务人员可以看懂甚至修改这些特征。</li>
<li>容错的：系统能帮助修改者发现并改正描述中的错位。</li>
</ul>


<p>我们一一来看这些要求：</p>

<ul>
<li>动态的：比较容易做到。我们只要不把配置放在静态的配置文件就可以了。放入数据库，或者可读写的文件系统都可以。主要涉及到DSL的管理、使用问题，与DSL本身的结构没有多大关系。</li>
<li>容错的：稍微难一点。但我们只要对每个DSL段修改后运行一个校验方法，在一个DSL段导入到系统之前，对它进行校验，给出错误信息就可以了。</li>
<li>全局的：更难一点了。回想一下前文介绍的“特征“的定义，它就是DSL要描述的对象。这个对象比较复杂。

<blockquote><p>描述了当何种<strong>业务差异</strong>的情况下，需要在哪些个<strong>扩展点</strong>填入哪些个<strong>扩展</strong>。</p></blockquote>

<p>  一个特征，包括了业务差异、扩展点、扩展，有好几个方面的信息。要把它们放入到同一个DSL片段（比如一个文件或一条数据库记录）中，除了各个方面的体量都不能太大，还得适当地表达出它们之间的联系。如果片段总体体积很大，超出了人们的阅读能力，或者人们阅读的时候，需要跟着很多引用、指针之类的到处跳来跳去，那显然我们的全局性要求就没有达到。</p></li>
<li>可读的：很难。正如前一点要求提到的，我们需要正确地表达出扩展点、扩展这些信息。如果仔细想一下就能意识到，扩展点与扩展点、扩展与扩展，可能是非常不同的。比如有个扩展点，是决定一个文档中有哪些字段的，另有一个扩展点，是决定一个文档在某个状态下可以被采取什么动作的。这些东西风马牛不相及，需要描述的内容非常不同，要如何才能给它们一个统一的描述形式呢？</li>
</ul>


<p>全局和可读，是我们这个DSL设计要重点解决的问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一场似非而是的DSL（一）]]></title>
    <link href="http://nielinjie.github.io/blog/2013/09/01/dsl1/"/>
    <updated>2013-09-01T21:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2013/09/01/dsl1</id>
    <content type="html"><![CDATA[<p>设计这套DSL的过程中，一直纠结的是：这到底是不是真正的DSL？</p>

<!-- more -->


<p>这套DSL，是为公司办公系统的“特征机制”设计的。</p>

<p>所谓“特征”，是对业务差异的一个建模。</p>

<p>我们的办公系统同时为多个不同的业务机构、外部系统、不同的文档类型服务，不同的机构、不同的外部系统、不同的文档类型带来了不同的业务差异逻辑。这些差异化的业务逻辑，带来了系统大部分的复杂性、不稳定性。处理通用逻辑与差异逻辑的关系，成了我们这个系统架构的主要挑战之一。应对的原则很明确，就是将差异逻辑与通用逻辑分开，使其互不影响，分别进化。架构上典型的模式——按通用性分层。</p>

<p>“特征机制”就是我们对这个模式的一个实现，简述一下：</p>

<ul>
<li>我们把系统逻辑中可能发生扩展的点称为<strong>扩展点</strong>。</li>
<li>不同的<strong>业务差异</strong>，通过在扩展点上填入适当的<strong>扩展</strong>来实现专用逻辑。</li>
<li>所谓<strong>特征</strong>，就是一条知识，描述了当在何种<strong>业务差异</strong>的处理中，需要在哪些个扩展点填入哪些个<strong>扩展</strong>。</li>
<li>所谓<strong>特征机制</strong>，就是当系统运行到一个扩展点的时候，查找到正确的特征，填入正确的扩展并运行的机制。</li>
</ul>


<p>容易发现，特征机制要发挥作用，需要有一个机制来描述所有的特征，这就是特征机制的知识层，对这个描述机制要求是：</p>

<ul>
<li><p>全局的：我们希望一个特征的所有内容，能够一次看到。如前所述：</p>

<blockquote><p>一条知识，描述了当何种<strong>业务差异</strong>的情况下，需要在哪些个<strong>扩展点</strong>填入哪些个<strong>扩展</strong>。</p></blockquote></li>
<li>动态的：可以在系统运行中加入、删除或者修改一个<strong>特征</strong>。</li>
<li>可读的：我们希望运营人员甚至业务人员可以看懂并修改这些<strong>特征</strong>。</li>
<li>容错的：系统能帮助修改者发现并改正描述中的错误。</li>
</ul>


<p>这些要求并不容易，幸好我们设计这个机制的时候已经将知识层与操作层分离，可以分别进化。先做好操作层，保证机制可以运行，后续再逐渐改善简陋的知识层。目前的知识层，是spring bean配置文件，整个特征机制可以运行，但上述的描述机制要求一条也没有达到。</p>

<p>于是便有了这一场DSL。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[能不能建立去中心化的言论机制？]]></title>
    <link href="http://nielinjie.github.io/blog/2013/08/20/distribute-saying/"/>
    <updated>2013-08-20T21:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2013/08/20/distribute-saying</id>
    <content type="html"><![CDATA[<p>在《知乎》问的这个问题，不知道有没有人一起来讨论。</p>

<!-- more -->


<h2>有没有办法？</h2>

<ul>
<li>去中心化后人们如何建立联系？- 通过利用现有的网络资源，建立分散式的存储和通信。比如用户端间直连、在现有言论平台发布某些信息、在paas、iaas上快速建立发布节点、利用传统p2p文件分享机制传递文件形式的信息。</li>
<li>去中心化后人们如何建立信任？- 类似于GPG的签名机制，熟人间传递公钥识别陌生人。</li>
<li>去中心化后人们如何建立秩序？- 私密的言论圈，秩序由用户自己负责。</li>
<li>……</li>
</ul>


<h2>有没有意义？</h2>

<ul>
<li>现有中心言论平台充斥混乱、谎言、压制。</li>
<li>人们有权接受和发送自己选择的信息。</li>
<li>……</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我们的新前端]]></title>
    <link href="http://nielinjie.github.io/blog/2013/02/25/our-new-front-end/"/>
    <updated>2013-02-25T21:27:49+08:00</updated>
    <id>http://nielinjie.github.io/blog/2013/02/25/our-new-front-end</id>
    <content type="html"><![CDATA[<p>公司历史悠久的B/S办公系（称为E系统）统需要添加移动支持。</p>

<!-- more -->


<p>根据前期决策，公司范围将以hybrid形式作为现有系统“移动化”的标准模式。公司将有专门团队开发外层壳体，作为一个具体应用，我们提供自己的页面，只要这些网页适合手机显示。</p>

<p>所以我们准备新开一个项目，开发本系统适于手机的页面。</p>

<p>初步架构已经完成：</p>

<h2>整体结构</h2>

<h4>SinglePageApplication</h4>

<p>采用趋向于SinglePageApplication风格是一项比较早确定的决策。即将大部分的展示逻辑都部署到浏览器端。这和公司里面现在大量存在的类似于Spring MVC的结构非常不同。但我们认为这个风格意义很明显：</p>

<ul>
<li>用户体验提升</li>
<li>移动互联网环境下性能要求</li>
<li>展示逻辑集中控制</li>
</ul>


<p>虽然在现今互联网很常见，但在公司的环境中，这种风格还比较新。开发设计人员对这个风格并不熟悉，我们需要特别注意由此带来的风险，在后面“前端结构和技术”一节，将提到的一些决策，都能帮助减轻这个风险。</p>

<h4>REST</h4>

<p>理解REST的含义特别是必要性并不容易。</p>

<p>最近有一个项目，同样是OnePageApplication风格，前期准备实践REST风格，但由于大家并没有理解REST含义，架构执行过程中也没有进行修正，最终成为了JSON-RCP风格接口。</p>

<p>在本公司架构师之间，对REST的理解也不尽相同。很多架构师更多的思考如何使用，对于“为何要使用”这个关键问题反而思考得比较少。</p>

<p>在新的项目中，我们在尽量使用REST风格接口的同时，并不强求其纯粹的风格，相反，我们将通过这次实践着重思考REST的意义，特别是对我们这个企业，在这个既有环境中的意义。</p>

<h4>业务逻辑</h4>

<p>E系统的既有结构是Web和App各部署到一组节点，相互分离的结构，理论上讲，业务逻辑全部部署于App层，我们只要重新开发我们的Web层，即可完全利用既有的业务逻辑。但实际情况是，很多业务逻辑被放到了web层。这不是既有架构的初衷。出现这种情况的原因应该是：</p>

<ul>
<li>开发（包括设计人员）人员知道有这个架构决策，不知道为何有这个决策。当架构执行力度降低的时候，开发人员按照自己的想法和当时环境的短期要求来组织逻辑。</li>
<li>系统采用Transaction script风格架构，以功能为主线条组织业务逻辑，同时又以功能为单位管理需求、开发过程，这进一步加剧了开发人员在当前功能的自由随意。</li>
</ul>


<p>我们对E系统的层次规划类似于DDD常用的四层<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，我们希望系统的业务逻辑能全部封装在业务层（应用层或者领域层），通过REST或者其他形式的接口暴露给展示层。在项目范围内，我们将在业务层中重写一些以前在展示层的业务逻辑。同时，另一个项目正在致力于重新布置整个E系统的代码结构，两个项目如何配合，将是我们需要小心处理的问题。</p>

<h2>前端结构与技术</h2>

<h4>模式和框架</h4>

<p>展示逻辑将全部部署于浏览器端，我们需要考虑如何组织这些逻辑。</p>

<p>MVC（或者其变体，我们不做区分）简单有效，开发人员比较熟悉，没有不使用的理由。我们考察了一些相关框架，最后落脚于下面两个：</p>

<ul>
<li>Backbone &ndash; 简单直白，社区活跃。虽然核心框架中不包含composite view、data binding等功能，但相关插件都有，可以方便的自由组合。</li>
<li>Ember &ndash; 功能丰富，特别是如果配合ember data，基本可以一站式解决所有问题。缺点是比较新，特别是ember data还不是“Production Ready”，遇到问题不一定能快速解决。</li>
</ul>


<p>我们倾向于Backbone，核心框架再按需配备一些周边挂件。对于不熟悉相关领域的开发人员，这种风格相对容易学习。</p>

<h4>语言基础</h4>

<p>以Js作为语言开发大规模复杂逻辑，开发人员并不熟悉，需要一些支持：</p>

<ul>
<li>模块化：模块化对于大规模的开发来说是必不可少的，但以前的开发人员却并不熟悉。这次我们选择Requirejs或者Seajs，将强制执行它们带来的模块机制。两者区别不大，就支持一下国货吧。</li>
<li>OO：Mootools带来类似extends、implement等OO特征，让习惯Java的开发人员非常顺手。但Backbone有自己的一点诸如继承的机制，如何协调两者关系，相关细节需要和开发人员一起研究讨论，建立示例代码。</li>
<li>单元测试：此类工具种类繁多，没有一一研究比较，只要有一个可用的就可以了。Qunit，必要的时候配合JSTestDriver。</li>
<li>遗留代码：遗留代码如何融入到上述的模块化机制，是一个还没有解决的问题。可能直接shim，也可能手工对每个文件逐个重新包装。两者优劣，需要继续研究。</li>
</ul>


<h4>响应式？</h4>

<p>使用一套响应式的页面还是大屏、小屏各用一套页面？还是两套吧。</p>

<ul>
<li>我们已经有了一套适用于pc web的大屏页面，其可用性久经考验。</li>
<li>我们不一定有足够的技术能力完成一套可用的响应式页面。</li>
<li>我们可以在新的一套页面中逐步加入响应式特性，一步步替代老的pc web页面。个人认为这是迟早的事，以后的屏幕，存在多种大小，多种分辨率，很难简单分为大屏、小屏两套。</li>
</ul>


<h4>JQuery、HTML5、CSS3？</h4>

<p>这些欢型的局部实现问题，留给前端工程师。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>四层=展示层+业务层+数据层，其中，业务层=应用层+领域层<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WD My Book Live 作为下载机]]></title>
    <link href="http://nielinjie.github.io/blog/2013/01/23/wd-download-machine/"/>
    <updated>2013-01-23T21:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2013/01/23/wd-download-machine</id>
    <content type="html"><![CDATA[<p>入了一个家用存储设备： <a href="http://www.360buy.com/product/502047.html">西部数据（WD）My Book Live 3.5英寸家庭网络硬盘3TB(WDBACG0030HCH)</a> 京东号称降价￥400，现在入看来还是比较合算的。</p>

<!-- more -->


<p>本来只是作为一个纯粹的硬盘来入手的。入了以后才发现可以用来下载。很好，可以不用开着下载电脑也不错。</p>

<h3>一、BT下载</h3>

<p>首先想到的是BT下载，也是网上提到比较多的。</p>

<p>网上的相关指南非常多（<a href="http://bbs.weiphone.com/read-htm-tid-5033256.html">比如这个</a>），大同小异，一般先装好fpkmgr，再安装Transmission。很容易，依葫芦画瓢没有遇到任何问题。</p>

<p>但问题是效果不佳，在我的网络环境中，即使yyets上的热门影片往往只能数十K的速度，远远称不上理想。对于BT下载并不精通，初步看了下原因，貌似Tracker好多都连不上。不知道是种子本身的原因还是Transmission配置的原因。反正跟以前用电脑挂迅雷比起来差太远，不实用。</p>

<h3>二、aria2和迅雷离线下载</h3>

<p>这种方式是利用aria2下载迅雷离线中已经下载好的内容，相当于“取回本地”操作。</p>

<ul>
<li>安装aria2，网上有很多例子，一般是使用optware安装<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。需要注意的是，optware自己的repository里面的aria2非常老，貌似是1.4的版本，最大的问题是没有rpc支持，远程控制不方便，比如不能使用后面提到的YAAW。我的办法是先安装这个版本，把依赖都自动装好，然后网上找了个1.15版本的文件<a href="http://pan.baidu.com/share/link?shareid=139721&amp;uk=2033032603">2</a>，直接替换掉1.4的文件。目前为止，运行得不错。</li>
<li>对迅雷离线页面的简单hack，从页面提取URL供aria2 http下载。有写好的js和插件。<a href="http://blog.binux.me/ThunderLixianExporter/">3</a></li>
<li>使用YAAW添加下载任务和管理下载过程。<a href="http://blog.binux.me/yaaw/">4</a></li>
</ul>


<p>这种方式效果很好，宽带带宽基本占满，可以支持迅雷离线所支持的一切合适，比如http、ftp、bt、donkey、磁链等等。家人也可以随时把下载要求直接放入迅雷离线，后续统一拿到本地。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>网上教程大多是要自己先安装optware。而我的机器里面已经有了optware，不知道是出厂带来的还是安装fpkmgr时候安装的。只需要把他（ipkg）加入到path中即可。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[这些年写过的代码（一）]]></title>
    <link href="http://nielinjie.github.io/blog/2013/01/23/code/"/>
    <updated>2013-01-23T21:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2013/01/23/code</id>
    <content type="html"><![CDATA[<p>2012年的最后两天，终于完成了一个久拖不决的任务：把几年来写过的代码review了一番。</p>

<!-- more -->


<p>这里记录的都是业余时间写的代码，它们往往都是以（企图）解决生活中的一个实际问题开始的，然后变成了当时流行的技术的试验场。这种情况下，最后当然往往把最初要解决的那个问题抛之脑后，无法挽回其烂尾命运。</p>

<h2>一、爬虫</h2>

<p>这是web爬虫程序。这个程序要解决的问题起源于从某个在线看书网站批量下载小说章节。后续又有批量下载mm图片的兴趣，使这个程序源远流长。
在这个问题中，程序逻辑主要集中在几个问题——</p>

<ul>
<li>爬虫线程管理：网络内容获取是耗时和不确定的io操作，需要管理其状态。同时爬虫往往是从前一个爬虫衍生的，所以所有爬虫线程中，既有并列关系的线程，也有先后关系的线程。</li>
<li>爬虫群中间状态管理：爬虫群不一定能一次完成所有想要内容的获取，需要把中间状态保存下来，同时由于web内容是持续更新的，爬虫群也需要支持发现和获取更新的操作，这也要求记录中间状态。显然，中间状态必须在多个爬虫线程间共享。</li>
<li>内容对象：爬虫群从web中获得的内容需要按照业务意义进行组织，形成一个对象团。这个对象团不同于爬虫群中间状态，也往往不直接对应于所爬过的网站结构。</li>
<li>爬虫行进路线：这个爬虫不是对页面上所有的链接进行跟进，而是根据网站结构，有目的的爬向有意义的内容，是有路线图的。以下载小说为例，第一个页面是排行榜，我们爬向某本书的链接而不是爬向广告，同样，到了具体的内容页面，我们尽量爬向“下一页”而不是“下一章”。</li>
<li>上述四点，前两个问题是所有爬行任务都一样的，后两个问题是每个爬行任务不同的，是对爬行任务的描述。这两个层面，分别是操作层和知识层，如何处理他们的联系，也是一个重要问题。</li>
</ul>


<p>这个程序我这里有groovy版、clojure版、scala版。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<p>最初是groovy<a href="http://groovy.codehaus.org">0</a>版，是直接从批量下载小说的需求引出的。</p>

<ul>
<li>groovy是我接触过的第一个jvm上的语言，闭包、动态特性和适度的magic，在某些场合非常合用。</li>
<li>groovy有称之为“builder”的风格，比如有xmlBuilder、httpBuilder……，类似Object Literal，简洁好用。</li>
<li>grovvy有现成的查询html中某些节点的工具。</li>
<li>有个griffon<a href="http://griffon.codehaus.org">1</a>，是仿照grails<a href="http://grails.org">2</a>的思想做的swing下的mvc框架。</li>
<li>这个版本以java内置的线程池管理线程。</li>
<li>这个版本没有区分操作层与知识层，没有考虑底层逻辑有可能被其他爬行任务服用的问题，没有从概念上区分中间状态对象、网站结构对象和内容对象。以网站结构对象为中心驱动：从一个结构对象中得到爬行线程对象，也从中抽取内容对象。</li>
</ul>


<p>然后是clojure<a href="http://clojure.org">3</a>版</p>

<ul>
<li>clojure是我见过的第一个把并发支持宣称为语言特性的一门语言。</li>
<li>clojure的lisp语法非常引人入胜。</li>
<li>当时对clojure没有对象（那时候想办法用record模拟，但别扭）这个特征非常迷惑，觉得没有对象咋能写程序呢？当然就更没办法去想什么操作层、知识层等等……</li>
<li>clojure的agent<a href="http://clojure.org/agents">4</a>，及其watch，非常适合爬行的底层逻辑。很方便的自动管理爬行线程间的并列、先后关系。</li>
<li>由于对FP<a href="http://en.wikipedia.org/wiki/Functional_programming">5</a>风格的不熟悉，不知道如何以这种风格去抽象逻辑层次，这个版本只实现了有限的底层逻辑。</li>
</ul>


<p>然后是scala<a href="http://www.scala-lang.org">6</a>版本，有好几个scala版本</p>

<ul>
<li>scala是个好语言。很多观点认为它有点太难学。不过我认为，如果你还没有完全学会，那你就像用java一样使用它，逐步领悟它的不同和强大之处。</li>
<li>sbt<a href="http://www.scala-sbt.org">7</a>好用。但有时候稍微复杂了点。只有最简单的情况可以声明式配置，稍微负载的情况就需要进行编程。</li>
<li>从scalaz<a href="http://code.google.com/p/scalaz/">8</a>我真正开始学习FP，有兴趣的同学可以详细读一下scalaz的例子的源代码。生活在 OO<a href="http://en.wikipedia.org/wiki/Object-oriented_programming">9</a>、imperative<a href="http://en.wikipedia.org/wiki/Imperative_programming">10</a> 世界的同学将会感到耳目一新，逐渐感到OO乃至imperative在某些方面相对乏力<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。</li>
<li>第一个版本我纠结于如何实现对象在线程间共享，我采用的策略是不共享，把公共对象封装在actor<a href="http://www.scala-lang.org/node/242">11</a>之下，由actor机制实现线程间通讯，不是所有线程都直接访问公共对象。现在scala已经吸纳了akka<a href="http://akka.io">12</a>的actor实现，比以前更加强大了。</li>
<li>第一个版本还研究了如何抽象在一个大对象中访问、修改某个深层属性，那时候不知道有Lens<a href="https://blog.stackmob.com/2012/02/an-introduction-to-lenses-in-scalaz/">15</a>这种模式。</li>
<li>第一个版本开始意识到操作层和知识层的不同，同时由于scala的OO、FP混合特性，我可以自如的进行抽象建模，两个层次完全分开。当面临不同的爬行任务，我只需定义新的内容对象和爬虫行进路线。</li>
<li>这里虽然没有进一步抽象出DSL<a href="http://en.wikipedia.org/wiki/Domain-specific_language">13</a>，但对DSL和其在scala的实现办法进行了一些研究，Internal DSL<a href="http://martinfowler.com/bliki/DomainSpecificLanguage.html">14</a>方面，scala没有groovy容易；但由于几个方便的工具，External DSL<a href="http://martinfowler.com/bliki/DomainSpecificLanguage.html">14</a>反倒是比较方便 —— 比如Kiama<a href="http://kiama.googlecode.com">16</a>、Parboiled<a href="https://github.com/sirthias/parboiled/wiki/parboiled-for-Scala">17</a></li>
<li>第二个版本出现在我发现STM<a href="http://nbronson.github.com/scala-stm/">20</a>在scala也有实现的时候，除了大对象共享方式不同，其他跟第一个版本大同小异。</li>
<li>第三个版本出现在我迷恋上Applicative、Monad、Arrow<a href="http://www.haskell.org/haskellwiki/Typeclassopedia">18</a> 、Iteratee<a href="http://www.haskell.org/haskellwiki/Enumerator_and_iteratee">19</a>等FP模式<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>的时候，我感到OO的编程模式丑陋而无法忍受，我要Lens，大对象要不可变、线程要被隐藏在并发模型之后、爬行任务的生成要实现Iteratee模式，总之我想以FP的“优雅”的方式实现这个程序。结果是，还没写完……。</li>
<li>我意识到自己在强迫自己使用不一样的、不熟悉的、听上去很牛的编程风格，只领略这些风格的不同和神奇，而没有认真思考这种不同有没有真正带来好处。<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></li>
</ul>


<p>最后有个Android版本，原本想实现在android上的爬行，并且开始探索scala在android上运行的可行性。但这个版本由于我迅速成为果粉而无疾而终。</p>

<p>（待续）</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>已经相当长时间没有关注groovy、grails、griffon、clojure的相关内容了，观点可能过期。scala相关的略好些。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>将FP跟OO、Imperative对立并不严密。但这里不打算仔细区别这个，我这里的OO、Impaerative指的通常的java、c#、c/c++之类的“主流”语言。<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>这里列出的都是Haskell的地址，因为Haskell有页面集中说明这些东西是啥。实际操作中还是用的scalaz实现版本。<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>我这样说完全不是指我反对FP风格。实际上我非常喜欢这种风格。我的意思只是，在学习的时候，需要更多的思考。<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[语录：关于企业中公用类库和框架的管理]]></title>
    <link href="http://nielinjie.github.io/blog/2013/01/01/said-20130101/"/>
    <updated>2013-01-01T21:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2013/01/01/said-20130101</id>
    <content type="html"><![CDATA[<p>关于企业中公用类库和框架的管理，在微博上与同行讨论，记录如下<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，也是我对公司的P框架的期待。</p>

<!-- more -->


<p>人说孩子要教的人多，管的人少。类库和框架也一样，整个企业都要对他作出贡献，但要有一两个靠谱的人始终负责管理，维护好它的定位、规划好它的方向，平衡好通用和合用、稳定和进化的关系。</p>

<p>我期待中的管理者将采用这样的管理策略——</p>

<ul>
<li><p>新特性应该由任何使用这个库的用户按自己的需要开发并提交；管理者要做的是决定哪些特性并入master流。任何用户也可以维护适应自己需求的流，但这些流都是从master流分支而出。</p></li>
<li><p>创新团队<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>维护自己的流（可能不止一个，按特征簇分开）。其中的新特性由使用者按自己的需求试用。验证后，交由管理者决定是否并入master流。</p></li>
<li><p>master流不一定只有一个，可以按使用模式或特征簇分成多个流。这些流以及它们之间的关系，由管理者定义和维护。</p></li>
<li><p>管理团队并不干预用户对框架的使用模式，由使用现场的架构要求决定。如果使用现场没有特殊要求，则可优先从master流中选择使用模式。</p></li>
</ul>

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>有整理，比如去除了一些使讨论通顺的口水话。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>他们推动框架的变化的动机是业界的技术趋势，而不是现场需求。<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[语录：REST]]></title>
    <link href="http://nielinjie.github.io/blog/2012/12/05/said-20121205/"/>
    <updated>2012-12-05T21:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2012/12/05/said-20121205</id>
    <content type="html"><![CDATA[<p>不是REST就别说是REST，可以说是json-rcp，又不丢人。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[语录：架构维护者的职责]]></title>
    <link href="http://nielinjie.github.io/blog/2012/12/03/said-20121203/"/>
    <updated>2012-12-03T21:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2012/12/03/said-20121203</id>
    <content type="html"><![CDATA[<p>目前最优不等于可以接受。架构维护者的职责就是守住一条底线，难点在于这时候你要对抗的往往不是敌人而是战友。</p>
]]></content>
  </entry>
  
</feed>
