<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 过程 | 聂同学]]></title>
  <link href="http://www.nietongxue.xyz/blog/categories/guo-cheng/atom.xml" rel="self"/>
  <link href="http://www.nietongxue.xyz/"/>
  <updated>2016-12-21T20:56:34+08:00</updated>
  <id>http://www.nietongxue.xyz/</id>
  <author>
    <name><![CDATA[nielinjie]]></name>
    <email><![CDATA[nielinjie@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[问题空间与解空间]]></title>
    <link href="http://www.nietongxue.xyz/blog/2016/08/14/question2/"/>
    <updated>2016-08-14T20:29:27+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2016/08/14/question2</id>
    <content type="html"><![CDATA[<p>问题空间与解空间<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，体现了思考的一般过程，所以在很多方法论中有所表现。</p>

<!--more-->


<p>“设计思维”讲到4D过程，Discovery、Define、Design、Delivery。 其中Discovery、Define就是在研究和结构化问题空间，而Design、Delivery则分别是解决问题和归纳整合，属于解空间。</p>

<p>领域驱动设计方法中，子域与上下文是两个看来近似的概念。其实子域在问题空间，是对领域这个大问题的分解，而上下文在解空间，是对子域的解决。研究上下文的关系，则是在归纳整合，使这些解决能互相融洽，共同解决领域这个大问题。</p>

<p>有一类问题，难点和重点在于分析和分解问题，解决问题倒是比较容易。针对这类问题的方法，自然是强调研究问题空间。</p>

<p>威胁建模方法，是一个很好的例子。数据流图，信任空间，STRIDE模型，都是研究问题空间的方法。找到了可能的威胁之后，还要对威胁进行评估排序，这些都是在问题空间。到最后才谈到解空间，也就是如何解决威胁。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>在<a href="/blog/2016/08/13/question/">前一篇</a>中首先提及。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[架构设计过程的驱动技术（三）]]></title>
    <link href="http://www.nietongxue.xyz/blog/2016/08/13/question/"/>
    <updated>2016-08-13T20:29:27+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2016/08/13/question</id>
    <content type="html"><![CDATA[<p>特征驱动和风险驱动，看来是相对完备的驱动技术；模式驱动，则不是那么完备。
这两类驱动技术的区别究竟从何而来呢？</p>

<!--more-->


<p>大部分人思考问题，特别是比较复杂的问题的过程。分为两个步骤 -</p>

<ul>
<li>第一个步骤，分析问题，定义问题，分解问题，将大问题、复杂的棘手的问题，分解为小的可解决的子问题。这个步骤，我们称为处理问题空间。</li>
<li>第二个步骤，对第一个步骤得到的子问题分别解决，并将所有答案归纳整合，使之可以解决最初的复杂问题。这个步骤，我们成为处理解空间。</li>
</ul>


<p>两个步骤如下图所示。图中ABCD步骤，就是处理问题空间，步骤EFGH则是处理解空间。</p>

<p>显然，模式驱动没有覆盖第一个步骤，只覆盖了第二个步骤。而特征驱动和风险驱动，覆盖了第一第二两个步骤。其中，特征驱动认为实现特征就是我们面对的大问题，提供了分析分解这个大问题的办法，这些方法都是作用于问题空间的方法。而风险驱动认为应对风险就是我们的大问题，提供了定义风险衡量风险等在问题空间方法。</p>

<p><img src="/images/question/question.png" width="500"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[“程序员需要工程思维”]]></title>
    <link href="http://www.nietongxue.xyz/blog/2016/03/13/quality2/"/>
    <updated>2016-03-13T19:46:06+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2016/03/13/quality2</id>
    <content type="html"><![CDATA[<p>有同学提到工程思维，认为借助传统的建筑、机械工程的思考方式，有助于控制软件工程质量<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。这当然是有益的。</p>

<!--more-->


<p>但我们需要注意，软件系统与传统建筑、机械系统有非常重要的不同。直接借鉴传统的建筑、机械工程思维，很多时候是不足以解决问题的。</p>

<p>最大的不同在于：软件系统不仅是运行着的，而且是演进着的<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。而且这个演进是必需的、积极的、有巨大价值的。这是软件质量控制的独特和真正困难之处。</p>

<p>传统工程一旦产出，产品本身就保持稳定。所以传统质量的定义是描述产出物的特征，符合这个特征的就是好质量，否则就是坏质量。对于特定的产品，质量的定义保持不变。质量控制的方法也以质量定义不变作为前提。</p>

<p>这个办法在软件这里不好用。因为产出物的特征不断变化，质量的定义必须不断变化。所以质量控制方法必须多增加一个维度，即质量定义本身的变化。有了这个维度，问题完全不一样了。</p>

<p>所以，从质量控制这个角度来说，将软件系统比作建筑、机械系统，软件工程比作建筑、机械工程是不理想的。不如把软件系统比作社会系统，把软件工程比作社会的发展演进。软件质量控制，更多的从社会科学领域借鉴方法。比如为了控制社会的有效运行，人类发明了立法、司法、执法等成体系的有效手段，我们可以借鉴，“反脆弱”<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>是个不错的尝试。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI0NjA1NTg0MA==&amp;mid=402605263&amp;idx=1&amp;sn=0490d0de815bef7ac9c61f8c47e0254e&amp;scene=2&amp;srcid=03136ItfAMvAXMJLxllTDEsp&amp;from=timeline&amp;isappinstalled=0#wechat_redirect">为了产品，程序猿请随时加满工程属性</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>“卖出不管”的传统软件这里不讨论。主要讲互联网系统比如SAAS。<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p><a href="/blog/2015/05/23/cloud2/#an">“反脆弱”</a><a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在发展中团队：开发质量问题]]></title>
    <link href="http://www.nietongxue.xyz/blog/2016/01/24/develop-quality/"/>
    <updated>2016-01-24T11:44:37+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2016/01/24/develop-quality</id>
    <content type="html"><![CDATA[<p>随着系统和团队规模逐渐成长，开发质量问题<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>一般有增多趋势。</p>

<!--more-->


<p>错误（包括低级错误）是不能完全避免的。开发人员如何减少错误呢？</p>

<p>有两个方面的事情可以做：</p>

<p>一是依靠团队和合理的过程，相互检查排错。比如结对编程、codereview、代码静态扫描、各种评审会议等等，都是属于这类。</p>

<p>另一个方面，是构建并依靠合理的系统结构。合理的系统结构一来可以分割复杂度，使开发人员面临相对简单的工作，减小错误发生的概率；二来即使错误发生，可以将错误的影响面限制在组件内部，减小全局影响。</p>

<p>可以说前一方面偏于对症治疗，而第二方面偏于对因治疗。对因治疗当然更利于根本性地杜绝错误，但很多时候对症治疗更加直接有效，同时为对因治疗赢得时间和资源。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>这里说的“开发质量问题”，指的是由于局部错误造成的系统问题。特别是那些由开发人员个人错误造成的问题。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在发展中团队：领域管理]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/12/31/developing-domain/"/>
    <updated>2015-12-31T09:54:24+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/12/31/developing-domain</id>
    <content type="html"><![CDATA[<p>度过初创期，业务复杂性明显发展，系统结构和质量越来越受到重视。</p>

<p>需要考虑如何管理领域<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。</p>

<!--more-->


<h3>什么是领域？</h3>

<p>领域是业务概念和他们之间的关系与协作。系统的目的就是实现这些概念和协作。</p>

<h3>领域有什么用？</h3>

<ol>
<li>领域决定系统的业务特征。领域的现状就是系统的业务现状，领域的历史就是系统的业务历史。或者说，领域体现了业务与系统特征间的因果关系。</li>
<li>领域是通用语言。在产品团队与开发团队间，各产品线之间，各开发团队之间或者开发团队内部。领域是沟通的语言，也是发布和积累的语言，是协作的首要工具。</li>
<li>领域是系统结构的依据。以领域驱动设计<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>是应对系统复杂性的常见手段。领域的结构深刻影响系统结构。</li>
</ol>


<p>这些用途决定了对领域管理的要求，比如：容易阅读，容易查找，容易控制，容易共享，容易跟踪变化。</p>

<h3>如何管理领域？</h3>

<ol>
<li>从静态、动态两个角度描述领域。静态体现领域实体和他们的关系，动态体现领域实体的行为和协作。可以借用UML类图和序列图的形式<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>，也可以使用伪代码。</li>
<li>形式化、结构化的描述体系。形式化的语言去除二义性，知识在各团队各角色之间不会产生歧义。结构化的语言体现层次，不同角色可以关注不同层面。 这一点上，UML相关约定完全够用。如果结合文件系统的树形结构，可以实现足够丰富的层次。</li>
<li>使用git或其他SVC。便于共享和跟踪变化。这要求使用尽量简单的描述语言。在这里，一般的UML图不太理想，人类无法阅读UML图的diff。同样的，各种其他图、doc文档之类也不理想。可以借用马丁大叔UmlAsSketch<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>的想法，使用纯文本形式的UML。</li>
<li>使用中文。英文翻译是引入歧义的重要途径，在尽量少的地方使用英文，而不是相反。</li>
<li>与开发共享周期。领域变化的步调一般与系统的设计开发一致，可以借用设计开发的版本和迭代周期。</li>
</ol>


<p>另外，一些可能的问题——</p>

<p>Q：领域是需求么？<br/>
A：对于开发团队来说，可以说领域来源于需求。区别是：</p>

<ol>
<li>需求从产品和用户的角度，以交互驱动；领域从设计和开发的角度，以结构和逻辑驱动。</li>
<li>需求是增量，领域是全量。需求描述的是每次改动，一般以版本、迭代作为组织单位。如果想从需求知道系统体现业务现状，就必须将历史中所有相关需求找出来进行归纳，这无疑非常困难。而领域持续维护，随时体现当前现状。</li>
<li>需求关心局部，领域关心全局。需求强调体验，往往专注于局部，以一个场景一次交互为单位进行描述。而领域强调整体，需要负责跨产品线跨系统保持一致性。</li>
<li>需求包括功能、质量、约束，领域只涉及到功能。</li>
</ol>


<p>Q：领域是设计（类图、ER图……）么？<br/>
A：领域是设计的依据（之一）。设计的目的是实现领域，但设计需要同时考虑其他架构策略，比如由质量要求引发的技术方案。如图：</p>

<p><img src="/images/dev/domain.png" width="550"></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>本文中的“领域”都是指“领域模型”或者其他形式的领域知识，而不是领域本身。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>此处的“以领域驱动设计”不完全等于DDD。<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>是不是任何事物都可以从静态和动态两角度描述，进而都使用类图和序列图？<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p><a href="http://martinfowler.com/bliki/UmlAsSketch.html">UmlAsSketch</a><a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
