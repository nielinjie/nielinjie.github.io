<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 架构 | 聂同学]]></title>
  <link href="http://www.nietongxue.xyz/blog/categories/jia-gou/atom.xml" rel="self"/>
  <link href="http://www.nietongxue.xyz/"/>
  <updated>2017-04-09T16:14:23+08:00</updated>
  <id>http://www.nietongxue.xyz/</id>
  <author>
    <name><![CDATA[nielinjie]]></name>
    <email><![CDATA[nielinjie@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[涌现中的架构（一）]]></title>
    <link href="http://www.nietongxue.xyz/blog/2017/04/04/emergence/"/>
    <updated>2017-04-04T17:43:06+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2017/04/04/emergence</id>
    <content type="html"><![CDATA[<p>之前对敏捷架构的思考和实践主要在敏捷团队内部<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。这个系列主要探讨在公司级别的敏捷架构实践。</p>

<!--more-->


<p>在实行敏捷风格架构的场景中，各个团队将按照自己的实际情况和各自对架构的理解完成架构活动。</p>

<p>作为全局架构师角色，不再进行提前的统一的架构设计。主要工作集中在对架构活动的辅导、服务和审核。</p>

<p>工作主要在几个方面 -</p>

<ol>
<li><p>架构结果不能相互抵触。</p>

<p>各团队产出各种组件，它们之间必须能够协作。各个团队的设计结果必须遵从协作协议。要么是既有的，要么是及时达成的。</p></li>
<li><p>上层结构需要持续维护。</p>

<p>跨团队的涌现架构需要一些上层结构的支持<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。团队设计的结果随时可能对高层结构产生影响，这时候需要判断这种影响是否是良性的。进而决策是鼓励还是遏制这种影响。</p></li>
<li><p>架构活动需要保持某种一致。</p>

<p>各个团队解决问题的方式需要某种程度的一致性，如果彼此相差太多，就会造成系统难以理解。对演进和传承都有不良的影响。但如果过于强调一致性，又有僵化的趋势，等于走回到计划型架构的老路。</p></li>
<li><p>架构设计有时可能需要干预。</p>

<p>敏捷和涌现的架构是我们的目标。但有些团队可能需要一些帮助才能做到。设计能力方面可能有待提高，认识理念方面可能需要统一。这些团队需要比较频密的干预和辅导。</p></li>
</ol>


<p>几个问题需要在实践中探索 -</p>

<ol>
<li><p>是否要规定架构设计的产出物？</p>

<p>可能需要某种程度的统一产出物，以便全局架构师审核和其他团队参考。</p></li>
<li><p>如何找到合适的沟通时间点？</p>

<p>架构设计会在团队间产生相互影响，当团队的节奏不同时，如何找到对彼此影响较小的时间点？</p></li>
<li><p>是否需要集中的架构研讨会议？</p>

<p>团队间的架构沟通是否可以通过一个集中的会议来减少成本？</p></li>
</ol>

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>之前总结的一个系列，时间比较久了。—— <a href="/blog/filter/filter.html?filterName=series&amp;filterValue=%E6%95%8F%E6%8D%B7%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1&amp;filterDes=Series%3A%20%E6%95%8F%E6%8D%B7%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1">Series: 敏捷的架构设计</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>最重要的一个可能是：有界上下文。之前有文重点说明这个结构的应用。—— <a href="http://localhost:4000/blog/filter/filter.html?filterName=series&amp;filterValue=%E9%87%8D%E6%9E%84%EF%BC%8C%E4%BB%A5%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84%E4%B8%BA%E4%B8%AD%E5%BF%83&amp;filterDes=Series%3A%20%E9%87%8D%E6%9E%84%EF%BC%8C%E4%BB%A5%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84%E4%B8%BA%E4%B8%AD%E5%BF%83">Series: 重构，以知识结构为中心</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[技术的对面]]></title>
    <link href="http://www.nietongxue.xyz/blog/2016/12/23/tech/"/>
    <updated>2016-12-23T09:13:54+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2016/12/23/tech</id>
    <content type="html"><![CDATA[<p><u><strong>技术</strong></u>的对面<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>是什么？<!--more--></p>

<p>是<u><strong>应用</strong></u>么？是<u><strong>方法</strong></u>么？是<u><strong>思想</strong></u>么？是<u><strong>道</strong></u>么？</p>

<p>最近看来，是<u><strong>策略</strong></u>。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>对面不是对立，是并立。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[与复杂同行（一）]]></title>
    <link href="http://www.nietongxue.xyz/blog/2016/12/11/complex/"/>
    <updated>2016-12-11T13:21:04+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2016/12/11/complex</id>
    <content type="html"><![CDATA[<p><strong>复杂性平方律</strong></p>

<blockquote><p>系统的复杂性正比于系统规模的平方</p></blockquote>

<p>一、系统的复杂性不仅由节点的数量（即“规模”）带来，更多的是由节点间的关系（包括没有关系）带来。<!--more-->
这也就是复杂性平方律的原因。系统的复杂性正比于节点数的平方，因为节点间的连接数正比于节点数的平方。
我们假设节点和连接的复杂度都为1，比如下图所示的系统，总复杂度为14。</p>

<p><img src="/images/complex/complex1.png" width="300"></p>

<p>二、尝试分拆系统。节点被分拆到两个不同的空间，出现了跨空间的连接，这些连接通常成本相对高，带来了相当多额外复杂度。
所以简单的分割不一定能带来复杂性的改善。
我们假设跨空间连接的复杂度为k，则两个空间的复杂度分别为7+4k、3+4k，要使分拆后复杂度降低，对k的要求很高 -</p>

<blockquote><p>  7 + 4k &lt; 14 => k &lt; 1.75</p>

<p>  3 + 4k &lt; 14 => k &lt; 2.75</p></blockquote>

<p><img src="/images/complex/complex2.png" width="300"></p>

<p>三、增加一些节点和连接（方块节点和虚线连接）来改变跨空间连接。
由于方块节点和虚线连接通常是一些技术性的代理元素，不用承载领域内容。它们的复杂性通常小于普通元素。这里我们仍然按1来计算。
同样计算对k的要求，发现降低了很多。</p>

<blockquote><p>11+ k &lt; 14 => k &lt; 3</p>

<p>6 + k &lt; 14 => k &lt; 8</p></blockquote>

<p><img src="/images/complex/complex3.png" width="300"></p>

<p>（待续） <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>前方坑大。管挖不管填。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式事务，也谈（番外）]]></title>
    <link href="http://www.nietongxue.xyz/blog/2016/10/07/process/"/>
    <updated>2016-10-07T14:29:52+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2016/10/07/process</id>
    <content type="html"><![CDATA[<h3>过程管理，一个基础模式？</h3>

<p>系列中<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>提到，事务管理，实质是一个过程管理。</p>

<!--more-->


<p>包括事务管理，过程管理还出现在多个常见的场景中，比如 -</p>

<ul>
<li>事务管理 - 负责管理各个相关联的操作，对他们的“状况“做出决策应对。</li>
<li>服务编排 - 负责将小粒度和职责单一的服务组合为复杂的业务过程。</li>
<li>协调异步 - 负责异步操作之间的步调协调工作。</li>
<li>交互串联 - 负责将多个业务步骤包装为一个用户友好的交互过程。</li>
</ul>


<p>这几个场景都是一个管理者在对一个过程进行管理。但在不同场景中管理者的职责不同 -</p>

<ul>
<li>事务管理 - 强调操作状况的可见、可控、可稽核。</li>
<li>服务编排 - 强调服务间的依赖管理，服务结果的传递和收集。</li>
<li>协调异步 - 强调操作间的步调协同，与同步的转化，处理等待，处理中间状态。</li>
<li>交互串联 - 强调与用户的交互，比如处理中间状态的表现，过程中用户的干预等。</li>
</ul>


<p>根据系列中的研究，这些个过程管理都可以考虑实现为分层结构的状态机模型。</p>

<p>这里有一个挑战：实际情况中一个管理组件很有可能兼职，很可能需要同时完成上述职责中的两三项。这种情况下，处理具体业务逻辑的最上层，就需要从各个职责各自的角度，对操作和决策进行描述，然后，如果能做到的话，把它们融合起来。</p>

<p>（也许还有下一篇，研究下如何融合各个职责的操作和决策）</p>

<p><img src="/images/transaction/process.png" width="500"></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>系列 - <a href="/blog/2016/09/19/transaction/">分布式事务，也谈</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式事务，也谈（之三）]]></title>
    <link href="http://www.nietongxue.xyz/blog/2016/10/06/transaction3/"/>
    <updated>2016-10-06T00:43:57+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2016/10/06/transaction3</id>
    <content type="html"><![CDATA[<p>继续谈实现模型。按抽象层次分层，设计为知识→操作多层结构，每个层针对不同层面的概念、逻辑和开发者。</p>

<!--more-->


<p>最上层为具体业务开发者需要关注的概念，实际上只包括：</p>

<ol>
<li>各个操作的特征，说明各个操作如何调用、可否回查、可否撤销等等。</li>
<li>决策表中的具体规则。说明当某某状况发生时，采取某某处置。</li>
</ol>


<p>第二层为事务管理组件，负责组织前面提到的两层嵌套状态机。</p>

<p>第三层和第四层，是两层嵌套状态机本身的实现。</p>

<p><img src="/images/transaction/transaction3.png" width="500"></p>
]]></content>
  </entry>
  
</feed>
