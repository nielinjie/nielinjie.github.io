<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 架构 | 聂同学]]></title>
  <link href="http://www.nietongxue.xyz/blog/categories/jia-gou/atom.xml" rel="self"/>
  <link href="http://www.nietongxue.xyz/"/>
  <updated>2017-06-03T15:58:29+08:00</updated>
  <id>http://www.nietongxue.xyz/</id>
  <author>
    <name><![CDATA[nielinjie]]></name>
    <email><![CDATA[nielinjie@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linus的代码与数据结构]]></title>
    <link href="http://www.nietongxue.xyz/blog/2017/06/03/code-data/"/>
    <updated>2017-06-03T15:39:24+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2017/06/03/code-data</id>
    <content type="html"><![CDATA[<p>Linus说： &ldquo;烂程序员关心的是代码。好程序员关心的是数据结构和它们之间的关系。&rdquo;</p>

<!-- more-->


<p>代码体现的是过程。数据结构（和它们之间的关系）体现的是实体。</p>

<p>这里讲的过程和实体，都是模型，是人类思维对现实世界认知进而处理的手段。</p>

<p>相比较而言，人类对实体的掌握，似乎要优于对过程。我们觉得实体比过程更直观和易处理。</p>

<p>所以面对复杂和大规模的过程，人们借助实体，来增强认知和处理能力 -</p>

<ol>
<li>一方面，我们借助实体，对过程做分割和组合。比如卖个东西，是个复杂的过程，我们借助订单、出库单、送货单等实体，把这个过程分解为相互配合的多个过程，通过分解降低了过程的复杂性。</li>
<li>另一个方面，我们借助实体，对过程作记录和可视。比如用账目来记录经营过程，用看板来可视化生产。虽然没有直接降低复杂性，但帮助了认知和理解。</li>
</ol>


<p>以上来看，实体是我们对付世界的首选武器，即使不得不处理过程，我们也人为地引入实体来帮忙。</p>

<p>回到Linus的话，说代码与数据结构，实际上说的是程序员如何建模设计的问题。我理解Linus的意见是，多用实体，辅助过程，符合人类思维模式，是聪明的选择。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[与复杂同行（番外）]]></title>
    <link href="http://www.nietongxue.xyz/blog/2017/05/21/complex80/"/>
    <updated>2017-05-21T14:57:18+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2017/05/21/complex80</id>
    <content type="html"><![CDATA[<p>在强制家长培训中，一位小学数学的教学专家谈了一个案例 -</p>

<!--more-->


<blockquote><p>一道应用题，所有的同学都得到了它的解答算式 -</p>

<p>25*(5+7)</p>

<p>但是接下来，不同的同学就有不同的步骤 -</p>

<p>有些同学直接按照运算准则，计算 25 * 12，这是两位数乘法，小朋友无法口算，需要通过笔算竖式乘法。</p>

<p>爱思考的同学通过乘法分配律，计算 25 *5 + 25 * 7，避免了两位数乘两位数，可以口算完成，不用使用竖式。</p>

<p>更爱思考的同学计算 25 * 10 + 25*2，难度进一步降低了。</p>

<p>最爱思考的同学计算 25 * 4 *3 ，非常容易计算。</p></blockquote>

<p>这个案例谈的是，通过变换计算的路径，避免复杂计算。（当然如果有可以秒算两位数乘法的小朋友，他可能会觉得“爱思考”的同学们不太好理解。）</p>

<p>软件开发者和架构师的日常工作中，常常也会遇到这个场景。设计方案可能容易发现，但可能不容易直接执行。</p>

<p>这时候我们的办法是变换我们的设计，改善它的可执行性，包括缓解在执行环节的风险。</p>

<p>在我看来利用设计变换需要注意一些原则 -</p>

<ol>
<li>设计变换是解空间的事，尽量不要涉及问题空间，也尽量不要干扰到设计本身。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></li>
<li>设计的变换需要有明确的目的。没事不要变换。这个目的要随时验证。</li>
<li>设计的变换必须是等效的，不论怎么变，需要始终保证能解决最初的问题。</li>
<li>设计的变换在这里实质是一种折中，跟所有折中一样，需要持续管理其影响。</li>
</ol>


<p>上面几点，比较理想化。实际中，情况要复杂一些，但不影响谈原则。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>关于解空间与问题空间，见之前的文章：<a href="/blog/2016/08/14/question2/">问题空间与解空间</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[涌现中的架构（一）]]></title>
    <link href="http://www.nietongxue.xyz/blog/2017/04/04/emergence/"/>
    <updated>2017-04-04T17:43:06+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2017/04/04/emergence</id>
    <content type="html"><![CDATA[<p>之前对敏捷架构的思考和实践主要在敏捷团队内部<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。这个系列主要探讨在公司级别的敏捷架构实践。</p>

<!--more-->


<p>在实行敏捷风格架构的场景中，各个团队将按照自己的实际情况和各自对架构的理解完成架构活动。</p>

<p>作为全局架构师角色，不再进行提前的统一的架构设计。主要工作集中在对架构活动的辅导、服务和审核。</p>

<p>工作主要在几个方面 -</p>

<ol>
<li><p>架构结果不能相互抵触。</p>

<p>各团队产出各种组件，它们之间必须能够协作。各个团队的设计结果必须遵从协作协议。要么是既有的，要么是及时达成的。</p></li>
<li><p>上层结构需要持续维护。</p>

<p>跨团队的涌现架构需要一些上层结构的支持<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。团队设计的结果随时可能对高层结构产生影响，这时候需要判断这种影响是否是良性的。进而决策是鼓励还是遏制这种影响。</p></li>
<li><p>架构活动需要保持某种一致。</p>

<p>各个团队解决问题的方式需要某种程度的一致性，如果彼此相差太多，就会造成系统难以理解。对演进和传承都有不良的影响。但如果过于强调一致性，又有僵化的趋势，等于走回到计划型架构的老路。</p></li>
<li><p>架构设计有时可能需要干预。</p>

<p>敏捷和涌现的架构是我们的目标。但有些团队可能需要一些帮助才能做到。设计能力方面可能有待提高，认识理念方面可能需要统一。这些团队需要比较频密的干预和辅导。</p></li>
</ol>


<p>几个问题需要在实践中探索 -</p>

<ol>
<li><p>是否要规定架构设计的产出物？</p>

<p>可能需要某种程度的统一产出物，以便全局架构师审核和其他团队参考。</p></li>
<li><p>如何找到合适的沟通时间点？</p>

<p>架构设计会在团队间产生相互影响，当团队的节奏不同时，如何找到对彼此影响较小的时间点？</p></li>
<li><p>是否需要集中的架构研讨会议？</p>

<p>团队间的架构沟通是否可以通过一个集中的会议来减少成本？</p></li>
</ol>

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>之前总结的一个系列，时间比较久了。—— <a href="/blog/filter/filter.html?filterName=series&amp;filterValue=%E6%95%8F%E6%8D%B7%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1&amp;filterDes=Series%3A%20%E6%95%8F%E6%8D%B7%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1">Series: 敏捷的架构设计</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>后续会讨论下这些个结构，其中一个比较明显的可能是：有界上下文。之前也有博文提到过这个结构的应用。—— <a href="/blog/filter/filter.html?filterName=series&amp;filterValue=%E9%87%8D%E6%9E%84%EF%BC%8C%E4%BB%A5%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84%E4%B8%BA%E4%B8%AD%E5%BF%83&amp;filterDes=Series%3A%20%E9%87%8D%E6%9E%84%EF%BC%8C%E4%BB%A5%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84%E4%B8%BA%E4%B8%AD%E5%BF%83">Series: 重构，以知识结构为中心</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[技术的对面]]></title>
    <link href="http://www.nietongxue.xyz/blog/2016/12/23/tech/"/>
    <updated>2016-12-23T09:13:54+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2016/12/23/tech</id>
    <content type="html"><![CDATA[<p><u><strong>技术</strong></u>的对面<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>是什么？<!--more--></p>

<p>是<u><strong>应用</strong></u>么？是<u><strong>方法</strong></u>么？是<u><strong>思想</strong></u>么？是<u><strong>道</strong></u>么？</p>

<p>最近看来，是<u><strong>策略</strong></u>。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>对面不是对立，是并立。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[与复杂同行（一）]]></title>
    <link href="http://www.nietongxue.xyz/blog/2016/12/11/complex/"/>
    <updated>2016-12-11T13:21:04+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2016/12/11/complex</id>
    <content type="html"><![CDATA[<p><strong>复杂性平方律</strong></p>

<blockquote><p>系统的复杂性正比于系统规模的平方</p></blockquote>

<p>一、系统的复杂性不仅由节点的数量（即“规模”）带来，更多的是由节点间的关系（包括没有关系）带来。<!--more-->
这也就是复杂性平方律的原因。系统的复杂性正比于节点数的平方，因为节点间的连接数正比于节点数的平方。
我们假设节点和连接的复杂度都为1，比如下图所示的系统，总复杂度为14。</p>

<p><img src="/images/complex/complex1.png" width="300"></p>

<p>二、尝试分拆系统。节点被分拆到两个不同的空间，出现了跨空间的连接，这些连接通常成本相对高，带来了相当多额外复杂度。
所以简单的分割不一定能带来复杂性的改善。
我们假设跨空间连接的复杂度为k，则两个空间的复杂度分别为7+4k、3+4k，要使分拆后复杂度降低，对k的要求很高 -</p>

<blockquote><p>  7 + 4k &lt; 14 => k &lt; 1.75</p>

<p>  3 + 4k &lt; 14 => k &lt; 2.75</p></blockquote>

<p><img src="/images/complex/complex2.png" width="300"></p>

<p>三、增加一些节点和连接（方块节点和虚线连接）来改变跨空间连接。
由于方块节点和虚线连接通常是一些技术性的代理元素，不用承载领域内容。它们的复杂性通常小于普通元素。这里我们仍然按1来计算。
同样计算对k的要求，发现降低了很多。</p>

<blockquote><p>11+ k &lt; 14 => k &lt; 3</p>

<p>6 + k &lt; 14 => k &lt; 8</p></blockquote>

<p><img src="/images/complex/complex3.png" width="300"></p>

<p>（待续） <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>前方坑大。管挖不管填。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
