<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 架构 | 聂同学]]></title>
  <link href="http://www.nietongxue.xyz/blog/categories/jia-gou/atom.xml" rel="self"/>
  <link href="http://www.nietongxue.xyz/"/>
  <updated>2015-12-03T12:00:22+08:00</updated>
  <id>http://www.nietongxue.xyz/</id>
  <author>
    <name><![CDATA[nielinjie]]></name>
    <email><![CDATA[nielinjie@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Orchestration 和 Choreography]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/11/29/oc/"/>
    <updated>2015-11-29T15:01:02+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/11/29/oc</id>
    <content type="html"><![CDATA[<p>Orchestration 和 Choreography，这个两个词在跟“服务”有关的架构讨论中常有出现。比如微服务和SOA。</p>

<!--more-->


<p>如果直译的话，这两个词一个是“编曲”，一个“编舞”。</p>

<p>编曲和编舞都是编。编就是安排、设计。不论是微服务的服务还是SOA的服务，要想沟通协同，合力完成业务请求，都是需要安排设计的。</p>

<p>但二者编排的对象不同，一个是曲一个是舞。特别是，按照词的本意，这里的“曲”指的是“管弦乐曲”，是相对复杂宏大的演奏。</p>

<p>曲和舞有什么区别呢？</p>

<ol>
<li>曲需要指挥，舞不需要。乐者在演奏时，需要指挥随时指挥协调。而舞者则不需要，按照事前安排做好自己就行。需要跟其他舞者合作时，也由自己直接沟通完成。</li>
<li>曲分工复杂，舞比较简单。管弦乐曲演奏需要多种不同乐器多种不同乐者，要求彼此配合得当，才能演出成功。而舞蹈没那么多分工，即使是大型舞蹈，台上人多，但角色也就数种而已。</li>
<li>曲比较严肃，舞比较宽松。乐者的演奏和配合一丝不苟，少有随性。舞者则有较多的个人发挥空间。</li>
</ol>


<p>SOA的理念是自上而下，比较多的依赖于集中安排，运行时也需要明确的中间件进行中央控制协调。边界内有多种类型的服务，相互之间严密配合。SOA的风格类似于编曲。</p>

<p>跟SOA相比，微服务风格更类似于编舞。边界内的服务遵循简单的约定，负责一个特定的领域。他们的地位相似，实现方式和沟通方式由自己选择。</p>

<p>编曲和编舞是一种形象的比喻，并不会完全精确。架构师编排服务的时候不要照抄。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[系统要像什么？]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/11/20/system-like/"/>
    <updated>2015-11-20T10:39:55+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/11/20/system-like</id>
    <content type="html"><![CDATA[<p>系统不要像一座建筑或一台机器。</p>

<!--more-->


<p>要想办法让系统像一个生物，如能更进一步，要像一个社会。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读TOGAF（二）：ADM初瞥]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/11/17/togaf-adm/"/>
    <updated>2015-11-17T00:05:18+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/11/17/togaf-adm</id>
    <content type="html"><![CDATA[<!--more-->


<ul>
<li>ADM建议一系列的阶段和步骤。但不建议范围<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。</li>
<li>ADM是渐进迭代的。每次迭代有自己的范围，渐进产出。</li>
<li>ADM是可以调整包括裁剪的。但调整必须管理并维持。</li>
<li>ADM通过架构仓库参与到企业火锅<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。</li>
</ul>

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>架构范围包括：宽度、深度、时间范围、架构领域。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p><a href="/blog/2015/11/07/togaf/">企业火锅</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读TOGAF（一）：企业大火锅]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/11/07/togaf/"/>
    <updated>2015-11-07T00:05:18+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/11/07/togaf</id>
    <content type="html"><![CDATA[<p>Enterprise Continuum， 我称作企业大火锅。</p>

<!--more-->


<p>热气腾腾地沸着。各种物料在里面翻滚，碰撞，成熟，积累。</p>

<p>食客不用看见那么多，眼中只有这一刻的这一坨，先捞去也……</p>

<p><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<p><img src="/images/togaf/hot.jpg" width="500"></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>比喻有风险。如有跑偏，概不负责。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[架构设计过程的驱动技术（二）]]></title>
    <link href="http://www.nietongxue.xyz/blog/2015/10/28/driving2/"/>
    <updated>2015-10-28T09:06:49+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2015/10/28/driving2</id>
    <content type="html"><![CDATA[<p>模式驱动不是一种顶层的驱动技术。因为架构模式本身，严格来讲并不是对目标系统本身的分解（而特征和风险则是）。<!--more-->如果说得完整一点，应该是：“为了实现xx特征（或者控制xx风险），我们应用xx模式。”。所以模式驱动其实是在特征驱动或风险驱动之后接着应用的驱动技术。但实际很多情况下，团队只要稍微知道要设计的系统的类型，脑中已经冒出了许多模式，后续也是依据这些模式的应用来跟进，可以说淡化了原有的顶层驱动技术。</p>

<p>由于不是顶层驱动技术，模式驱动很难验证最终解决了问题，比如不能说：“由于我们使用了xx、yy、zz模式，所以我们能完成XX系统。”反过来，对于顶层的驱动技术，就可以说：“由于我们实现了所有典型的特征，所以我们能实现XX系统”，或者，“由于我们遏制了所有（发现了的）风险，所有我们能完成XX系统”。所以如果使用模式驱动，应该要回过头来，借助顶层驱动技术来验证问题的解决。从这个意义上来讲，可以说模式驱动是被顶层驱动嵌套使用的。</p>

<p>特征驱动和风险驱动分解问题时，也会频繁使用模式思维，但这不是模式驱动。比如说特征驱动，整理系统的质量需求的时候，我们常常使用一个“质量需求检查表”。其中列举了特定类型系统常见的质量需求。我们对此一一检视，判别目标系统是否有此需求。这是典型的模式思维。但这里的模式不是架构设计模式，这里也不是将目标系统分解为模式进行跟进。所以不是模式驱动的架构设计。</p>
]]></content>
  </entry>
  
</feed>
