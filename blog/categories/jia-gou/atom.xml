<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 架构 | 聂同学]]></title>
  <link href="http://www.nietongxue.xyz/blog/categories/jia-gou/atom.xml" rel="self"/>
  <link href="http://www.nietongxue.xyz/"/>
  <updated>2017-09-14T11:06:57+08:00</updated>
  <id>http://www.nietongxue.xyz/</id>
  <author>
    <name><![CDATA[nielinjie]]></name>
    <email><![CDATA[nielinjie@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[涌现中的架构（三）]]></title>
    <link href="http://www.nietongxue.xyz/blog/2017/06/25/emergence3/"/>
    <updated>2017-06-25T12:56:59+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2017/06/25/emergence3</id>
    <content type="html"><![CDATA[<p>之前有思考过研发团队发展的三个要素<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。</p>

<p>在敏捷环境中，进一步思考了三个要素和它们之间的关系。<!-- more -->如下面的图所示。</p>

<p>每两个元素之间有关系，每个关系上面有一个词。这个词说的不是关系本身。而说的是，要维持好和改善这个关系，需要思考的关键点。</p>

<p><img src="http://www.nietongxue.xyz/images/emergence/3Factor.png" width="80%"/></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>见之前的博文：<a href="/blog/2016/05/02/3h/">团队发展的三要素</a>。这个博文的视角更多的还是在团队的内部。在全局、跨团队的视角上，三个要素有一些变化。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微服务划分：按业务能力 vs 按子域]]></title>
    <link href="http://www.nietongxue.xyz/blog/2017/06/11/ms-split/"/>
    <updated>2017-06-11T16:15:44+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2017/06/11/ms-split</id>
    <content type="html"><![CDATA[<p>微服务的划分方法，常见的是两种，按业务能力和按子域<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。<!-- more--></p>

<p>“子域”，就是DDD中的"子域"。</p>

<p>“业务能力”，是一个专用名词，指的是一个连续的业务过程，其中不需要中断，也不需要别的业务过程的参与。这些业务过程自然组织起来，比如首尾相连，或者，由用户参与来自然连接。</p>

<p>两种不同的服务划分风格，反映了对业务本身的不同的描述与划分的风格。</p>

<p>比较形象地讲，按子域划分，就是把业务划成一块一块的。按业务能力划分，就是把业务划成一段一段的。一块一块的，描述业务概念和它们之间的关系。一段一段的，描述业务执行的步骤和过程。</p>

<p>按业务能力划分的优势主要在运行时。各个服务的运行时依赖被尽量减少。在服务性能、可用性方面不会相互牵绊，可以做到最好。</p>

<p>而按子域划分的优势主要在设计时和演进时。有利于应对业务的规模发展、复杂性增加和分别演进。</p>

<p>这样看来，按业务能力划分的微服务是不是类似于一种事务脚本？只不过它的粒度更大，以服务为单元？</p>

<p>是时候又贴出这张图，事务脚本的优势与劣势在图里体现得很明显，按业务能力划分的微服务，是否有同样的优势与劣势？</p>

<p><img src="http://www.nietongxue.xyz/images/domain/domain.gif" width="80%"/></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>有的观点，认为两种划分可以选择。有的观点，认为应该这样划分而不要那样划分。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linus的代码与数据结构]]></title>
    <link href="http://www.nietongxue.xyz/blog/2017/06/03/code-data/"/>
    <updated>2017-06-03T15:39:24+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2017/06/03/code-data</id>
    <content type="html"><![CDATA[<p>Linus说： &ldquo;烂程序员关心的是代码。好程序员关心的是数据结构和它们之间的关系。&rdquo;</p>

<!-- more-->


<p>代码体现的是过程。数据结构（和它们之间的关系）体现的是实体。</p>

<p>这里讲的过程和实体，都是模型，是人类思维对现实世界认知进而处理的手段。</p>

<p>相比较而言，人类对实体的掌握，似乎要优于对过程。我们觉得实体比过程更直观和易处理。</p>

<p>所以面对复杂和大规模的过程，人们借助实体，来增强认知和处理能力 -</p>

<ol>
<li>一方面，我们借助实体，对过程做分割和组合。比如卖个东西，是个复杂的过程，我们借助订单、出库单、送货单等实体，把这个过程分解为相互配合的多个过程，通过分解降低了过程的复杂性。</li>
<li>另一个方面，我们借助实体，对过程作记录和可视。比如用账目来记录经营过程，用看板来可视化生产。虽然没有直接降低复杂性，但帮助了认知和理解。</li>
</ol>


<p>以上来看，实体是我们对付世界的首选武器，即使不得不处理过程，我们也人为地引入实体来帮忙。</p>

<p>回到Linus的话，说代码与数据结构，实际上说的是程序员如何建模设计的问题。我理解Linus的意见是，多用实体，辅助过程，符合人类思维模式，是聪明的选择。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[与复杂同行（番外）]]></title>
    <link href="http://www.nietongxue.xyz/blog/2017/05/21/complex80/"/>
    <updated>2017-05-21T14:57:18+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2017/05/21/complex80</id>
    <content type="html"><![CDATA[<p>在强制家长培训中，一位小学数学的教学专家谈了一个案例 -</p>

<!--more-->


<blockquote><p>一道应用题，所有的同学都得到了它的解答算式 -</p>

<p>25*(5+7)</p>

<p>但是接下来，不同的同学就有不同的步骤 -</p>

<p>有些同学直接按照运算准则，计算 25 * 12，这是两位数乘法，小朋友无法口算，需要通过笔算竖式乘法。</p>

<p>爱思考的同学通过乘法分配律，计算 25 *5 + 25 * 7，避免了两位数乘两位数，可以口算完成，不用使用竖式。</p>

<p>更爱思考的同学计算 25 * 10 + 25*2，难度进一步降低了。</p>

<p>最爱思考的同学计算 25 * 4 *3 ，非常容易计算。</p></blockquote>

<p>这个案例谈的是，通过变换计算的路径，避免复杂计算。（当然如果有可以秒算两位数乘法的小朋友，他可能会觉得“爱思考”的同学们不太好理解。）</p>

<p>软件开发者和架构师的日常工作中，常常也会遇到这个场景。设计方案可能容易发现，但可能不容易直接执行。</p>

<p>这时候我们的办法是变换我们的设计，改善它的可执行性，包括缓解在执行环节的风险。</p>

<p>在我看来利用设计变换需要注意一些原则 -</p>

<ol>
<li>设计变换是解空间的事，尽量不要涉及问题空间，也尽量不要干扰到设计本身。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></li>
<li>设计的变换需要有明确的目的。没事不要变换。这个目的要随时验证。</li>
<li>设计的变换必须是等效的，不论怎么变，需要始终保证能解决最初的问题。</li>
<li>设计的变换在这里实质是一种折中，跟所有折中一样，需要持续管理其影响。</li>
</ol>


<p>上面几点，比较理想化。实际中，情况要复杂一些，但不影响谈原则。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>关于解空间与问题空间，见之前的文章：<a href="/blog/2016/08/14/question2/">问题空间与解空间</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[涌现中的架构（一）]]></title>
    <link href="http://www.nietongxue.xyz/blog/2017/04/04/emergence/"/>
    <updated>2017-04-04T17:43:06+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2017/04/04/emergence</id>
    <content type="html"><![CDATA[<p>之前对敏捷架构的思考和实践主要在敏捷团队内部<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。这个系列主要探讨在公司级别的敏捷架构实践。</p>

<!--more-->


<p>在实行敏捷风格架构的场景中，各个团队将按照自己的实际情况和各自对架构的理解完成架构活动。</p>

<p>作为全局架构师角色，不再进行提前的统一的架构设计。主要工作集中在对架构活动的辅导、服务和审核。</p>

<p>工作主要在几个方面 -</p>

<ol>
<li><p>架构结果不能相互抵触。</p>

<p>各团队产出各种组件，它们之间必须能够协作。各个团队的设计结果必须遵从协作协议。要么是既有的，要么是及时达成的。</p></li>
<li><p>上层结构需要持续维护。</p>

<p>跨团队的涌现架构需要一些上层结构的支持<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。团队设计的结果随时可能对高层结构产生影响，这时候需要判断这种影响是否是良性的。进而决策是鼓励还是遏制这种影响。</p></li>
<li><p>架构活动需要保持某种一致。</p>

<p>各个团队解决问题的方式需要某种程度的一致性，如果彼此相差太多，就会造成系统难以理解。对演进和传承都有不良的影响。但如果过于强调一致性，又有僵化的趋势，等于走回到计划型架构的老路。</p></li>
<li><p>架构设计有时可能需要干预。</p>

<p>敏捷和涌现的架构是我们的目标。但有些团队可能需要一些帮助才能做到。设计能力方面可能有待提高，认识理念方面可能需要统一。这些团队需要比较频密的干预和辅导。</p></li>
</ol>


<p>几个问题需要在实践中探索 -</p>

<ol>
<li><p>是否要规定架构设计的产出物？</p>

<p>可能需要某种程度的统一产出物，以便全局架构师审核和其他团队参考。</p></li>
<li><p>如何找到合适的沟通时间点？</p>

<p>架构设计会在团队间产生相互影响，当团队的节奏不同时，如何找到对彼此影响较小的时间点？</p></li>
<li><p>是否需要集中的架构研讨会议？</p>

<p>团队间的架构沟通是否可以通过一个集中的会议来减少成本？</p></li>
</ol>

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>之前总结的一个系列，时间比较久了。—— <a href="/blog/filter/filter.html?filterName=series&amp;filterValue=%E6%95%8F%E6%8D%B7%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1&amp;filterDes=Series%3A%20%E6%95%8F%E6%8D%B7%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1">Series: 敏捷的架构设计</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>后续会讨论下这些个结构，其中一个比较明显的可能是：有界上下文。之前也有博文提到过这个结构的应用。—— <a href="/blog/filter/filter.html?filterName=series&amp;filterValue=%E9%87%8D%E6%9E%84%EF%BC%8C%E4%BB%A5%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84%E4%B8%BA%E4%B8%AD%E5%BF%83&amp;filterDes=Series%3A%20%E9%87%8D%E6%9E%84%EF%BC%8C%E4%BB%A5%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84%E4%B8%BA%E4%B8%AD%E5%BF%83">Series: 重构，以知识结构为中心</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
