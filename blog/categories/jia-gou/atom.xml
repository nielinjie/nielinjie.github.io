<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 架构 | 聂同学]]></title>
  <link href="http://www.nietongxue.xyz/blog/categories/jia-gou/atom.xml" rel="self"/>
  <link href="http://www.nietongxue.xyz/"/>
  <updated>2016-09-28T21:13:40+08:00</updated>
  <id>http://www.nietongxue.xyz/</id>
  <author>
    <name><![CDATA[nielinjie]]></name>
    <email><![CDATA[nielinjie@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[分布式事务，也谈]]></title>
    <link href="http://www.nietongxue.xyz/blog/2016/09/19/transaction/"/>
    <updated>2016-09-19T17:16:43+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2016/09/19/transaction</id>
    <content type="html"><![CDATA[<p>近来有挺多文章谈“分布式事务”。
这些文章主要是从实现模式角度来谈的。比如常见的模式有哪些，哪些个模式适合哪种场景，有什么优点缺点，根据什么选择等等。<!--more-->
比如附图的这个红绿灯图，是其中的优秀代表。很有指导作用。</p>

<p>这个“也谈”<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>不重复这些，从其他角度谈一些认识。</p>

<h3>一</h3>

<p>“分布式事务”到底是什么<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>？</p>

<ol>
<li>“分布式事务”本质上是对一个过程进行管理。</li>
<li>这个过程由一些操作构成，特别是由一些有状况<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>的操作构成。</li>
<li>管理者的职责是可控地调用这些操作。特别是当某些操作出现状况时，做出决策和处置。</li>
</ol>


<h3>二</h3>

<p>为了完成管理的职责，管理者必须清楚所有操作的两方面特性：一方面，操作的状况如何获知（包括是否需要获知）。另一方面，在特定状况下，可以对操作进行何种处置。比如 -</p>

<ul>
<li>成功/失败 - 一般操作有这两种基本状况。但并不一定限于此两种。</li>
<li>超时 - 常见操作状况的一种，一般等于是状况未知。</li>
<li>回查 - 回查是获取操作状况的手段，即向操作提供者查询某笔操作是否成功。是否可回查，是操作的特性。</li>
<li>重试 - 处置的一种，即再次尝试。是否可重试，是操作的特性。</li>
<li>幂等 - 操作的特性，是可重试中的一种情况。</li>
<li>补偿 - 处置的一种，是对操作进行撤销的一种办法。</li>
<li>……</li>
</ul>


<h3>三</h3>

<p>根据操作的特性，当某些操作出现状况时，管理者可以决策和处置所有操作。决策和处置的规则，是管理者的核心知识，比如体现为决策表格 -</p>

<table>
<thead>
<tr>
<th>操作A状况 </th>
<th> 操作B状况 </th>
<th> 处置策略</th>
</tr>
</thead>
<tbody>
<tr>
<td>成功</td>
<td>失败</td>
<td> 操作A撤销</td>
</tr>
<tr>
<td>未知</td>
<td>（未尝试）</td>
<td>重试操作A</td>
</tr>
<tr>
<td>成功</td>
<td>未知</td>
<td>回查操作B</td>
</tr>
<tr>
<td>成功</td>
<td>繁忙</td>
<td>等待时间t后重试B</td>
</tr>
<tr>
<td>成功</td>
<td>已排队</td>
<td>等待时间t后回查B</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
<td>……</td>
</tr>
</tbody>
</table>


<h3>四</h3>

<p>所有常见的实现模式（比如附图的原文所列举的），都是对上述要点的实现，从不同的方面做了特殊化。-</p>

<ol>
<li>Saga模式 - 比较一般的模型。但仍然有一些特殊要求。比如操作都有反操作。</li>
<li>补偿模式 - 特殊而简化的模型，一般用于处理按顺序执行的系列操作，一旦某个操作失败，对已经成功的操作全部进行补偿。</li>
<li>TCC模式 - 特殊模型，可以做到在事务过程中外界对操作不可见，也就是做到“隔离性”，但这个特性并不是由操作的管理者带来的，而是由操作的提供者带来的。通过将一个普通的业务操作分拆为相关联的两个，操作提供者实现了操作对外部的不可见。两个操作之间需要一个状态的维护。</li>
<li>可靠事件模式 - 特殊模型，该模式重点不在管理，而在管理者调用操作的途径。这个途径的特点是底层机制决定了管理者可以假定操作总会成功（或者说就当它都成功了）。所以对过程的管理就可以比较简单了。管理者不再需要处理操作状况的可知、操作的重试、撤销等问题。</li>
<li>两段、三段提交模式 - 不谈了。</li>
</ol>


<p>（待续，接下来也许尝试建立一个实现模型。）</p>

<p><img src="/images/transaction/transaction.jpg" width="500"></p>

<p>原文：<a href="http://www.open-open.com/lib/view/open1473404638516.html">分布式事务：不过是在一致性、吞吐量和复杂度之间，做一个选择</a></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>强行音译为Yet Another，嗯，听起来还蛮像的。😂<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>貌似通篇也适合“不分布”式事务。<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>“状况”，我自己选择的词汇，区别于“结果”，比如1+1的操作，2（或者3）是“结果”，做完了或者没做完或者不愿意做是“状况”。<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[问题空间与解空间]]></title>
    <link href="http://www.nietongxue.xyz/blog/2016/08/14/question2/"/>
    <updated>2016-08-14T20:29:27+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2016/08/14/question2</id>
    <content type="html"><![CDATA[<p>问题空间与解空间<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，体现了思考的一般过程，所以在很多方法论中有所表现。</p>

<!--more-->


<p>“设计思维”讲到4D过程，Discovery、Define、Design、Delivery。 其中Discovery、Define就是在研究和结构化问题空间，而Design、Delivery则分别是解决问题和归纳整合，属于解空间。</p>

<p>领域驱动设计方法中，子域与上下文是两个看来近似的概念。其实子域在问题空间，是对领域这个大问题的分解，而上下文在解空间，是对子域的解决。研究上下文的关系，则是在归纳整合，使这些解决能互相融洽，共同解决领域这个大问题。</p>

<p>有一类问题，难点和重点在于分析和分解问题，解决问题倒是比较容易。针对这类问题的方法，自然是强调研究问题空间。</p>

<p>威胁建模方法，是一个很好的例子。数据流图，信任空间，STRIDE模型，都是研究问题空间的方法。找到了可能的威胁之后，还要对威胁进行评估排序，这些都是在问题空间。到最后才谈到解空间，也就是如何解决威胁。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>在<a href="/blog/2016/08/13/question/">前一篇</a>中首先提及。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[架构设计过程的驱动技术（三）]]></title>
    <link href="http://www.nietongxue.xyz/blog/2016/08/13/question/"/>
    <updated>2016-08-13T20:29:27+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2016/08/13/question</id>
    <content type="html"><![CDATA[<p>特征驱动和风险驱动，看来是相对完备的驱动技术；模式驱动，则不是那么完备。
这两类驱动技术的区别究竟从何而来呢？</p>

<!--more-->


<p>大部分人思考问题，特别是比较复杂的问题的过程。分为两个步骤 -</p>

<ul>
<li>第一个步骤，分析问题，定义问题，分解问题，将大问题、复杂的棘手的问题，分解为小的可解决的子问题。这个步骤，我们称为处理问题空间。</li>
<li>第二个步骤，对第一个步骤得到的子问题分别解决，并将所有答案归纳整合，使之可以解决最初的复杂问题。这个步骤，我们成为处理解空间。</li>
</ul>


<p>两个步骤如下图所示。图中ABCD步骤，就是处理问题空间，步骤EFGH则是处理解空间。</p>

<p>显然，模式驱动没有覆盖第一个步骤，只覆盖了第二个步骤。而特征驱动和风险驱动，覆盖了第一第二两个步骤。其中，特征驱动认为实现特征就是我们面对的大问题，提供了分析分解这个大问题的办法，这些方法都是作用于问题空间的方法。而风险驱动认为应对风险就是我们的大问题，提供了定义风险衡量风险等在问题空间方法。</p>

<p><img src="/images/question/question.png" width="500"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FAQ：应用架构与技术架构]]></title>
    <link href="http://www.nietongxue.xyz/blog/2016/05/28/avst/"/>
    <updated>2016-05-28T17:15:59+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2016/05/28/avst</id>
    <content type="html"><![CDATA[<p><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>应用架构产出结构。技术架构产出技术。</p>

<p>应用架构的职责是产出并维护一个合理健康的结构。而技术架构所产出技术，则被用作支持这个结构的手段。技术就是手段。</p>

<!--more-->


<p>技术的进化有时候会直接导致结构的变革，这就是技术驱动的团队的情况。而其他情况，可能是大部分情况，技术是在结构的框架和需求中发展。</p>

<p>大部分的团队的技术，来自于“选型”，即从已有技术选择适合自己的，而这个“适合自己”，最重要的标准之一就是适合自己的结构。</p>

<p>技术是局部的，而结构是广泛的。但局部与广泛是相对的。在更宏观层面来看，更微观的结构可能就是技术。任何一项局部技术，它的存在和种种特性，可能需要复杂和高妙的内部结构来支撑。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>通篇以一名应用架构师的视角。我肯定别的架构师有他们自己的看法。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重构，以知识结构为中心（四）]]></title>
    <link href="http://www.nietongxue.xyz/blog/2016/04/16/dev-dc4/"/>
    <updated>2016-04-16T11:10:01+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2016/04/16/dev-dc4</id>
    <content type="html"><![CDATA[<p>为了帮助领域团队凝聚和守护领域知识，我们设计和使用了一些工具。</p>

<!--more-->


<h3>领域模型</h3>

<p>最首要的工具当然是领域模型。但从零开始建立一个有些远水解不了近渴。
我们的想法是识别一点建立一点使用一点，持续地延伸和细化。</p>

<p>当前是划分上下文、区别领域与应用、建立团队的阶段，我们关注点就在上下文之间的边界上和领域与应用的边界上。
那么我们就以上下文之间的边界处和领域与应用之间的边界处作为我们领域模型建立的起点。</p>

<h3>领域边界跟踪表<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h3>

<p>上下文之间的关系非常重要，关系到知识的依赖类型，也关系到领域团队间的沟通和协作。所以我们特别关注厘清边界处的概念和它们的属主。</p>

<p>团队认识到的边界，往往描述为领域之间的交互场景。这时候需要从中提炼出业务概念和规则。一般以领域实体和领域事件为代表。</p>

<h3>应用差异跟踪表</h3>

<p>领域团队职责是维护业务的一致性。
这要求领域团队除了控制领域知识以外，对领域知识的各种应用形式必须有足够的认识和应对。
这一点在当前领域与应用的边界尚未完全明确的情况下尤为必要。</p>

<p>我们的切入点是总结应用形式之间的差异并制定对差异的应对策略<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。</p>

<p>（还有一些其他层面的工具，待续）</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>“领域边界”其实是上下文边界的俗成说法，老司机也阻止不了——上下文这个名词确实不够简明。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p><a href="/attachment/app-diff.html/">《领域知识在各应用的形态差异及如何处理》（已打码）</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
