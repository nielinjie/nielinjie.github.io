<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 架构 | 聂同学]]></title>
  <link href="http://nielinjie.github.io/blog/categories/jia-gou/atom.xml" rel="self"/>
  <link href="http://nielinjie.github.io/"/>
  <updated>2014-06-16T19:49:19+08:00</updated>
  <id>http://nielinjie.github.io/</id>
  <author>
    <name><![CDATA[nielinjie]]></name>
    <email><![CDATA[nielinjie@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[给老爷爷系统（八）：特征机制]]></title>
    <link href="http://nielinjie.github.io/blog/2014/06/16/feature/"/>
    <updated>2014-06-16T21:06:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/06/16/feature</id>
    <content type="html"><![CDATA[<blockquote><p>这是一个老爷爷系统。</p></blockquote>

<p>在《<a href="/blog/2013/09/01/dsl1/">一场似非而是的DSL</a>》和《<a href="/blog/2014/06/16/3d">三个划分维度</a>》中，
已经提到了“特征机制”。这里专门讲一下。</p>

<!-- more -->


<p>“特征机制”，是一种动态选择机制，用来协同“通用”和“专用”两个层次。
当通用逻辑运行到某个点，需要执行专用逻辑，我们首先需要找到正确地专用逻辑。</p>

<ul>
<li>我们把通用逻辑中需要运行专用机制，也就是可能发生扩展的点，称为“扩展点”。</li>
<li>不同的“差异来源”带来不同的“业务差异”，通过在扩展点上填入适当的“扩展”来实现差异化的专用逻辑。</li>
<li>所谓“特征”，就是一条知识，描述了当在何种“业务差异”的处理中，需要在哪些个扩展点填入哪些个“扩展”。</li>
<li>所谓“特征机制”，就是当系统运行到一个扩展点的时候，查找到正确的特征，填入正确的扩展并运行的机制。</li>
</ul>


<p>特征机制的实现在设计上有意识地做到“操作层”和“知识层”分离，以便二者能够分别进化，这点在《<a href="/blog/2013/09/01/dsl1/">一场似非而是的DSL</a>》已经说明了。</p>

<p>下面的图体现了上面这些概念的静态关系。除了主干之外，枝节也说一下：</p>

<ul>
<li>“业务差异”需要一个载体，就是“特征拥有者”，比如“签报”、“用户”等领域对象都可以是特征拥有者，这些拥有者的属性导致了差异。</li>
<li>同一个拥有者的特征可能来源于不同的差异，其中有可能会相互影响甚至冲突，这时候需要一个裁决者，这就是“特征集”。</li>
<li>“特征要求”是拥有者的属性与特征之间的映射，体现为“业务属性”和“业务事件”。</li>
<li>特征由特征要求决定，可以在需要特征时刷新，也可以当“业务属性”改变或“业务事件”发生时刷新。</li>
</ul>


<p><img src="/images/feature/feature2.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给老爷爷系统（七）：三个划分维度]]></title>
    <link href="http://nielinjie.github.io/blog/2014/06/16/3d/"/>
    <updated>2014-06-16T20:06:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/06/16/3d</id>
    <content type="html"><![CDATA[<blockquote><p>这是一个老爷爷系统。</p></blockquote>

<p><a href="/blog/2014/06/09/refactory">前一篇</a>提到，
为了应对复杂性，对代码按“领域”进行划分。</p>

<!-- more -->


<p>这个维度的划分不强调层次，而强调聚合<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。
根据领域概念的相关性联系在一起，比如跟“用户”这个领域概念有关的代码放在一处，跟“流程”有关的代码放在一处。
而跟“（用户）授权”有关的代码放在一处，这一处靠近“用户”而远离“流程”。</p>

<p>另一个维度，这个系统（和其他很多系统一样）历来就有从框架“职责”方向的划分，
比如代码分为Action、Controller、Service、BO、DAO等等。整理了一下，
从上到下，分为三个层次：表现层、业务层、基础设施层，其中业务层，又分为功能层和领域层。
跟上个维度不同，这个维度上，层次是有明显意义的。
上一层一般只能调用下一层或者同一层的逻辑。</p>

<p>逐步的我们发现，我们需要另一个划分。我们的系统是企业办公系统，
除了“通用”逻辑以外，我们有很多“专用”的逻辑，这些“专用”逻辑贯穿在整个业务逻辑中，
比如不同的专业公司、不同的地域，对某些功能有不同的要求。（这些带来业务逻辑差异的因素，称为“差异来源”。）
这些逻辑如果在实现时简单直接，就会有很多“专用”代码，“弥散”在整个系统中。
坏处很明显：</p>

<ul>
<li>专用逻辑分散，很难管理和进化。</li>
<li>通用逻辑跟专用逻辑纠缠，增加了不必要的复杂度。</li>
</ul>


<p>于是我们明确了第三个维度的划分，在这个维度上，系统划分为“通用”、“专用”两个层次。</p>

<p>下面的第一个图，体现了三个维度的划分情况。</p>

<p>第二个图，重点描述了第三个维度的划分。
左边是没有第三维度划分时的情况，不同差异来源的专用逻辑，在不同的领域，无规律地散乱着。
右边是按照第三维度划分后的情况，下层是通用逻辑。上层是专用逻辑，按照不同的差异来源，不同的领域，有序分布。
至于协同两个层次的机制，称为“特征机制”，将在<a href="/blog/2014/06/16/feature">下一篇</a>中阐述。</p>

<p><img src="/images/3d/3d.png"></p>

<p><img src="/images/feature/feature.png"></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p><a href="/blog/2014/06/07/structure">结构的要素</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给老爷爷系统（六）：重构（二）]]></title>
    <link href="http://nielinjie.github.io/blog/2014/06/11/refactory2/"/>
    <updated>2014-06-11T20:06:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/06/11/refactory2</id>
    <content type="html"><![CDATA[<blockquote><p>这是一个老爷爷系统。</p></blockquote>

<p>还是一篇补记，主要讲讲为什么是重构而不是重写。</p>

<!-- more -->


<p>同事们喜欢重写系统，好多别的老爷爷老态龙钟之后都是被重写的。
我们选择重构不重写的原因主要有三点：</p>

<ul>
<li>代码具有高价值，是可用和满足需求的。重写就意味着要放弃这些价值。</li>
<li>没有现成的需求。由于开发年代久远，人员流动，而用户也非常分散，没有人能告诉我们需求。
唯一可能的就是通读代码，反推出需求。这样做，无疑是成本高，风险大。</li>
<li>能否解决代码系统腐化根源？这一点其实是我们考虑的重点。重写容易，
如何防止重写的系统再次变坏，却不是件简单的任务。
我们认为在重构代码的过程中，可以教育和锻炼团队，通过寻找让系统变好的方法，来掌握防止或缓解系统变坏的手段。
这样不仅让本系统的情况好转，也可以给其他正在或即将变坏的系统提供借鉴。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给老爷爷系统（五）：重构（一）]]></title>
    <link href="http://nielinjie.github.io/blog/2014/06/09/refactory/"/>
    <updated>2014-06-09T20:06:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/06/09/refactory</id>
    <content type="html"><![CDATA[<blockquote><p>这是一个老爷爷系统。</p></blockquote>

<p>这是一篇补记，说的是在刚刚接手老爷爷系统的时候。</p>

<!-- more -->


<p>系统老不是问题，老而失控才是问题。我们的老爷爷系统就遇到了老而失控的问题。</p>

<p>系统腐化、大泥球，讲的大概都是一个意思：需求不停、补丁重重、代码堆积、逻辑纠缠。
随便一个小改动，都如履薄冰，面对着巨大的复杂性。越来越复杂、越来越纠缠，
慢慢地（应该说是很快地 &ndash;_&ndash;!!）接近了凡人能处理的极限。</p>

<p>我们研究了代码的结构和历史，发现主要问题是按照“功能”来安置代码，逻辑都放在一个功能入口的纵切面上。
以我们这个系统的具体情况<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>来说，这个纵切面，就是一条线：Controller → Service → DAO。
所有的代码，都分布在这条线上。
整个类似于Transaction Script模式。Transaction Script本身难说有什么问题，问题是这个模式只能面对比较小规模的领域逻辑，
当领域逻辑复杂度增加的时候，Transaction Script模式就难堪重任了。问题体现出来主要在两个方面：</p>

<ul>
<li>补丁：当一个功能涉及到的领域逻辑越来越多时，功能的代码上就依附了各种各样的领域逻辑代码。比如审批一个单据，逐渐贴上了用户授权、时效检查等等代码，如果“审批”功能本身修改，就得面对成倍增加的复杂性。</li>
<li>碎片：同一类的领域逻辑，由于在各个功能都要使用，代码就被分散到了各个功能的代码里面。比如上面说的“用户授权”，在多个功能的代码里都有分布，一旦需要改动，得从各个功能中找出来一一修改，复杂性可想而知。</li>
</ul>


<p>应对的办法是什么呢？简单两个字——划分。</p>

<p>我们的划分标准选择的是领域相关程度。
关于“用户”的代码集中在一起，关于“时效”的代码也集中在一起。
甚至“功能”的主要代码，也按照领域相关程度来放入不同的区域，
比如“审批”、"退回"都是一种对单据的状态流转，它跟为单据设置“审批人”就不是同一类，不放在一起。
而功能入口的纵切面上，只有调用这些代码的代码。</p>

<p>需要说明一下的是我们这里说“划分”的标准是“领域”，这个跟“领域驱动设计（DDD）”并没有太大关系，
大家不要搞混了。
我们的目的只是“划分”。</p>

<p>（<a href="/blog/2014/06/11/refactory2">下篇继续</a>）</p>

<p><img src="/images/refactory/refactory.png"></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>系统采用类似SpringMVC的一个定制框架。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给老爷爷系统（四）：如何描述系统？（三）]]></title>
    <link href="http://nielinjie.github.io/blog/2014/06/07/view3/"/>
    <updated>2014-06-07T18:06:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2014/06/07/view3</id>
    <content type="html"><![CDATA[<blockquote><p>这是一个老爷爷系统。</p></blockquote>

<p>这一篇讲讲如何实现的问题。</p>

<!-- more -->


<p>实现方面主要考虑了两个要点：</p>

<ul>
<li>如何构建和维护：要快速地建立和编辑，能够加入版本管理，能够在各方面间共享。</li>
<li>如何展现：各方面要容易地挂载自己的关注点数据，同时跨角色观察的需求要求框架能同时挂载多方面的数据。</li>
</ul>


<p>我们为这两个要点选择了两种不同的形式。</p>

<p>一方面在构建和维护时，特征描述采用纯文本方式，可以说是一种简单地DSL。
DSL文件很方便人和机器阅读，同时放入SCM，实现版本管理和角色间共享。</p>

<p>```
审批/逐个审批</p>

<pre><code>-i 查看签报详细信息
-i 输入审批意见
    -g 使用默认意见
    -g 手工输入意见
    -g 语音输入意见
-i 选择用户
签报
用户
</code></pre>

<p>批量审批</p>

<pre><code>-e 逐个审批
-i 查看待处理文件列表
-i 点击审批按钮
</code></pre>

<p>……
```</p>

<p>另一方面在展现时，我们解析DSL，图形化交互式（并且略显炫酷滴 :-D）地展示。
下面展示的是目前的状况。</p>

<ul>
<li>左边的图，是“系统特征”，由黄色椭圆形表示的领域过程、绿色圆形表示的领域实体，以及他们之间的连线构成。</li>
<li>右边的下拉菜单，是由各方面提供的关注点数据，可以按需要附加到“系统特征”上。比如这个截图上，
左边的图上面有个红色的大圆，就是将代码质量数据叠加上来。还有个深绿色的小点，是将代码结构的数据叠加上来。</li>
<li>除了可以以叠加的方式展示数据，还可以根据关注点数据对图进行过滤。</li>
</ul>


<p><img src="/images/view/view3.png"></p>

<p>最后，代码在此：<a href="http://github.com/nielinjie/developTools">http://github.com/nielinjie/developTools</a></p>
]]></content>
  </entry>
  
</feed>
