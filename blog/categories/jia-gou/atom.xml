<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 架构 | 聂同学]]></title>
  <link href="http://nielinjie.github.io/blog/categories/jia-gou/atom.xml" rel="self"/>
  <link href="http://nielinjie.github.io/"/>
  <updated>2015-06-03T00:24:10+08:00</updated>
  <id>http://nielinjie.github.io/</id>
  <author>
    <name><![CDATA[nielinjie]]></name>
    <email><![CDATA[nielinjie@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[节选译：迁移至云架构（四）]]></title>
    <link href="http://nielinjie.github.io/blog/2015/06/02/cloud4/"/>
    <updated>2015-06-02T11:15:31+08:00</updated>
    <id>http://nielinjie.github.io/blog/2015/06/02/cloud4</id>
    <content type="html"><![CDATA[<p>原文：<a href="http://pivotal.io/platform-as-a-service/migrating-to-cloud-native-application-architectures-ebook">Migrating to Cloud-Native Application Architectures</a></p>

<p>本文为”节选译“，不是逐句逐段翻译，是意译和无废话译。</p>

<p>（<a href="/blog/2015/05/29/cloud3/">接前文</a>）</p>

<!--more-->


<h2>组织转变</h2>

<p>这一节我们将讨论为了更好地应用云架构，组织在建立团队方面将如何改进。这个理论的背后是著名的<em>Conway’s Law</em>，我们的办法是围绕一个长期的产品线建立多职责的团队，而不是鼓励每种职责的人员呆在自己单独的团队里（比如testing）。</p>

<h3><a name="bct"></a>业务能力<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>团队</h3>

<blockquote><p>任何组织设计的产品，它的设计结构都跟组织的交流结构一致。—— Melvyn Conway</p></blockquote>

<p>我们已经讨论了把IT划分为竖井的做法。自然地，这时我们也把每个人放进了这样的竖井里。那么我们来看看需要开发一个新软件时会发生什么。</p>

<p>通常的做法是建立一个项目团队，指定一名项目经理。然后项目经理会跟各个竖井打交道，获得项目所需的各种人员。从上面引用的<em>Conway’s Law</em>我们会看到，这种团队自然就产出了类似竖井结构的架构：</p>

<ul>
<li>数据操作层</li>
<li>服务层</li>
<li>Web MVC 层</li>
<li>消息层</li>
<li>……</li>
</ul>


<p>这些层次横亘在各个业务能力间，各个业务能力要想不影响其他地创新和落地，变得比较困难。</p>

<p>很多公司想要迁移到云架构，比如按业务能力划分微服务。他们应用的是Thoughtworks所谓的
<a href="http://www.thoughtworks.com/radar/techniques/inverse-conway-maneuver">“反Conway策略”</a>。不是按组织结构来决定架构，而是反过来，按照想要的架构来重新调整组织架构。按照Conway的观点，只有这样，你想要的架构才会最终出现。</p>

<p>所以，作为迁移到DevOps文化的一部分，团队跨职责并按照业务能力来组织，他们开发产品而不是项目。产品是长期存在的，直到他们不再具有业务价值。交付一个业务能力需要的人员都在一个团队中——开发、测试、发布、运营，代码不需要在各个团队间传来传去。这种团队往往也叫“<a href="http://www.fastcompany.com/50106/inside-mind-jeff-bezos">两个披萨团队</a>”，也就是说如果两个披萨不够这个团队分，那这个团队就太大了点。</p>

<p>现在我们来看如何决定要建立什么团队。如果我们遵从“反Conway策略”，我们将从组织的领域模型开始，找到能够封装在“界限上下文”<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>里地业务能力。一旦确定了这些业务能力，我们就建立相关的业务能力团队，负责这个业务能力的整个生命周期，同时也负责从开发到运营的整个循环。</p>

<h3><a name="pt"></a>平台团队</h3>

<p>业务能力团队依赖于“敏捷的自助基础设施”<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>。实际上，我们可以定义一个业务能力，叫做“可以开发、部署、运营业务能力的业务能力”。这个能力由平台团队负责。</p>

<p>平台团队根据业务能力团队的要求运营着“敏捷的自助基础设施”。如果公司自己运行云平台，那平台团队需要负责数据中心和了解硬件。</p>

<p>IT运营往往通过各种ticket系统与客户交互。但平台团队运营的是“自助”的平台，它要以不同的方式交互。就像业务能力团队通过API合同跟其他团队协作，平台团队也为平台定义一套合同。业务能力团队不是将环境和数据请求放到等待队列等待实施，而是请求并获得一个自动发布管道，需要的时候能够自行处理环境和数据。</p>

<h2>技术转变</h2>

<p>现在我们来看看迁移到云中的DevOps可能遇到的实现问题。</p>

<h3>分解巨大<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>架构</h3>

<p>传统的n层巨大架构部署到云基础设施很难运行得好。因为它们往往就运行环境做了一些假设，然而云基础设施并不支持，比如：</p>

<ul>
<li>mount好的共享文件系统</li>
<li>P2p的应用服务集群</li>
<li>共享运行库</li>
<li>已知位置的配置文件</li>
</ul>


<p>这些假设都基于这种架构的应用被部署在长期存在的基础设施上，它们跟云基础设施弹性短期的想法并不兼容。如果应用并没有这些环境假设呢？还是有问题：</p>

<ul>
<li>巨大架构将所有业务能力的变化绑在一起，不利于各个业务能力的创新分别落地。妨害了创新的快速。</li>
<li>巨大架构中的服务很难单独伸缩，负载效率难以提升。</li>
<li>新加入组织的员工难以适应，他们需要学习整个领域和大量的代码，没有几个月的时间，他们很难成为真正有效率的开发人员。</li>
<li>开发组织通过增加人员来扩大规模很难，增加沟通和协作的成本。</li>
<li>技术栈长期不变，引入新技术风险较大。</li>
</ul>


<p>以上清单正好是“微服务”<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>的优势清单逐条反过来（<s>我Kao</s>）。同时，将组织划分为业务能力团队，也要求将巨大架构分解为微服务。只有这样，才能充分享有我们迁移到云基础设施的好处。</p>

<h3><a name="dd"></a>分解数据</h3>

<p>分解巨大架构并不足够。数据模型也需要分解。如果业务能力团队看似自治但却被限制在同一个数据上协作，巨大架构对创新的阻碍只不过搬到了数据层面而已。</p>

<p>DDD认为<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>我们的成功很大程度上依赖于我们的领域模型的质量。领域模型只有内部一致才能有用，同一个模型中不应该有不一致的概念和词汇。</p>

<p>要产出一个大一统的领域模型非常困难和昂贵，甚至是不可能的。Evans根据内部一致的子集来划分领域，称为“界限上下文”。</p>

<p>最近在跟航空业的客户合作时，我们讨论了几个他们业务的核心概念。比如“预定”，我们能在相关业务中找出十七个不同的定义，显然它们不能看做是同一个概念。相反，每个定义都是有细微差异的不同概念。这成为了组织的瓶颈。</p>

<p>界限上下文允许我们在组织范围保留不一致的定义，同时在单个上下文里面保持一致。</p>

<p>我们开始识别哪些能够内部一致的领域模型片段。我们在这些片段的周围画出边界，这就成了我们界限上下文。这样我们就能把我们的业务能力团队对应到界限上下文，这些团队将产出对应的微服务。</p>

<p>微服务的定义又指导了需要哪些十二因子应用。十二因子主要是技术上的规范，而微服务主要是业务上的规范。我们定义界限上下文，赋予之业务能力，围绕业务能力建立团队，让团队开发十二因子应用。由于这样的应用都是独立可部署的，使得业务能力团队有更多的技术手段可用。</p>

<p>我们将界限上下文与“每服务每数据库”模式关联，也就是每个微服务封装、管理和保护它们自己的领域模型和数据存储。在这个模式中，只有一个应用服务可以访问它的数据存储（可能是一个多租户数据库集群中的一个schema，也可以是一个独占的物理数据库）。任何外部访问只能通过API合同（经常是REST，但是可以是任何协议）。</p>

<p>这种分解使应用可以根据自己的数据特征选择不同的数据存储，比如数据结构和数据读写模式。另一方面，为了能回答一些跨上下文的问题，数据通过事件驱动技术重新组合起来。比如<a href="http://martinfowler.com/bliki/CQRS.html">CQRC</a>和<a href="http://martinfowler.com/eaaDev/EventSourcing.html">event sourcing</a>就常常用来实现跨上下文将相似概念同步起来。</p>

<h3>容器化</h3>

<p>容器镜像（比如由<a href="https://linuxcontainers.org">LXC</a>、<a href="https://www.docker.com">Docker</a>、<a href="https://github.com/coreos/rkt">Rocket</a>准备的）正在迅速成为云架构的部署单元。这些镜像也迅速得到了调度工具的支持，比如Kubernetes、Marathon、 Lattice。公有云提供商比如Amazon和Google也提供了基于容器的调度和部署服务。容器技术提供了跟虚拟机相似的资源分配和隔离，同时相对来说大大地轻量和易移植。应用开发者要尽快适应将应用打包为容器镜像，以便能享有现代云基础设施带来的便利。</p>

<h3>从奏乐到舞蹈<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup></h3>

<p>不仅仅服务产出、数据模型和管理应该去中心化，服务的集成也应该去中心化。企业中服务集成传统上使用类似ESB。ESB就成为了服务间交互的所有决策的控制者，包括路由、传输、协议、安全等。我们称为“奏乐”，类似于指挥决定了整个音乐的演奏进程。ESB和奏乐模式使得架构图显得非常简单，但不幸的是这种简单性具有欺骗性。ESB中经常隐藏着一张复杂性的网。管理这种复杂性非常费时，跟它一起工作也成为了应用开发团队的瓶颈。就像我们谈到的大一统的数据模型一样，大一统的服务集成也成为了追求快速的绊脚石。</p>

<p>在云架构中，比如微服务，我们倾向于“舞蹈”，类似于芭蕾舞。不是把精力放在集成机制，而是放在各个节点。当舞台上发生了跟原计划不符的异常情况，并没有一个指挥来告诉舞者该怎么做，而是舞者自己适应。类似的，我们的服务也是自己适应他们运行环境中出现的异常情况，比如通过“客户端负载均衡<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup>”和“断路器<sup id="fnref:9"><a href="#fn:9" rel="footnote">9</a></sup>”。</p>

<p>虽然架构图看上去趋向于一张纠结的网，但其复杂性并不超过传统的SOA。舞蹈模式只是承认和暴露了系统本质的复杂性。这个转变同样是为了支持自治进而实现云架构快速地目标。团队可以迅速应对各种情况，不必与其他团队过多协作，也不用疲于跟ESB打交道。</p>

<h2>总结</h2>

<p>以下为译者自己总结的 :&ndash;)</p>

<ol>
<li>文化转变：DevOps、持续交付、自治</li>
<li>组织结构转变：业务能力团队、平台团队</li>
<li>技术转变：分解服务、分解数据、容器化、分解集成</li>
</ol>


<p>（后文继续，迁移指南）</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>business capability<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>bounded contexts，在“<a href="#dd">分解数据</a>”中讨论<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p><a href="/blog/2015/05/23/cloud2/#ai">前面已经提到</a>。<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>Monolith<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
<li id="fn:5">
<p><a href="/blog/2015/05/23/cloud2/#ms">微服务</a>。<a href="#fnref:5" rev="footnote">&#8617;</a></p></li>
<li id="fn:6">
<p>书：<em>Domain-Driven Design</em>，作者Eric Evans<a href="#fnref:6" rev="footnote">&#8617;</a></p></li>
<li id="fn:7">
<p>从Orchestration到Choreography<a href="#fnref:7" rev="footnote">&#8617;</a></p></li>
<li id="fn:8">
<p>路由和负载均衡（链接待建）<a href="#fnref:8" rev="footnote">&#8617;</a></p></li>
<li id="fn:9">
<p>错误容忍（链接待建）<a href="#fnref:9" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[节选译：迁移至云架构（三）]]></title>
    <link href="http://nielinjie.github.io/blog/2015/05/29/cloud3/"/>
    <updated>2015-05-29T11:15:31+08:00</updated>
    <id>http://nielinjie.github.io/blog/2015/05/29/cloud3</id>
    <content type="html"><![CDATA[<p>原文：<a href="http://pivotal.io/platform-as-a-service/migrating-to-cloud-native-application-architectures-ebook">Migrating to Cloud-Native Application Architectures</a></p>

<p>本文为”节选译“，不是逐句逐段翻译，是意译和无废话译。</p>

<p>（<a href="/blog/2015/05/23/cloud2/">接前文</a>）</p>

<!--more-->


<h1>需要转变</h1>

<h2>文化转变</h2>

<h3>从竖井到DevOps</h3>

<p>企业IT常常被组织为一些竖井：软件开发、QA、DBA、系统管理、运营、发布管理、项目管理等。这些竖井往往有不同的管理层次、工具集、沟通方式、词汇和激励形式。这些不同鼓励了做事方法的不同。</p>

<p>一个常被提到的例子是开发和运营的不同。
开发的任务是开发功能，往往是通过向企业IT中引入更改来实现的。所以开发部门的任务可以说成是“交付变化”，自然开发部门也往往是鼓励交付更多的变化。</p>

<p>另一方面，运营的任务则可以说是“防止变化”，运营的任务是保持可用性、弹性、性能和持久性。他们往往被鼓励保持KPI，比如平均错误间隔，平均恢复时间等。然而对于保持这些指标来说，最大的风险就是引入变化。结果就是，运营经常不是想办法怎么安全地引入开发期望的变化，而是想办法把让引入变化更痛苦，从而降低变化的频率。</p>

<p>这种不同的做事方法显然带来了低效的合作。协作、沟通、交接工件变得非常乏味和痛苦，甚至是混乱和危险。企业IT往往企图修复这种状况，构建了通过ticket系统和会议驱动的重流程。结果是工作变得更加慢和浪费了。</p>

<p>像这样的环境跟云架构快速的理念完全相左。竖井诞生的原因，往往是希望带来更多地稳定和安全，但实践证明，作用甚微，甚至有时候会带来反作用。</p>

<p>DevOps的核心就是打破这样的竖井。构建共享的工具、词汇和沟通结构，建立文化，为着同一个目标：快速安全地实现价值。围绕这一目标建立激励机制。官僚机构和流程被信任和责任心取代。</p>

<p>届时，开发和运营向同一个直接领导负责，共同寻找办法，既能持续产出价值，又能保持可用性、弹性、性能和持久性。现在发现，云架构相关技术能够为之提供支持。</p>

<h3>从Punctuated Equilibrium<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 到持续交付</h3>

<p>企业往往引入了敏捷过程，比如Scrum，但一般限于开发团队。</p>

<p>我们已经相当成功地将单个的开发团队变得敏捷。我们做了很多改进：结对编程、测试驱动开发，持续集成……，我们已经能很高效地完成“从用户故事到Demo”的循环。但我们的问题是：<em>功能什么时候能上生产呢？</em></p>

<p>这个问题我们很难回答，它迫使我们考虑一些我们不能控制的因素：</p>

<ul>
<li>QA流程需要多少时间？</li>
<li>我们啥时候能加入版本计划？</li>
<li>什么时候运营能准备好环境？</li>
</ul>


<p>这时候我们意识到我们陷入了“<a href="http://sdtimes.com/analyst-watch-water-scrum-fall-is-the-reality-of-agile/">Water-Scrum-fall</a>” ，我们的团队已经开始敏捷了，但我们的组织还没有。结果，我们每个迭代的成果并不能体现到生产部署，代码其实还堆积在传统的发布循环中。</p>

<p>这种工作模式实际上抹杀了敏捷的两个关键好处。</p>

<ul>
<li>客户仍然要隔好几个星期才能看到新东西，感觉不到敏捷的好处，所以并不能如约与开发团队建立信任关系。他们倾向于回到老的工作方式：把尽量多的需求都塞到版本里——由于他们不太相信软件能够快速发布，于是宁愿最后好不容易发布的时候能多交付点东西。</li>
<li>开发团队可能要好几周才能得到真正的反馈。Demo是很不错，但开发人员都知道，只有真正的用户使用了真正的生产软件，才能产生好的反馈。这样的反馈才能提供有效的修正，团队才能真正做到“build the right thing”。如果反馈延迟了，错误堆积起来，返工的成本就很高。</li>
</ul>


<p>想要得到云架构的好处就需要转变到持续发布。</p>

<p>技术上我们可以做到每个迭代（甚至每次代码提交）自动部署到生产。我们建立部署管道，在此执行自动测试，防止生产问题。现在唯一需要做的是业务决策：现在是否是发布新特性的好的业务时机？由于部署管道是全自动的，业务决策好后可以一键实施。</p>

<h3>从中央集权到分散自治</h3>

<p>Water-Scrum-fall文化中有一点值得特别指出，因为我感觉是使用云的过程中的一个绊脚石。</p>

<p>企业经常围绕应用架构和数据管理建立中央集权组织，负责维护守则和标准、审批设计和更改。中央集权确实有几点帮助：</p>

<ul>
<li>可以防止技术栈的不一致。降低组织的维护总成本。</li>
<li>可以防止架构选择的不一致。</li>
<li>合规管理之类的Cross-cutting concerns可以在组织内保持一致。</li>
<li>数据的所有权可以一目了然。</li>
</ul>


<p>这些组织建立起来是为了提高质量和降低成本。但收效甚微。同时还影响了云架构在快速方面的努力。巨大架构可能成为技术创新的瓶颈，巨大单一的管理组织也一样。有时候一个小的变化只需要几分钟就能完成，而且也肯定会通过评审，但却需要很长时间来等待评审会议的召开。</p>

<p>使用云架构几乎总是伴随着去中心集权。开发云架构应用的团队（“Business Capability Teams”<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>）几乎拥有了交付所需要的所有的能力。他们拥有数据管理、技术栈、架构、每个部件的设计以及API合同。如果有什么决定需要做，那就是这个团队就能做了。</p>

<p>去中心和自治的团队通过集成模式规定的机制来制衡，这些机制存在于团队开发的服务之间，通常很小很轻。（比如使用HTTP REST JSON风格的API，而不是各不相同的RPC接口。）这些机制通常最先出现在基层，用来解决一些共有问题，比如“错误容忍”。我们鼓励各团队自己设计解决方案，然后自组织地与其他团队一起形成公用的模式和框架。如果出现了对整个组织都好用的模式和框架，那么就将这些模式、框架转交给“云工具、框架团队”。工具框架团队可以是平台团队<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>的一部分，也可以不是。在整个团队对架构形成共识的过程中，工具框架团队和他们的方案，将起到带头作用。</p>

<p>（<a href="/blog/2015/06/02/cloud4/">后文继续</a>）</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p><a href="http://en.wikipedia.org/wiki/Punctuated_equilibrium">Punctuated Equilibrium</a>（什么鬼……）<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p><a href="/blog/2015/06/02/cloud4/#bct">业务能力团队</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p><a href="/blog/2015/06/02/cloud4/#pt">平台团队</a><a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[节选译：迁移至云架构（二）]]></title>
    <link href="http://nielinjie.github.io/blog/2015/05/23/cloud2/"/>
    <updated>2015-05-23T11:15:31+08:00</updated>
    <id>http://nielinjie.github.io/blog/2015/05/23/cloud2</id>
    <content type="html"><![CDATA[<p>原文：<a href="http://pivotal.io/platform-as-a-service/migrating-to-cloud-native-application-architectures-ebook">Migrating to Cloud-Native Application Architectures</a></p>

<p>本文为”节选译“，不是逐句逐段翻译，是意译和无废话译。</p>

<p>（<a href="/blog/2015/05/23/cloud/">接前文</a>）</p>

<!--more-->


<h2>云架构的定义</h2>

<h3><a name="12f"></a>十二因子应用</h3>

<p>“十二因子应用”是一些云架构模式。它们专注于速度、稳定、伸缩，主要包括强调声明性配置、无状态和无共享的横向伸缩进程、全面与部署环境解耦合等方面。当前大量的云平台都为部署十二因子应用优化。</p>

<p>在“十二因子应用”的说法中，“应用”指的是单个部署单元。</p>

<p>十二因子应用表述为：<br/>
（省略，可参见官方中文版：<a href="http://12factor.net/zh_cn/">十二因子应用</a>）</p>

<p>十二因子让应用可以快速部署，因为对环境没有多少要求。对环境没有要求也让云平台可以采用简单一致的机制来自动化地提供新的环境。这是十二因子应用在速度方面的意义。</p>

<p>十二因子也使得应用满足“生命短促”的要求，换句话说我们可以以很小的成本丢弃这些应用。首先应用环境本身完全是可丢弃的，同时应用的状态，不管内存中的还是持久化的，都外化到支持服务中。这就使得应用可以简单地自动化地伸缩。在大多数情况下，平台只要按想要的数量简单拷贝现有的环境然后启动进程就可以了。当需要缩减的时候，只要关闭运行中的进程，然后删除相应地环境就可以了，完全不用备份或者保护这些环境。这是十二因子应用在伸缩方面的意义。</p>

<p>最后，应用的可丢弃性使得平台自动错误恢复非常容易快速。同时，将日志作为事件流大大地帮助了应用状态的可视化。环境的等同、一致的配置机制以及支持服务机制则使得平台能为应用运行的各个方面提供更强大的可视化能力。这是十二因子应用在稳定方面的意义。</p>

<h3><a name="ms"></a>微服务</h3>

<p>微服务代表了将巨大架构<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>业务系统解构为独立可部署的服务。每个服务代表一个业务能力，或者说是产生业务价值的最小原子服务。</p>

<ul>
<li>我们将业务领域解耦为独立可部署的上下文的同时，我们就解耦了相关的变化迭代。当变化被局限在单个的上下文，这些变化可以独立于业务的其他方面。结果就是可以更频繁迅速地落实，从而持续不断地产生价值。</li>
<li>便于加速开发。包括可以投入更多地开发人员。可以将开发人员分开，让他们平行工作，不用过多的交流协作。</li>
<li>新加入的开发人员上手更快，因为他们需要学习的东西更少，需要打交道的团队也更小。</li>
<li>应用新技术可以更容易。在巨大架构应用中应用新技术风险较大，一旦犯错可能拖累整个企业架构。</li>
<li>微服务带来独立有效的伸缩。巨大架构应用也可以伸缩，但要求所有部件一起伸缩，不光是哪些负载重的部件。</li>
</ul>


<h3><a name="ai"></a>敏捷的自助基础设施</h3>

<p>云架构应用的部署与维护往往由开发团队负责。支持自助的平台往往有帮助。</p>

<p>好的平台能为用户建立一个抽象层。在IAAS中，我们通过调用API来建立虚拟服务器、网络、存储，然后应用不同形式的配置和自动化来运行我们的应用和支持服务。平台现在鼓励我们以应用和支持服务的角度思考。</p>

<p>应用代码只是简单地被push到git仓库，平台就开始自动编译打包、建立应用环境、部署应用、启动必要地进程。团队不需要知道代码在哪里运行，也不用知道代码是怎么到那里去的。</p>

<p>支持服务也采用类似的机制。不论需要数据库、消息队列还是邮件服务器，只需要告诉平台你的需求。现在的平台大多提供SQL/NoSQL数据库、消息队列、搜索引擎、缓存等各种重要的支持服务。这些服务的实例可以被绑定到我们应用，必要地使用许可被自动注入到应用中。完全不需要繁琐和容易出错的各种定制。</p>

<p>这些平台还提供各种其他能力：</p>

<ul>
<li>应用实例自动化和按需的伸缩。</li>
<li>应用健康管理。</li>
<li>动态路由和负载均衡。</li>
<li>日志和测量数据的汇总。</li>
</ul>


<p>这一系列的工具保障了团队可以敏捷地开发和运营他们的服务，并且做到快速、稳定、可伸缩。</p>

<h3>基于API的协作</h3>

<p>云架构中，服务之间唯一的交互方式是API，公开发布和有版本的API。通常采用HTTP上的REST风格并使用JSON序列化，但其他协议和序列化方式也完全可以。</p>

<p>团队可以在需要的时候部署新的功能。只要他们不破坏任何既有的API合同，就不用跟其他团队协调同步。跟自助基础设施交互的主要方式也是API，不论新建、伸缩还是维护应用基础设施，都通过API的调用进行。</p>

<p>通过<a href="http://martinfowler.com/articles/consumerDrivenContracts.html">客户驱动合同</a>，交互双方校验合同。服务的消费者不允许访问依赖的实现细节，也不能直接访问它的数据存储。事实上，只有一个服务可以访问它自己的数据存储。这种强制解耦合有利于云架构的速度。</p>

<h3>“反脆弱”</h3>

<p>“反脆弱”并不是指的鲁棒性或弹性。而是指系统在压力下变得更强的特性。什么系统可以做到这个？比如人的免疫系统，暴露的时候变得更强而隔离的时候变得更弱。比如，Netflix Simian Army项目有个Chaos Monkey子模块，通过向生产部件中随机注入错误来寻找架构中的弱点。通过显式地寻找弱点、注入错误、强制修复，架构自然随时间逐渐变强。</p>

<h2>总结</h2>

<p>以下为译者自己总结的 :&ndash;)</p>

<ol>
<li>提出创新时代的四个问题：速度、稳定、伸缩、移动</li>
<li>云架构在这四个问题上大致有何思路。</li>
<li>针对四个问题，云架构有五个措施：十二因子、微服务、自助基础设施、基于API协作、反脆弱</li>
</ol>


<p>（<a href="/blog/2015/05/29/cloud3/">后文继续，需要改变</a>）</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>monolithic application architectures<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[节选译：迁移至云架构（一）]]></title>
    <link href="http://nielinjie.github.io/blog/2015/05/23/cloud/"/>
    <updated>2015-05-23T11:15:31+08:00</updated>
    <id>http://nielinjie.github.io/blog/2015/05/23/cloud</id>
    <content type="html"><![CDATA[<p>原文：<a href="http://pivotal.io/platform-as-a-service/migrating-to-cloud-native-application-architectures-ebook">Migrating to Cloud-Native Application Architectures</a></p>

<p>本文为”节选译“，不是逐句逐段翻译，是意译和无废话译。</p>

<!--more-->


<h1>云架构的兴起</h1>

<p>创新型公司遇到的问题是：</p>

<ul>
<li>创新的速度</li>
<li>总是可用的服务</li>
<li>Web的伸缩</li>
<li>移动为中心的用户体验</li>
</ul>


<p>迁移到云是一个自然地选择，”云架构“是这些公司获得搅局能力的关键。</p>

<p>“云”指的是：任何计算环境，其中的资源（比如计算、网络、存储等）可以随时按需、自助地提供和释放。</p>

<h2>为什么需要“云架构”？</h2>

<h3>速度</h3>

<p>互联网公司声称每天部署几百次，为何需要频繁部署？如果你可以每天部署几百次，那么你可以几乎实时纠正错误；如果你可以实时纠正错误，那你可以进行更多的试错；如果你可以更多的试错，那你可以进行更广泛地实验。这很可能带来下一个竞争优势。</p>

<p>云基础设施灵活和自助的特性正好满足要求。就提供一个新的应用环境来说，调用一个云服务的API当然比传统流程快得多。再加上可以在持续集成\构建环境中加入钩子和其他联动，可以进一步加快速度。</p>

<h3>稳定</h3>

<p>云架构平衡了快速和稳定、可用、持久。</p>

<p>前面已经提到，云架构提供了迅速纠正错误的能力。注意，这里<strong>不是指防止错误</strong>。</p>

<p>那么我们如何即快速又稳定呢？</p>

<ul>
<li><p>可视化<br/>
我们的架构必须提供工具来及时发现失败。我们需要监测整个系统：定义一个”正常状态“，及时发现偏差，并能找到导致偏差的部件。功能丰富的测量、监控、报警、数据可视化框架和工具是云架构的重要组成部分。</p></li>
<li><p>缺陷隔离<br/>
为了控制失败带来的风险，我们需要限制被失败影响的部件或者特性。如果仅仅因为推荐引擎失效就导致所有人不能买东西，那肯定是灾难性的。单体架构的系统往往是这种情形。云架构系统经常采用”微服务“<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，通过采用微服务构建系统，我们可以把失败限制在单个微服务中。当然，需要”缺陷容忍“特征的配合。</p></li>
<li><p>缺陷容忍<br/>
将系统解构为独立部署的部件还不够。我们还必须防止一个部件中的失败在部件的依赖者中变成一个连环失败。Mike Nygrad描述了<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>几种缺陷容忍的模式，其中最常用的是”断流器“。软件断流器跟电路断流器非常相似：通过断开部件之间的连接来阻止连环失败的产生发展。断流器往往还能在断开的时候提供合适的默认行为。后续会进一步讨论。<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p></li>
<li>自动恢复<br/>
如果发现某些地方有问题，那我们一般简单重启或者重新部署相关的服务。云架构一般不需要人工干预，我们采用自动发现和恢复。<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></li>
</ul>


<h3>伸缩</h3>

<p>当需求增长，我们需要伸展我们的容量来服务需求。以前我们更多地采用纵向伸展：买更强大的服务器。</p>

<p>创新公司使用两个创新性的办法来解决问题：</p>

<ul>
<li>不买强大的服务器，而是把应用实例横向伸展到大量的便宜机器上去。这些机器容易得到而且到位很快。</li>
<li>将没有充分利用的强大服务器虚拟化成多个小服务器，在上面部署独立的负载。</li>
</ul>


<p>当公用云出现，这两个办法得到了发展：虚拟化方面由云供应商来处理，用户专心处理横向伸缩。最近另一个趋势出现：作为应用部署的单元，虚拟服务器正在往“容器”转变。后续进一步讨论。<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup></p>

<p>这种转变进一股降低了创新门槛。部署和维护软件的成本都降低了。迎合需求改变软件的速度也非常快。</p>

<p>这些收益的代价就是，我们必须面向横向伸缩来架构我们的应用。云的灵活性要求“生命短促”，不仅要能快速建立应用实例，还必须能快速安全地销毁实例。这是一个“状态管理”的问题，可销毁和可持续性的关系如何？传统的方法比如“集群会话”和“共享文件系统”都不能很好地伸缩。</p>

<p>所以云架构的另一个特点是状态外化，将状态交给外部状态管理服务（比如数据网格、缓存、对象存储等），同时保持应用实例本身是“无状态”的。无状态的应用实例可以快速地创建和销毁，跟外部状态管理服务也可以快速连接和分开，这样就可以快速响应需求的变化。当然这也要求外部状态管理服务本身是可以伸缩的。多数的云服务商已经意识到这一点，提供了很健壮的类似服务。</p>

<h3>移动应用和客户端多样性</h3>

<p>应用需要”随时随地“满足需求。访问成几何级数增长。云架构予以支持。</p>

<p>移动平台是多样化的，移动应用经常需要跟遗留服务或者云中的微服务打交道。这些服务不可能满足各种移动平台的用户的不同需求。将整合多样性的任务交给移动开发会增加网络延迟和流量，带来响应慢和电池消耗。云架构可以将整合任务放到服务器端，比如通过模式”API GateWay"。后续进一步讨论。<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup></p>

<p>（<a href="/blog/2015/05/23/cloud2/">后文继续</a>）</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>见<a href="/blog/2015/05/23/cloud2/#ms">“微服务”</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>书：<em>Release It!</em><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>见“断流器”（链接待建）<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>要求微服务的一些特性，见<a href="/blog/2015/05/23/cloud2/#12f">“十二因子应用”</a>。<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
<li id="fn:5">
<p>见“容器化”（链接待建）<a href="#fnref:5" rev="footnote">&#8617;</a></p></li>
<li id="fn:6">
<p>见“API GateWay和边界服务“（链接待建）<a href="#fnref:6" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[质量保障措施参考清单（三）]]></title>
    <link href="http://nielinjie.github.io/blog/2015/04/10/resilient3/"/>
    <updated>2015-04-10T10:18:14+08:00</updated>
    <id>http://nielinjie.github.io/blog/2015/04/10/resilient3</id>
    <content type="html"><![CDATA[<p>（<a href="/blog/2015/04/10/resilient2/">接上篇</a>）</p>

<!-- more -->


<h2>业务正确性和容错性</h2>

<p>系统不仅需要业务功能结果正确，还需要在业务发生问题的时候能够尽量多的提供诊断和恢复支持。</p>

<h3>设计时</h3>

<p>设计时可以识别的设计要求大致有：</p>

<ul>
<li>业务错误可以回查。</li>
<li>业务过程可以回查。</li>
<li>业务操作可以回查。</li>
<li>系统故障情况下业务（一定程度上）可以持续。</li>
</ul>


<p>为满足此要求，需要：</p>

<ul>
<li>定义业务过程、业务状态。</li>
<li>记录业务过程和状态的变化。</li>
<li>为各个状态定义业务备案。</li>
<li>记录业务操作。</li>
</ul>


<h3>业务接入时</h3>

<ul>
<li>业务被误用。

<ul>
<li>明确的业务定位</li>
</ul>
</li>
<li>系统之间业务状态不正确或不明确。

<ul>
<li>记录业务进出口状态。</li>
</ul>
</li>
</ul>


<h3>日常趋势</h3>

<ul>
<li>事故趋势恶化

<ul>
<li>业务逻辑有问题？</li>
<li>用户体验有问题？

<ul>
<li>用户体验数据</li>
</ul>
</li>
<li>需要事故记录</li>
</ul>
</li>
</ul>


<h3>事故时</h3>

<ul>
<li>系统操作中断，比如可用性事故引起。

<ul>
<li>需要各个状态定义业务备案。</li>
</ul>
</li>
<li>事后发现业务结果不正确。

<ul>
<li>记录业务过程状态变化。</li>
</ul>
</li>
<li>系统错误

<ul>
<li>大范围错误 &ndash; 归结为<a href="/blog/2015/04/10/resilient2/">可用性事故</a>。</li>
<li>局部错误 &ndash; 归结为bug。</li>
<li>需要系统错误率实时监控和报警。</li>
<li>需要系统错误持续记录和分析。</li>
</ul>
</li>
</ul>


<h3>小结</h3>

<p>综上，为持续保障系统正确性，需要采取的措施有：</p>

<ul>
<li><strong>明确的业务定位。</strong>以及定期review。</li>
<li><strong>定义各个业务过程、业务状态。</strong></li>
<li><strong>业务过程和业务状态的变化的记录。</strong></li>
<li><strong>各个状态定义业务备案。</strong></li>
<li><strong>业务操作的记录。</strong></li>
<li><strong>业务进出口状态的记录。</strong></li>
<li><strong>用户体验数据持续记录和分析。</strong></li>
<li><strong>系统错误率持续监控和阙值报警。</strong></li>
<li><strong>系统错误持续记录和分析。</strong></li>
<li><strong>事故记录与分析。</strong></li>
</ul>

]]></content>
  </entry>
  
</feed>
