<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 设计 | 聂同学]]></title>
  <link href="http://www.nietongxue.xyz/blog/categories/she-ji/atom.xml" rel="self"/>
  <link href="http://www.nietongxue.xyz/"/>
  <updated>2017-09-14T11:06:57+08:00</updated>
  <id>http://www.nietongxue.xyz/</id>
  <author>
    <name><![CDATA[nielinjie]]></name>
    <email><![CDATA[nielinjie@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[分布式事务，也谈（之三）]]></title>
    <link href="http://www.nietongxue.xyz/blog/2016/10/06/transaction3/"/>
    <updated>2016-10-06T00:43:57+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2016/10/06/transaction3</id>
    <content type="html"><![CDATA[<p>继续谈实现模型。按抽象层次分层，设计为知识→操作多层结构，每个层针对不同层面的概念、逻辑和开发者。</p>

<!--more-->


<p>最上层为具体业务开发者需要关注的概念，实际上只包括：</p>

<ol>
<li>各个操作的特征，说明各个操作如何调用、可否回查、可否撤销等等。</li>
<li>决策表中的具体规则。说明当某某状况发生时，采取某某处置。</li>
</ol>


<p>第二层为事务管理组件，负责组织前面提到的两层嵌套状态机。</p>

<p>第三层和第四层，是两层嵌套状态机本身的实现。</p>

<p><img src="/images/transaction/transaction3.png" width="500"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式事务，也谈（之二）]]></title>
    <link href="http://www.nietongxue.xyz/blog/2016/09/26/transaction2/"/>
    <updated>2016-09-26T16:08:48+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2016/09/26/transaction2</id>
    <content type="html"><![CDATA[<p>如前一篇提到的 <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，本篇谈一谈实现模型<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。</p>

<!--more-->


<p>过程管理常常被实现为一个状态机，这里顺着这个思路尝试一番。</p>

<ol>
<li>每个操作实现为一个状态机，称为“操作状态机”。</li>
<li>使用一个外层状态机处理决策过程，实现决策表。称为“决策状态机”。</li>
<li>操作状态机嵌入决策状态机，作为内嵌状态<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>。决策状态机和操作状态机分别是外层状态机和内层状态机。</li>
<li>内层状态机对外层隐藏它自己能够独立处理的逻辑。仅向外暴露最终的对外<strong>状况</strong>和可以被外层<strong>处置</strong>的事件。</li>
<li>逻辑在内外层之间的分配是最重要的一个权衡。如果内层逻辑太多则外层可以做的处置就太少，控制能力有限。如果内层逻辑太少，就将大量复杂性丢给外层，外层负担太重。这两种情况，层次结构都失效了。</li>
<li>内外层之间通过事件沟通，内层产生的最终状况通过事件送达外层决策，外层决策做出的处置也通过事件操作内层。</li>
<li>操作的撤销可以视为另一个操作，实现为一个独立的操作状态机。也可以与操作本身一起实现为同一个状态机。这是内外层的逻辑分布进行权衡的一个例子。</li>
<li>决策表，是外层逻辑的核心，是一些规则的集合，规则的输入是各个操作的对外状况，输出是对各个操作的处置。<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></li>
<li>决策逻辑可能会很复杂，比如有时候决策逻辑不仅依赖于当前输入，还会依赖于决策历史。此时需要权衡，可以把特别复杂和不太可能发生的情况留给人工解决。</li>
<li>整个结构还可能继续嵌套，也就是说整个状态机可能还是更外层状态机的一个内嵌状态机。</li>
<li>上述整个结构，是对应于一个事务的。处理多个事务，就是同时并存的多个状态机实例。</li>
</ol>


<p>（<a href="/blog/2016/10/06/transaction3/">下一篇</a>，继续谈实现模型）</p>

<p>附图：</p>

<p><img src="/images/transaction/transaction2.png" width="500"></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>本篇所有概念和名词都延续自<a href="/blog/2016/09/19/transaction/">前一篇</a>。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>此处并没有任何可以直接应用的结论或代码。“干货”并非是本博的主要内容，参见：<a href="/blog/2016/05/20/dry/">时事：干货</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>Wiki：<a href="https://en.wikipedia.org/wiki/UML_state_machine#Hierarchically_nested_states">Hierarchically_nested_states</a><a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>决策表的例子见<a href="/blog/2016/09/19/transaction/">前一篇</a>，但要注意，前一篇的例子中，对操作的处置是很细节的，在很多场景中不一定适合，如上面第5点讨论的。<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给老爷爷系统（八）：特征机制]]></title>
    <link href="http://www.nietongxue.xyz/blog/2014/06/16/feature/"/>
    <updated>2014-06-16T21:06:38+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2014/06/16/feature</id>
    <content type="html"><![CDATA[<blockquote><p>这是一个老爷爷系统。</p></blockquote>

<p>在《<a href="/blog/2013/09/01/dsl1/">一场似非而是的DSL</a>》和《<a href="/blog/2014/06/16/3d">三个划分维度</a>》中，
已经提到了“特征机制”。这里专门讲一下。</p>

<!-- more -->


<p>“特征机制”，是一种动态选择机制，用来协同“通用”和“专用”两个层次。
当通用逻辑运行到某个点，需要执行专用逻辑，我们首先需要找到正确地专用逻辑。</p>

<ul>
<li>我们把通用逻辑中需要运行专用机制，也就是可能发生扩展的点，称为“扩展点”。</li>
<li>不同的“差异来源”带来不同的“业务差异”，通过在扩展点上填入适当的“扩展”来实现差异化的专用逻辑。</li>
<li>所谓“特征”，就是一条知识，描述了当在何种“业务差异”的处理中，需要在哪些个扩展点填入哪些个“扩展”。</li>
<li>所谓“特征机制”，就是当系统运行到一个扩展点的时候，查找到正确的特征，填入正确的扩展并运行的机制。</li>
</ul>


<p>特征机制的实现在设计上有意识地做到“操作层”和“知识层”分离，以便二者能够分别进化，这点在《<a href="/blog/2013/09/01/dsl1/">一场似非而是的DSL</a>》已经说明了。</p>

<p>下面的图体现了上面这些概念的静态关系。除了主干之外，枝节也说一下：</p>

<ul>
<li>“业务差异”需要一个载体，就是“特征拥有者”，比如“签报”、“用户”等领域对象都可以是特征拥有者，这些拥有者的属性导致了差异。</li>
<li>同一个拥有者的特征可能来源于不同的差异，其中有可能会相互影响甚至冲突，这时候需要一个裁决者，这就是“特征集”。</li>
<li>“特征要求”是拥有者的属性与特征之间的映射，体现为“业务属性”和“业务事件”。</li>
<li>特征由特征要求决定，可以在需要特征时刷新，也可以当“业务属性”改变或“业务事件”发生时刷新。</li>
</ul>


<p><img src="/images/feature/feature2.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[结构的要素]]></title>
    <link href="http://www.nietongxue.xyz/blog/2014/06/07/structure/"/>
    <updated>2014-06-07T17:06:38+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2014/06/07/structure</id>
    <content type="html"><![CDATA[<p>结构的基本要素有：</p>

<ul>
<li>存在：一个元素是否存在。</li>
<li>边界：一个元素的定义和与其他元素的区别。</li>
<li>关系：一个元素与其他元素有没有联系。</li>
</ul>


<p>在基本之上，研究结构的另一些特征可能有帮助：</p>

<ul>
<li>聚合：元素与某些元素的关系不同于与其他元素。</li>
<li>层次：元素与另一些元素区别的意义取决于观察的角度。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一场似非而是的DSL（后传）]]></title>
    <link href="http://www.nietongxue.xyz/blog/2013/09/02/dsl-post/"/>
    <updated>2013-09-02T21:36:38+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2013/09/02/dsl-post</id>
    <content type="html"><![CDATA[<p>这是后传，不是正传，主要写设计结果和实现的一些细节，不喜请无视。</p>

<!-- more -->


<p>DSL的一个片段如最后的代码所示，基本上满足了我们的要求——</p>

<ul>
<li>片段完整地描述了一个特征，包括扩展点、扩展等等各方面的信息。实例中，<code>dynamicProperty</code>、<code>show</code>、<code>mail</code>是三个不同的扩展点，大括号里面的内容是当某个业务差异时填入扩展点的具体扩展逻辑。而这个业务差异，由<code>condition</code>描述。</li>
<li>不存在片段中和片段间来回引用穿梭等影响阅读完整性的问题。</li>
<li>不同方面的内容描述形式一致。比如动态属性dynamicProperty和邮件策略mail是不同的特征，背后的业务知识是很不同的，但这里体现为统一的描述形式。</li>
<li>聚焦于业务概念，噪音很少。这个片段看上去，除了表示范围的大小括号外，基本上全部是业务概念。</li>
</ul>


<p>讲一些实现细节——</p>

<ul>
<li>DSL的实现基于Groovy的<code>ObjectGraphBuilder</code>。</li>
<li>示例代码中的<code>dsl</code>就是<code>ObjectGraphBuilder</code>的一个实例，<code>requirement</code>构建顶层的bean。</li>
<li>类似于<code>requirement{}</code>以及内嵌的<code>dynamicProperty{…}</code>都是一些普通的groovy方法调用，通过groovy的动态调用机制赋予这次调用一些逻辑，以<code>dynamictProperty</code>为例：

<ul>
<li>实例化一个类，根据方法名计算这个类的类名。这个例子里就是类<code>DynamicProperty</code>。</li>
<li>将这个实例set到上级bean的适当属性上，这个属性也是根据方法的名字计算得到的。这个例子就是属性<code>dynamicProperty</code>。</li>
</ul>
</li>
<li>上述的根据方法名计算类名和属性的办法是<code>ObjectGraphBuilder</code>原生的，比较简陋，需要做一些定制，<code>ObjectGraphBuilder</code>提供了定制的接口，分别是<code>ClassNameResolver</code>和<code>RelationNameResolver</code>。我们对简单的计算办法做了补充：

<ul>
<li>类名搜寻策略，原生的计算只有硬匹配，就是只能设置一个包名，每个方法名直接加在包名后面就得出类名。这个策略在我们这里完全行不通，因为我们这里的很多类，不是固定在某个已知的包里面的，比如扩展和扩展点，这些类是具体的，类名来自于具体逻辑所在的包，散布在整个系统。对此我们引入了类名搜索机制，在整个系统的包空间搜索需要的类。另外一方面，我们借助reflection，从上层bean的属性类型，得到需要的类。</li>
<li>属性搜寻策略，在原生的名字匹配的基础上，我们结合类型匹配，也就是根据类名对应策略得到的类名反过来匹配上层bean的属性类型，找到这个属性。比如<code>dynamicProperty</code>这个方法，上层的bean是没有一个叫“dynamicProperty”的属性的，但有个<code>Feature</code>类型的属性。<code>dynamicProperty</code>方法实例化<code>DynamicProperty</code>类，它是<code>Feature</code>的子类，可以匹配。</li>
<li>上述两个搜索策略都考虑了集合属性的情况，名字经过简单地单复数转化，读取类型时通过泛型的集合的参数类型读取。</li>
<li>有一种特殊情况，搜寻类名和搜寻属性的策略会相互影响，我们希望有一种特殊的策略能把两个搜索过程独立开。我们约定一种特殊的方法名字形式：<code>propertya$classb</code>，这样我们根据<code>propertya</code>计算属性，<code>classb</code>计算类名。更特殊的情况比如代码中的<code>$selectorRenderer</code>，只计算类名不计算属性，表示这里只实例化bean，不做上层bean的属性设置。这中特殊策略为DSL的编写带来了方便，但其实不是一种业务策略，在DSL的角度看来其实是一种噪音，我们尽量避免使用。</li>
</ul>
</li>
<li>相关的代码不多，已经放到github，供参考。<a href="https://github.com/nielinjie/dslOGB">https://github.com/nielinjie/dslOGB</a>。其中用于扫描classpath的依赖包<code>com.google.classpath</code>来自于介里：<a href="https://code.google.com/p/classpath-explorer/">https://code.google.com/p/classpath-explorer/</a>。</li>
</ul>


<p>代码：</p>

<pre><code>dsl.requirement{
    name('isStock')
    description('是否关联交易')
    condition(exp:'(owner.sortId==1 || owner.sortId==11 ) &amp;&amp; owner.taskComp.contains("PA002")')
    dynamicProperty{
        name('isStockTrade')
        cName('关联交易')
        type(java.lang.String.class)
        stringValidator()
        stringEditor()
        maxLength(10)
        minLength(1)
        isRequired(true)
        defaultValue(true)
        renderMap(key:'writable',value:$selectorRenderer())
        renderMap(key:'readOnly')
        activeEvent{
            change('var ....')
        }
    }

    show{
        flag(function:'submitTask',flag:'writable')
        flag(function:'approval',flag:'readOnly')
    }

    mail{
        handleMap(key:'New_Submit',value:'mailHandle')
        handleMap(key:'Edit_Submit',value:'mailHandle')
    }
}
</code></pre>
]]></content>
  </entry>
  
</feed>
