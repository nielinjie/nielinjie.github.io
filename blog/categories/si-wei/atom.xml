<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 思维 | 聂同学]]></title>
  <link href="http://www.nietongxue.xyz/blog/categories/si-wei/atom.xml" rel="self"/>
  <link href="http://www.nietongxue.xyz/"/>
  <updated>2018-01-20T18:20:02+08:00</updated>
  <id>http://www.nietongxue.xyz/</id>
  <author>
    <name><![CDATA[nielinjie]]></name>
    <email><![CDATA[nielinjie@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[“驱动者”说]]></title>
    <link href="http://www.nietongxue.xyz/blog/2018/01/14/driver/"/>
    <updated>2018-01-14T23:16:37+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2018/01/14/driver</id>
    <content type="html"><![CDATA[<p>之前<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>谈到“驱动”这个概念。说“驱动”讲的是拆分问题的单位，现在尝试讨论下，什么样的东西，适合用来作为这个驱动者，也就是说，什么样的东西，适合用来拆分问题。</p>

<!-- more -->


<p>之前的我们讲，驱动者是拆分问题的单位，也是应对问题的单位、解决问题、验证解答的单位。就是说，驱动者有两个功能，一是拆分问题，一是推动问题的解决。</p>

<p>拆分问题方面的要求有两个 -</p>

<ol>
<li>拆分本身的质量。拆分要易操作，最好不依赖于个人，有机械的工程方法。拆分的结果要不缺失、不重复，要容易反过来验证是否能组合回到最初的问题<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。</li>
<li>拆分出来的子问题的质量。问题要容易定义，容易应对。拆分问题的唯一目的是要让问题变得容易分别应对。如果能通过一些机械方法，直接将子问题映射为一些可以执行的任务，并到达SMART的标准，那可以说是最理想的拆分了。</li>
</ol>


<p>推动问题解决方面，只有一个要求，就是要把解决问题的程度、进度可视化。这一方面相对简单。</p>

<p>下面我们用一两个“驱动”的例子，来看看下这些驱动者在各个方面的表现。</p>

<p>比如我们说测试驱动开发。测试案例就是驱动者，我们看看它是否符合这三个要求 -</p>

<ol>
<li>拆分问题的质量。不太好。从要实现的用户故事，到拆分为的测试案例之间，联系并不明显。从用户故事到测试案例的映射需要程序员的丰富经验，这个过程缺乏机械性。同样的，从测试案例反过来验证组合回用户故事，也是不够直接的。通俗的讲，就是即使我完成了所有分解而来的100个测试案例，我仍然无法直接判定我是否已经满足了用户故事。</li>
<li>定义和应对子问题。比较好。拆分而来的子问题就是设法写出满足测试案例的代码。测试案例确定时，任务的边界也就是确定的。而对于如何写出一个通过测试案例的代码，相对比较可控。</li>
<li>可视化解决程度。不太好。是否能通过测试，作为问题是否解决的标注，一目了然。但这个标准只有0和1，没有中间状态，对进度的表征是不理想的。</li>
</ol>


<p>从上面三点看，第一点比较突出，测试驱动的主要不足在于如何将用户故事稳定可靠地映射为一些测试案例。这时候BDD的理念赶来帮忙了，稍微改进一下测试驱动，将拆分为单元测试案例改为拆分为以软件行为描述的测试案例。行为描述与用户故事之间的分解-组合关系就相对更直接了。至于第三点，进度不好标度，这个问题不是很突出，因为测试驱动分解的任务粒度够小。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p><a href="/blog/2017/12/14/d-o/">前一篇：“驱动”与“面向”</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>拆分本身可以讲一大堆，这里不展开。后续可以有一篇专文。<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[“驱动”与“面向”]]></title>
    <link href="http://www.nietongxue.xyz/blog/2017/12/14/d-o/"/>
    <updated>2017-12-14T22:45:56+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2017/12/14/d-o</id>
    <content type="html"><![CDATA[<p>领域驱动、测试驱动、风险驱动；面向对象、面向组件、面向服务。这些说法我们都已经很熟悉了，大家研究的重点往往是其中的那个名词。名词是关键没错，但那已经说得够多了。今天来聊聊其中的动词，“驱动”与“面向”。</p>

<!-- more -->


<p>“驱动”，作用于问题空间，讲的是拆分问题的单位。领域驱动，是以领域结构为依据拆分问题；测试驱动，就是将问题拆分为一个个测试案例，等等。拆分后的小问题，就是应对问题的单位、解决问题、验证解答的单位，这些后续的活动都挂载在这个小问题上，同时这个小问题也是将任务、资源、进度、协同等等这些过程要点牵引起来的那个由头，就像火车头“驱动”着一串车厢一样。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<p>“面向”，作用于解空间，讲的是构建答案的单位。面向对象，就是以对象作为答案的搭建单元；面向服务，就是以服务作为构建答案的搭建单元。这种单位，往往把整个构建工作分成两部分，先要建造这些单位，然后组合这些单位。就像面向砖瓦的建筑，就分成了制造砖瓦和砌砖。当然过程中可能不只有一种单位，在不同的阶段、不同的层次上有不同的单位，比如服务也是由对象、组件这些单位构成的。</p>

<p>在“问题空间与解空间”<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>这个一般思维框架中，“驱动”与“面向”两个动词，基本上涉及了从问题分析解决的整个过程。</p>

<p>那什么样的东西适于驱动，什么样的东西适于面向呢？正在做一些思考总结，此处先挖坑待填。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>类似的观点在之前的博文中已有谈及，但没有明确谈为什么用“驱动”这个词。——<a href="/blog/filter/filter.html?filterName=series&amp;filterValue=%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B%E7%9A%84%E9%A9%B1%E5%8A%A8%E6%8A%80%E6%9C%AF&amp;filterDes=Series%3A%20%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B%E7%9A%84%E9%A9%B1%E5%8A%A8%E6%8A%80%E6%9C%AF">《架构设计过程的驱动技术》</a>、 <a href="/blog/2016/08/14/question2/">《问题空间与解空间》</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p><a href="/blog/2016/08/14/question2/">《问题空间与解空间》</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linus的代码与数据结构]]></title>
    <link href="http://www.nietongxue.xyz/blog/2017/06/03/code-data/"/>
    <updated>2017-06-03T15:39:24+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2017/06/03/code-data</id>
    <content type="html"><![CDATA[<p>Linus说： &ldquo;烂程序员关心的是代码。好程序员关心的是数据结构和它们之间的关系。&rdquo;</p>

<!-- more-->


<p>代码体现的是过程。数据结构（和它们之间的关系）体现的是实体。</p>

<p>这里讲的过程和实体，都是模型，是人类思维对现实世界认知进而处理的手段。</p>

<p>相比较而言，人类对实体的掌握，似乎要优于对过程。我们觉得实体比过程更直观和易处理。</p>

<p>所以面对复杂和大规模的过程，人们借助实体，来增强认知和处理能力 -</p>

<ol>
<li>一方面，我们借助实体，对过程做分割和组合。比如卖个东西，是个复杂的过程，我们借助订单、出库单、送货单等实体，把这个过程分解为相互配合的多个过程，通过分解降低了过程的复杂性。</li>
<li>另一个方面，我们借助实体，对过程作记录和可视。比如用账目来记录经营过程，用看板来可视化生产。虽然没有直接降低复杂性，但帮助了认知和理解。</li>
</ol>


<p>以上来看，实体是我们对付世界的首选武器，即使不得不处理过程，我们也人为地引入实体来帮忙。</p>

<p>回到Linus的话，说代码与数据结构，实际上说的是程序员如何建模设计的问题。我理解Linus的意见是，多用实体，辅助过程，符合人类思维模式，是聪明的选择。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[技术的对面]]></title>
    <link href="http://www.nietongxue.xyz/blog/2016/12/23/tech/"/>
    <updated>2016-12-23T09:13:54+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2016/12/23/tech</id>
    <content type="html"><![CDATA[<p>“技术”的对面是“策略”，不是“应用”、“方法”，不是“思想”、“道”，也不是“艺术”或“诗歌”。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[与复杂同行（一）]]></title>
    <link href="http://www.nietongxue.xyz/blog/2016/12/11/complex/"/>
    <updated>2016-12-11T13:21:04+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2016/12/11/complex</id>
    <content type="html"><![CDATA[<p><strong>复杂性平方律</strong></p>

<blockquote><p>系统的复杂性正比于系统规模的平方</p></blockquote>

<p>一、系统的复杂性不仅由节点的数量（即“规模”）带来，更多的是由节点间的关系（包括没有关系）带来。<!--more-->
这也就是复杂性平方律的原因。系统的复杂性正比于节点数的平方，因为节点间的连接数正比于节点数的平方。
我们假设节点和连接的复杂度都为1，比如下图所示的系统，总复杂度为14。</p>

<p><img src="/images/complex/complex1.png" width="300"></p>

<p>二、尝试分拆系统。节点被分拆到两个不同的空间，出现了跨空间的连接，这些连接通常成本相对高，带来了相当多额外复杂度。
所以简单的分割不一定能带来复杂性的改善。
我们假设跨空间连接的复杂度为k，则两个空间的复杂度分别为7+4k、3+4k，要使分拆后复杂度降低，对k的要求很高 -</p>

<blockquote><p>  7 + 4k &lt; 14 => k &lt; 1.75</p>

<p>  3 + 4k &lt; 14 => k &lt; 2.75</p></blockquote>

<p><img src="/images/complex/complex2.png" width="300"></p>

<p>三、增加一些节点和连接（方块节点和虚线连接）来改变跨空间连接。
由于方块节点和虚线连接通常是一些技术性的代理元素，不用承载领域内容。它们的复杂性通常小于普通元素。这里我们仍然按1来计算。
同样计算对k的要求，发现降低了很多。</p>

<blockquote><p>11+ k &lt; 14 => k &lt; 3</p>

<p>6 + k &lt; 14 => k &lt; 8</p></blockquote>

<p><img src="/images/complex/complex3.png" width="300"></p>

<p>（待续） <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>前方坑大。管挖不管填。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
