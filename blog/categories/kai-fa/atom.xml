<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 开发 | 聂同学]]></title>
  <link href="http://nielinjie.github.io/blog/categories/kai-fa/atom.xml" rel="self"/>
  <link href="http://nielinjie.github.io/"/>
  <updated>2014-03-22T22:41:32+08:00</updated>
  <id>http://nielinjie.github.io/</id>
  <author>
    <name><![CDATA[nielinjie]]></name>
    <email><![CDATA[nielinjie@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[这些年写过的代码（一）]]></title>
    <link href="http://nielinjie.github.io/blog/2013/01/23/code/"/>
    <updated>2013-01-23T21:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2013/01/23/code</id>
    <content type="html"><![CDATA[<p>2012年的最后两天，终于完成了一个久拖不决的任务：把几年来写过的代码review了一番。</p>

<!-- more -->


<p>这里记录的都是业余时间写的代码，它们往往都是以（企图）解决生活中的一个实际问题开始的，然后变成了当时流行的技术的试验场。这种情况下，最后当然往往把最初要解决的那个问题抛之脑后，无法挽回其烂尾命运。</p>

<h2>一、爬虫</h2>

<p>这是web爬虫程序。这个程序要解决的问题起源于从某个在线看书网站批量下载小说章节。后续又有批量下载mm图片的兴趣，使这个程序源远流长。
在这个问题中，程序逻辑主要集中在几个问题——</p>

<ul>
<li>爬虫线程管理：网络内容获取是耗时和不确定的io操作，需要管理其状态。同时爬虫往往是从前一个爬虫衍生的，所以所有爬虫线程中，既有并列关系的线程，也有先后关系的线程。</li>
<li>爬虫群中间状态管理：爬虫群不一定能一次完成所有想要内容的获取，需要把中间状态保存下来，同时由于web内容是持续更新的，爬虫群也需要支持发现和获取更新的操作，这也要求记录中间状态。显然，中间状态必须在多个爬虫线程间共享。</li>
<li>内容对象：爬虫群从web中获得的内容需要按照业务意义进行组织，形成一个对象团。这个对象团不同于爬虫群中间状态，也往往不直接对应于所爬过的网站结构。</li>
<li>爬虫行进路线：这个爬虫不是对页面上所有的链接进行跟进，而是根据网站结构，有目的的爬向有意义的内容，是有路线图的。以下载小说为例，第一个页面是排行榜，我们爬向某本书的链接而不是爬向广告，同样，到了具体的内容页面，我们尽量爬向“下一页”而不是“下一章”。</li>
<li>上述四点，前两个问题是所有爬行任务都一样的，后两个问题是每个爬行任务不同的，是对爬行任务的描述。这两个层面，分别是操作层和知识层，如何处理他们的联系，也是一个重要问题。</li>
</ul>


<p>这个程序我这里有groovy版、clojure版、scala版。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<p>最初是groovy<a href="http://groovy.codehaus.org">0</a>版，是直接从批量下载小说的需求引出的。</p>

<ul>
<li>groovy是我接触过的第一个jvm上的语言，闭包、动态特性和适度的magic，在某些场合非常合用。</li>
<li>groovy有称之为“builder”的风格，比如有xmlBuilder、httpBuilder……，类似Object Literal，简洁好用。</li>
<li>grovvy有现成的查询html中某些节点的工具。</li>
<li>有个griffon<a href="http://griffon.codehaus.org">1</a>，是仿照grails<a href="http://grails.org">2</a>的思想做的swing下的mvc框架。</li>
<li>这个版本以java内置的线程池管理线程。</li>
<li>这个版本没有区分操作层与知识层，没有考虑底层逻辑有可能被其他爬行任务服用的问题，没有从概念上区分中间状态对象、网站结构对象和内容对象。以网站结构对象为中心驱动：从一个结构对象中得到爬行线程对象，也从中抽取内容对象。</li>
</ul>


<p>然后是clojure<a href="http://clojure.org">3</a>版</p>

<ul>
<li>clojure是我见过的第一个把并发支持宣称为语言特性的一门语言。</li>
<li>clojure的lisp语法非常引人入胜。</li>
<li>当时对clojure没有对象（那时候想办法用record模拟，但别扭）这个特征非常迷惑，觉得没有对象咋能写程序呢？当然就更没办法去想什么操作层、知识层等等……</li>
<li>clojure的agent<a href="http://clojure.org/agents">4</a>，及其watch，非常适合爬行的底层逻辑。很方便的自动管理爬行线程间的并列、先后关系。</li>
<li>由于对FP<a href="http://en.wikipedia.org/wiki/Functional_programming">5</a>风格的不熟悉，不知道如何以这种风格去抽象逻辑层次，这个版本只实现了有限的底层逻辑。</li>
</ul>


<p>然后是scala<a href="http://www.scala-lang.org">6</a>版本，有好几个scala版本</p>

<ul>
<li>scala是个好语言。很多观点认为它有点太难学。不过我认为，如果你还没有完全学会，那你就像用java一样使用它，逐步领悟它的不同和强大之处。</li>
<li>sbt<a href="http://www.scala-sbt.org">7</a>好用。但有时候稍微复杂了点。只有最简单的情况可以声明式配置，稍微负载的情况就需要进行编程。</li>
<li>从scalaz<a href="http://code.google.com/p/scalaz/">8</a>我真正开始学习FP，有兴趣的同学可以详细读一下scalaz的例子的源代码。生活在 OO<a href="http://en.wikipedia.org/wiki/Object-oriented_programming">9</a>、imperative<a href="http://en.wikipedia.org/wiki/Imperative_programming">10</a> 世界的同学将会感到耳目一新，逐渐感到OO乃至imperative在某些方面相对乏力<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。</li>
<li>第一个版本我纠结于如何实现对象在线程间共享，我采用的策略是不共享，把公共对象封装在actor<a href="http://www.scala-lang.org/node/242">11</a>之下，由actor机制实现线程间通讯，不是所有线程都直接访问公共对象。现在scala已经吸纳了akka<a href="http://akka.io">12</a>的actor实现，比以前更加强大了。</li>
<li>第一个版本还研究了如何抽象在一个大对象中访问、修改某个深层属性，那时候不知道有Lens<a href="https://blog.stackmob.com/2012/02/an-introduction-to-lenses-in-scalaz/">15</a>这种模式。</li>
<li>第一个版本开始意识到操作层和知识层的不同，同时由于scala的OO、FP混合特性，我可以自如的进行抽象建模，两个层次完全分开。当面临不同的爬行任务，我只需定义新的内容对象和爬虫行进路线。</li>
<li>这里虽然没有进一步抽象出DSL<a href="http://en.wikipedia.org/wiki/Domain-specific_language">13</a>，但对DSL和其在scala的实现办法进行了一些研究，Internal DSL<a href="http://martinfowler.com/bliki/DomainSpecificLanguage.html">14</a>方面，scala没有groovy容易；但由于几个方便的工具，External DSL<a href="http://martinfowler.com/bliki/DomainSpecificLanguage.html">14</a>反倒是比较方便 —— 比如Kiama<a href="http://kiama.googlecode.com">16</a>、Parboiled<a href="https://github.com/sirthias/parboiled/wiki/parboiled-for-Scala">17</a></li>
<li>第二个版本出现在我发现STM<a href="http://nbronson.github.com/scala-stm/">20</a>在scala也有实现的时候，除了大对象共享方式不同，其他跟第一个版本大同小异。</li>
<li>第三个版本出现在我迷恋上Applicative、Monad、Arrow<a href="http://www.haskell.org/haskellwiki/Typeclassopedia">18</a> 、Iteratee<a href="http://www.haskell.org/haskellwiki/Enumerator_and_iteratee">19</a>等FP模式<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>的时候，我感到OO的编程模式丑陋而无法忍受，我要Lens，大对象要不可变、线程要被隐藏在并发模型之后、爬行任务的生成要实现Iteratee模式，总之我想以FP的“优雅”的方式实现这个程序。结果是，还没写完……。</li>
<li>我意识到自己在强迫自己使用不一样的、不熟悉的、听上去很牛的编程风格，只领略这些风格的不同和神奇，而没有认真思考这种不同有没有真正带来好处。<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></li>
</ul>


<p>最后有个Android版本，原本想实现在android上的爬行，并且开始探索scala在android上运行的可行性。但这个版本由于我迅速成为果粉而无疾而终。</p>

<p>（待续）</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>已经相当长时间没有关注groovy、grails、griffon、clojure的相关内容了，观点可能过期。scala相关的略好些。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>将FP跟OO、Imperative对立并不严密。但这里不打算仔细区别这个，我这里的OO、Impaerative指的通常的java、c#、c/c++之类的“主流”语言。<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>这里列出的都是Haskell的地址，因为Haskell有页面集中说明这些东西是啥。实际操作中还是用的scalaz实现版本。<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>我这样说完全不是指我反对FP风格。实际上我非常喜欢这种风格。我的意思只是，在学习的时候，需要更多的思考。<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于REST风格的讨论（二）]]></title>
    <link href="http://nielinjie.github.io/blog/2012/10/29/rest2/"/>
    <updated>2012-10-29T21:36:38+08:00</updated>
    <id>http://nielinjie.github.io/blog/2012/10/29/rest2</id>
    <content type="html"><![CDATA[<p>参与到讨论中的架构师只有两三位。看来公司内对REST有看法的同学并不多。邮件如下。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<!-- more -->


<p>其中，XN是这次公司里负责研究和介绍REST的主要人员，通过讨论，我理解这次侧重于研究的是<strong>展示逻辑部署于浏览器端</strong>这种应用模式，以及如何以这种模式替换目前广泛使用的类似SpringMVC的服务器端展示逻辑。其中浏览器到服务器端的HTTP接口，用到了类似REST形式。对于REST本身的内涵和意义，这次并没有作为重点关注。</p>

<h3>答复: 关于REST风格 &ndash; NLJ（我）</h3>

<p>感谢大家参加讨论，对XN和CH的观点回复如下，供大家批评。</p>

<ul>
<li>缓存

<ul>
<li><p>我理解缓存是REST最基本的优点之一。</p></li>
<li><p>“在WEB层框架上处理全局的数据缓存是不合适的”这个观点是同意的，没有异议，但我理解也不应该在框架层禁用缓存，比如XN在先前的邮件中提到的“所有REST请求与.do是一样的，都禁用浏览器缓存的，这个是由一个拦截器来完成的。”</p></li>
<li><p>“是否使用缓存”跟“XX框架是否有控制缓存实现”是两个层面的事情，我理解不能因为Spring3REST框架不支持控制缓存就禁用缓存。我们都知道缓存是由HTTP 头控制的，就算是最基本的直接写servlet也是可以操作HTTP头的。</p></li>
<li><p>前面CH提到的缓存安全性跟cookie一样，这个有点问题。</p>

<ul>
<li><p>缓存不仅仅指浏览器上的缓存，还包括整个HTTP链路上的缓存，比如proxy上的，所以不像cookie只存在于某个人私人的机器上。</p></li>
<li><p>Cookie一般不会存放实际业务数据，比较多是些id、token之类的，即使泄露，风险也比较小。</p></li>
</ul>
</li>
</ul>
</li>
<li>会话

<ul>
<li>看来大家意见没有明显的差异。</li>
</ul>
</li>
<li>资源

<ul>
<li><p>资源的划分，是个业务问题。而DTO，Form，表，Service这些都是实现问题。在划分资源时是不会看到实现上的任何概念的。如果划分的结果，一个资源的范围和Form（或者DTO，表）一样，那也仅仅是巧合而已。</p></li>
<li><p>我理解划分资源通常是设计REST接口的时候，其依据是业务实体和业务过程对业务实体的使用，而不是某个系统某个功能对它的使用方式。因为一个资源不是为一个系统一个功能服务的，而是为一个业务一个企业服务的，它不知道使用它的会是谁，会是什么方式。</p></li>
<li><p>“各类终端(IOS/html/android)等的Form应该是统一的”这个不太理解，我理解即使在同一个平台上，不同的操作上下文中，也存在同一个业务对象映射到不同Form的情况。比如一个订单，有可能在一个页面上被扼要展示，在另一个页面上却详细展示，在可打印页面上又是另一种展示方式。Form的概念，完全是一个展示逻辑的概念，不是业务逻辑的概念。</p></li>
</ul>
</li>
<li>HTTP远程调用

<ul>
<li>既然作出了PF-REST，为什么不是推广REST？是因为REST不是我们的方向，还是感觉现阶段实现不了？</li>
</ul>
</li>
</ul>


<h3>答复: 关于REST风格 &ndash; XN</h3>

<ul>
<li><p>缓存</p>

<p>我所理解的REST，它是与MVC一样，是一个基于HTTP协议的WEB层框架。在WEB层框架上处理全局的数据缓存是不合适的，比较多的是会话级别的(HTTPSession)。</p>

<p>数据缓存本身涉及数据完整性，是要很小心地控制的。</p>

<p>通过HTTP响应头控制浏览器的缓存，Spring3REST好像没有相应实现，还是我没有发现？其它的REST框架有实现？是否有例子？</p></li>
<li><p>会话</p>

<p>实际情况是，会话级别的缓存不可避免，大部分在应用需要登陆，至少uid需要缓存的。</p></li>
<li><p>资源</p>

<p>首先，资源抽象依据是什么？DTO？表?
如果是DTO或表，那要Services干什么?</p>

<p>所以PF-REST提出以Form表单为抽象依据，各类终端(IOS/html/android)等的Form应该是统一的。</p></li>
<li><p>HTTP远程调用</p>

<p>其实，PF推广的就是基于接口、REST风格的前后端分工开发模式，以区别MVC开发模式，不是推广REST本身，一切还是HTTP协议。</p></li>
</ul>


<h3>答复: 关于REST风格 &ndash; CH</h3>

<p>没有去听这个分享，就我理解对于缓存部分有些看法：</p>

<ul>
<li><p>服务端缓存</p>

<p>我同意NLJ的说法，没有一概而论不适合缓存的情况,能缓存的数据都是指允许在缓存更新周期内不一致的数据，</p>

<p>数据自身属性决定是否适合缓存，和REST不REST有啥关系呢？</p>

<p>具体做法上，直接利用Spring的基于方法参数的缓存和REST结合最合适，比如URL中有一部分代表方法，有一部分代表参数，在REST的实现方法中调用Service接口时传入这个参数，就可以把缓存做这个Service的接口方法上。</p></li>
<li><p>客户端缓存</p>

<p>REST接口一般返回JSON或者XML，这个json或者xml实际是可以当作普通图片这样的资源缓存在浏览器缓存中，只要服务端有控制Etag和失效日期，这样的话重复请求时服务端返回304，实际结果是直接来自于IE缓存的。</p>

<p>至于安全性，我觉得这个和cookie在IE中存放是一个级别的，既然cookie都可以，那么这个缓存为啥不可以？</p></li>
</ul>

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>邮件按时间倒序，已经对人名和涉及到公司的专用名字做了更改。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
