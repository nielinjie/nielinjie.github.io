<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 产品 | 聂同学]]></title>
  <link href="http://www.nietongxue.xyz/blog/categories/chan-pin/atom.xml" rel="self"/>
  <link href="http://www.nietongxue.xyz/"/>
  <updated>2017-06-25T16:00:42+08:00</updated>
  <id>http://www.nietongxue.xyz/</id>
  <author>
    <name><![CDATA[nielinjie]]></name>
    <email><![CDATA[nielinjie@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[知识在此（一）：脑图大开]]></title>
    <link href="http://www.nietongxue.xyz/blog/2014/08/02/pkc/"/>
    <updated>2014-08-02T16:06:38+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2014/08/02/pkc</id>
    <content type="html"><![CDATA[<p><a href="http://pckmmap.duapp.com/" target="_blank">“知识在此：脑图大开”</a> ps：不是“脑洞大开”……</p>

<!-- more -->


<p>这是一个“脑图”工具。</p>

<p>脑图工具是本人一直重度依赖的思考工具。
所以也是<a href="/blog/2014/08/02/pkc0/">“知识在此”</a>系列的第一个工具。</p>

<p>这个工具将按照本人对脑图的需求和期待来改进。大家有任何意见和期待，请给随时我反馈。</p>

<p>目前看到近期的路线图可能是：</p>

<ul>
<li>云端存储和共享。</li>
<li>演示模式。</li>
<li>应用插件。</li>
<li>移动适配。</li>
</ul>


<p><img src="/images/pkc/mm.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[知识在此（零）]]></title>
    <link href="http://www.nietongxue.xyz/blog/2014/08/02/pkc0/"/>
    <updated>2014-08-02T14:06:38+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2014/08/02/pkc0</id>
    <content type="html"><![CDATA[<p>什么是“知识在此”？</p>

<!-- more -->


<p>“知识在此”是我正在致力于的“个人知识管理工具系列”。</p>

<p>在信息爆炸的时代，信息只有经过过滤、整理、归纳才能成为知识。</p>

<p><img src="/images/pkc/ivk.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[企业中需要什么样的社交？]]></title>
    <link href="http://www.nietongxue.xyz/blog/2014/06/05/social/"/>
    <updated>2014-06-05T16:06:38+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2014/06/05/social</id>
    <content type="html"><![CDATA[<p>正在考虑这个问题。
目前想到几点：</p>

<!-- more -->


<ul>
<li><p>业务系统、办公系统和所有工作环境中随时可以发起社交活动。<br/>
企业中的社交以工作中的沟通和协作为主，工作事务中随时可以发起社交很重要。</p></li>
<li><p>社交中要可以方便地包含“业务上下文” 。
不论是即时通讯、协作、还是活动流、备忘录，需要能方便地插入“业务上下文”。
“业务上下文”是由业务系统定义，是对一个事务进行介入的入口，比如正在处理的订单，正在审批的文件等。<br/>
大概包括功能、用户、业务对象等重要要素。</p></li>
<li><p>社交中要容易为单个事务建立独立的“通道”。<br/>
工作中的社交跟生活中的社交不同，并不希望各种人和事交织在一起，
而是希望每件事务可以有个相对隔离的空间，在这个空间中不要被其他人和事干扰。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[能不能建立去中心化的言论机制？]]></title>
    <link href="http://www.nietongxue.xyz/blog/2013/08/20/distribute-saying/"/>
    <updated>2013-08-20T21:36:38+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2013/08/20/distribute-saying</id>
    <content type="html"><![CDATA[<p>在《知乎》问的这个问题，不知道有没有人一起来讨论。</p>

<!-- more -->


<h2>有没有办法？</h2>

<ul>
<li>去中心化后人们如何建立联系？- 通过利用现有的网络资源，建立分散式的存储和通信。比如用户端间直连、在现有言论平台发布某些信息、在paas、iaas上快速建立发布节点、利用传统p2p文件分享机制传递文件形式的信息。</li>
<li>去中心化后人们如何建立信任？- 类似于GPG的签名机制，熟人间传递公钥识别陌生人。</li>
<li>去中心化后人们如何建立秩序？- 私密的言论圈，秩序由用户自己负责。</li>
<li>……</li>
</ul>


<h2>有没有意义？</h2>

<ul>
<li>现有中心言论平台充斥混乱、谎言、压制。</li>
<li>人们有权接受和发送自己选择的信息。</li>
<li>……</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[这些年写过的代码（一）]]></title>
    <link href="http://www.nietongxue.xyz/blog/2013/01/23/code/"/>
    <updated>2013-01-23T21:36:38+08:00</updated>
    <id>http://www.nietongxue.xyz/blog/2013/01/23/code</id>
    <content type="html"><![CDATA[<p>2012年的最后两天，终于完成了一个久拖不决的任务：把几年来写过的代码review了一番。</p>

<!-- more -->


<p>这里记录的都是业余时间写的代码，它们往往都是以（企图）解决生活中的一个实际问题开始的，然后变成了当时流行的技术的试验场。这种情况下，最后当然往往把最初要解决的那个问题抛之脑后，无法挽回其烂尾命运。</p>

<h2>一、爬虫</h2>

<p>这是web爬虫程序。这个程序要解决的问题起源于从某个在线看书网站批量下载小说章节。后续又有批量下载mm图片的兴趣，使这个程序源远流长。
在这个问题中，程序逻辑主要集中在几个问题——</p>

<ul>
<li>爬虫线程管理：网络内容获取是耗时和不确定的io操作，需要管理其状态。同时爬虫往往是从前一个爬虫衍生的，所以所有爬虫线程中，既有并列关系的线程，也有先后关系的线程。</li>
<li>爬虫群中间状态管理：爬虫群不一定能一次完成所有想要内容的获取，需要把中间状态保存下来，同时由于web内容是持续更新的，爬虫群也需要支持发现和获取更新的操作，这也要求记录中间状态。显然，中间状态必须在多个爬虫线程间共享。</li>
<li>内容对象：爬虫群从web中获得的内容需要按照业务意义进行组织，形成一个对象团。这个对象团不同于爬虫群中间状态，也往往不直接对应于所爬过的网站结构。</li>
<li>爬虫行进路线：这个爬虫不是对页面上所有的链接进行跟进，而是根据网站结构，有目的的爬向有意义的内容，是有路线图的。以下载小说为例，第一个页面是排行榜，我们爬向某本书的链接而不是爬向广告，同样，到了具体的内容页面，我们尽量爬向“下一页”而不是“下一章”。</li>
<li>上述四点，前两个问题是所有爬行任务都一样的，后两个问题是每个爬行任务不同的，是对爬行任务的描述。这两个层面，分别是操作层和知识层，如何处理他们的联系，也是一个重要问题。</li>
</ul>


<p>这个程序我这里有groovy版、clojure版、scala版。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<p>最初是groovy<a href="http://groovy.codehaus.org">0</a>版，是直接从批量下载小说的需求引出的。</p>

<ul>
<li>groovy是我接触过的第一个jvm上的语言，闭包、动态特性和适度的magic，在某些场合非常合用。</li>
<li>groovy有称之为“builder”的风格，比如有xmlBuilder、httpBuilder……，类似Object Literal，简洁好用。</li>
<li>grovvy有现成的查询html中某些节点的工具。</li>
<li>有个griffon<a href="http://griffon.codehaus.org">1</a>，是仿照grails<a href="http://grails.org">2</a>的思想做的swing下的mvc框架。</li>
<li>这个版本以java内置的线程池管理线程。</li>
<li>这个版本没有区分操作层与知识层，没有考虑底层逻辑有可能被其他爬行任务服用的问题，没有从概念上区分中间状态对象、网站结构对象和内容对象。以网站结构对象为中心驱动：从一个结构对象中得到爬行线程对象，也从中抽取内容对象。</li>
</ul>


<p>然后是clojure<a href="http://clojure.org">3</a>版</p>

<ul>
<li>clojure是我见过的第一个把并发支持宣称为语言特性的一门语言。</li>
<li>clojure的lisp语法非常引人入胜。</li>
<li>当时对clojure没有对象（那时候想办法用record模拟，但别扭）这个特征非常迷惑，觉得没有对象咋能写程序呢？当然就更没办法去想什么操作层、知识层等等……</li>
<li>clojure的agent<a href="http://clojure.org/agents">4</a>，及其watch，非常适合爬行的底层逻辑。很方便的自动管理爬行线程间的并列、先后关系。</li>
<li>由于对FP<a href="http://en.wikipedia.org/wiki/Functional_programming">5</a>风格的不熟悉，不知道如何以这种风格去抽象逻辑层次，这个版本只实现了有限的底层逻辑。</li>
</ul>


<p>然后是scala<a href="http://www.scala-lang.org">6</a>版本，有好几个scala版本</p>

<ul>
<li>scala是个好语言。很多观点认为它有点太难学。不过我认为，如果你还没有完全学会，那你就像用java一样使用它，逐步领悟它的不同和强大之处。</li>
<li>sbt<a href="http://www.scala-sbt.org">7</a>好用。但有时候稍微复杂了点。只有最简单的情况可以声明式配置，稍微负载的情况就需要进行编程。</li>
<li>从scalaz<a href="http://code.google.com/p/scalaz/">8</a>我真正开始学习FP，有兴趣的同学可以详细读一下scalaz的例子的源代码。生活在 OO<a href="http://en.wikipedia.org/wiki/Object-oriented_programming">9</a>、imperative<a href="http://en.wikipedia.org/wiki/Imperative_programming">10</a> 世界的同学将会感到耳目一新，逐渐感到OO乃至imperative在某些方面相对乏力<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。</li>
<li>第一个版本我纠结于如何实现对象在线程间共享，我采用的策略是不共享，把公共对象封装在actor<a href="http://www.scala-lang.org/node/242">11</a>之下，由actor机制实现线程间通讯，不是所有线程都直接访问公共对象。现在scala已经吸纳了akka<a href="http://akka.io">12</a>的actor实现，比以前更加强大了。</li>
<li>第一个版本还研究了如何抽象在一个大对象中访问、修改某个深层属性，那时候不知道有Lens<a href="https://blog.stackmob.com/2012/02/an-introduction-to-lenses-in-scalaz/">15</a>这种模式。</li>
<li>第一个版本开始意识到操作层和知识层的不同，同时由于scala的OO、FP混合特性，我可以自如的进行抽象建模，两个层次完全分开。当面临不同的爬行任务，我只需定义新的内容对象和爬虫行进路线。</li>
<li>这里虽然没有进一步抽象出DSL<a href="http://en.wikipedia.org/wiki/Domain-specific_language">13</a>，但对DSL和其在scala的实现办法进行了一些研究，Internal DSL<a href="http://martinfowler.com/bliki/DomainSpecificLanguage.html">14</a>方面，scala没有groovy容易；但由于几个方便的工具，External DSL<a href="http://martinfowler.com/bliki/DomainSpecificLanguage.html">14</a>反倒是比较方便 —— 比如Kiama<a href="http://kiama.googlecode.com">16</a>、Parboiled<a href="https://github.com/sirthias/parboiled/wiki/parboiled-for-Scala">17</a></li>
<li>第二个版本出现在我发现STM<a href="http://nbronson.github.com/scala-stm/">20</a>在scala也有实现的时候，除了大对象共享方式不同，其他跟第一个版本大同小异。</li>
<li>第三个版本出现在我迷恋上Applicative、Monad、Arrow<a href="http://www.haskell.org/haskellwiki/Typeclassopedia">18</a> 、Iteratee<a href="http://www.haskell.org/haskellwiki/Enumerator_and_iteratee">19</a>等FP模式<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>的时候，我感到OO的编程模式丑陋而无法忍受，我要Lens，大对象要不可变、线程要被隐藏在并发模型之后、爬行任务的生成要实现Iteratee模式，总之我想以FP的“优雅”的方式实现这个程序。结果是，还没写完……。</li>
<li>我意识到自己在强迫自己使用不一样的、不熟悉的、听上去很牛的编程风格，只领略这些风格的不同和神奇，而没有认真思考这种不同有没有真正带来好处。<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></li>
</ul>


<p>最后有个Android版本，原本想实现在android上的爬行，并且开始探索scala在android上运行的可行性。但这个版本由于我迅速成为果粉而无疾而终。</p>

<p>（待续）</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>已经相当长时间没有关注groovy、grails、griffon、clojure的相关内容了，观点可能过期。scala相关的略好些。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>将FP跟OO、Imperative对立并不严密。但这里不打算仔细区别这个，我这里的OO、Impaerative指的通常的java、c#、c/c++之类的“主流”语言。<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>这里列出的都是Haskell的地址，因为Haskell有页面集中说明这些东西是啥。实际操作中还是用的scalaz实现版本。<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>我这样说完全不是指我反对FP风格。实际上我非常喜欢这种风格。我的意思只是，在学习的时候，需要更多的思考。<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
