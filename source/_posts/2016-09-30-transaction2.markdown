---
layout: post
title: "分布式事务，也谈（之二）"
date: 2016-09-26 16:08:48 +0800
comments: true
categories: ["架构","设计"]
series: ["分布式事务，也谈 2"]
published: true
---

如前一篇提到的 [^2]，本篇谈一谈实现模型[^1]。

<!--more-->

过程管理常常被实现为一个状态机，这里顺着这个思路尝试一番。

1. 每个操作实现为一个状态机，称为“操作状态机”。
2. 使用一个外层状态机处理决策过程，实现决策表。称为“决策状态机”。
3. 操作状态机嵌入决策状态机，作为内嵌状态[^3]。决策状态机和操作状态机分别是外层状态机和内层状态机。
4. 内层状态机对外层隐藏它自己能够独立处理的逻辑。仅向外暴露最终的对外**状况**和可以被外层**处置**的事件。
5. 逻辑在内外层之间的分配是最重要的一个权衡。如果内层逻辑太多则外层可以做的处置就太少，控制能力有限。如果内层逻辑太少，就将大量复杂性丢给外层，外层负担太重。这两种情况，层次结构都失效了。
6. 内外层之间通过事件沟通，内层产生的最终状况通过事件送达外层决策，外层决策做出的处置也通过事件操作内层。
7. 操作的撤销可以视为另一个操作，实现为一个独立的操作状态机。也可以与操作本身一起实现为同一个状态机。这是内外层的逻辑分布进行权衡的一个例子。
8. 决策表，是外层逻辑的核心，是一些规则的集合，规则的输入是各个操作的对外状况，输出是对各个操作的处置。[^4]
9. 决策逻辑可能会很复杂，比如有时候决策逻辑不仅依赖于当前输入，还会依赖于决策历史。此时需要权衡，可以把特别复杂和不太可能发生的情况留给人工解决。
10. 整个结构还可能继续嵌套，也就是说整个状态机可能还是更外层状态机的一个内嵌状态机。
11. 上述整个结构，是对应于一个事务的。处理多个事务，就是同时并存的多个状态机实例。




（[下一篇](/blog/2016/10/06/transaction3/)，继续谈实现模型）

附图：

{% img  /images/transaction/transaction2.png 500 %}


[^1]: 此处并没有任何可以直接应用的结论或代码。“干货”并非是本博的主要内容，参见：[时事：干货](/blog/2016/05/20/dry/)
[^2]: 本篇所有概念和名词都延续自[前一篇](/blog/2016/09/19/transaction/)。
[^3]: Wiki：[Hierarchically_nested_states](https://en.wikipedia.org/wiki/UML_state_machine#Hierarchically_nested_states)
[^4]: 决策表的例子见[前一篇](/blog/2016/09/19/transaction/)，但要注意，前一篇的例子中，对操作的处置是很细节的，在很多场景中不一定适合，如上面第5点讨论的。